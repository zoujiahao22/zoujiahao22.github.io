<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>小邹的博客 | 小邹的博客</title><meta name="author" content="小邹"><meta name="copyright" content="小邹"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="2Redis 项目 Redis快速入门sql和nosql区别关系型数据库SQL  和 非关系型数据库 NoSQL的区别:    Redis是一个基于内存的键值型NoSQL数据库,有以下的特征: 1.键值型,value支持多种不同数据结构,功能丰富 2.单线程,每个命令具备原子性 3.低延迟,速度快(基于内存、IO多路复用、良好的编码) 4.支持主从集群、分片集群 5.支持多语言客户端 Redis常">
<meta property="og:type" content="article">
<meta property="og:title" content="小邹的博客">
<meta property="og:url" content="https://www.zoulifelogs.cn/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis-%E9%A1%B9%E7%9B%AE/index.html">
<meta property="og:site_name" content="小邹的博客">
<meta property="og:description" content="2Redis 项目 Redis快速入门sql和nosql区别关系型数据库SQL  和 非关系型数据库 NoSQL的区别:    Redis是一个基于内存的键值型NoSQL数据库,有以下的特征: 1.键值型,value支持多种不同数据结构,功能丰富 2.单线程,每个命令具备原子性 3.低延迟,速度快(基于内存、IO多路复用、良好的编码) 4.支持主从集群、分片集群 5.支持多语言客户端 Redis常">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_10.webp">
<meta property="article:published_time" content="2024-07-28T12:26:36.013Z">
<meta property="article:modified_time" content="2024-07-24T10:20:46.984Z">
<meta property="article:author" content="小邹">
<meta property="article:tag" content="运动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_10.webp"><link rel="shortcut icon" href="https://www.fomal.cc/favicon.ico"><link rel="canonical" href="https://www.zoulifelogs.cn/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis-%E9%A1%B9%E7%9B%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '小邹的博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-24 18:20:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_10.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="小邹的博客"><span class="site-name">小邹的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-28T12:26:36.013Z" title="发表于 2024-07-28 20:26:36">2024-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-24T10:20:46.984Z" title="更新于 2024-07-24 18:20:46">2024-07-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="2Redis-项目"><a href="#2Redis-项目" class="headerlink" title="2Redis 项目"></a>2Redis 项目</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418141457766.png" alt="image-20240418141457766"></p>
<h1 id="Redis快速入门"><a href="#Redis快速入门" class="headerlink" title="Redis快速入门"></a>Redis快速入门</h1><h4 id="sql和nosql区别"><a href="#sql和nosql区别" class="headerlink" title="sql和nosql区别"></a>sql和nosql区别</h4><p><strong>关系型数据库SQL  和 非关系型数据库 NoSQL的区别:</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418234841852.png" alt="image-20240418234841852" style="zoom:67%;" /> 

<p><strong>Redis是一个基于内存的键值型NoSQL数据库,有以下的特征:</strong></p>
<p>1.键值型,value支持多种不同数据结构,功能丰富</p>
<p>2.单线程,每个命令具备原子性</p>
<p>3.低延迟,速度快(基于内存、IO多路复用、良好的编码)</p>
<p>4.支持主从集群、分片集群</p>
<p>5.支持多语言客户端</p>
<h4 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h4><p><strong>Redis数据结构介绍</strong></p>
<p>Redis是一个key-value的数据库，<strong>key</strong>一般是<strong>String类型</strong>，不过value的类型多种多样</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418235953715.png" alt="image-20240418235953715" style="zoom:67%;" />

<p><strong>Redis通用命令</strong> </p>
<p>对任何数据类型都适用的命令,常见的有:</p>
<p><strong>KEYS</strong>:查看符合模版的所有key,</p>
<p><strong>DEL</strong>:删除一个指定的key</p>
<p><strong>EXISTS</strong>:判断key是否存在</p>
<p><strong>EXPIRE</strong>:给一个key设置有效期,有效期到期时key会被自动删除</p>
<p><strong>TTL</strong>:查看一个key的剩余有效期</p>
<p>通过<strong>help [command]</strong> 可以查看一个命令的具体用法,例如:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419003533546.png" alt="image-20240419003533546" style="zoom:67%;" />

<h4 id="Redis常见的五种数据结构"><a href="#Redis常见的五种数据结构" class="headerlink" title="Redis常见的五种数据结构:"></a>Redis常见的五种数据结构:</h4><h5 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1.String类型"></a>1.<strong>String类型</strong></h5><p>也就是字符串类型,是Redis最简单的存储形式</p>
<p>其中value是字符串,不过根据字符串的格式不同,分为三类:</p>
<p><strong>1.string</strong>:普通字符串</p>
<p><strong>2.int:整数类型</strong>,可以做自增、自减操作</p>
<p><strong>3.float浮点类型</strong>，可以做自增、自减操作</p>
<p>不管哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512M</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419004332753.png" alt="image-20240419004332753" style="zoom:67%;" /> 

<p><strong>String类型的常见命令</strong> </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419010959587.png" alt="image-20240419010959587" style="zoom:50%;" /> 

<p><strong>key的结构</strong></p>
<p>Redis的key允许有多个单词形成<strong>层级结构</strong>，多个单词之间用‘ ：’隔开，格式如下：</p>
<p>​         项目名：业务名：类型：id              格式并非固定</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419012005325.png" alt="image-20240419012005325" style="zoom:67%;" /> 

<h5 id="2-Hash类型"><a href="#2-Hash类型" class="headerlink" title="2.Hash类型"></a>2.<strong>Hash类型</strong></h5><p>Hash类型，也叫散列，其value是一个无序字典，类似于java中的HashMap结构</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419130743896.png" alt="image-20240419130743896" style="zoom: 67%;" /> 

<p><strong>Hash类型常见命令</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419132300636.png" alt="image-20240419132300636" style="zoom:67%;" /> 

<h5 id="3-list类型的常见命令"><a href="#3-list类型的常见命令" class="headerlink" title="3.list类型的常见命令"></a>3.<strong>list类型的常见命令</strong></h5><p>List中的List类型与java中的LinkedList类似，可以看成是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<p>有序   元素可以重复   插入与删除快  查询速度一般    </p>
<p>常用来存储一个有序数据，比如<strong>朋友圈点赞列表</strong>，<strong>评论列表</strong>等。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419134349259.png" alt="image-20240419134349259" style="zoom:67%;" /> 



<h5 id="4-Set类型"><a href="#4-Set类型" class="headerlink" title="4.Set类型"></a>4.<strong>Set类型</strong></h5><p>redis的set结构与java中的hashset类似，可以看作是一个value为null的HashMap。因为它是一个hash表，因此具备与HashSet类似的特征：</p>
<p><strong>无序</strong>、<strong>元素不可重复</strong>、查找快、支持交集、并集、差集等功能</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421001657154.png" alt="image-20240421001657154" style="zoom:67%;" /> 

<h5 id="5-SortedSet类型"><a href="#5-SortedSet类型" class="headerlink" title="5.SortedSet类型"></a>5.SortedSet类型</h5><p>redis的sortset是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大。sortedset中的每个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个<strong>跳表SkipList加hash表</strong></p>
<p>sortedSet具有下列特性：</p>
<p><strong>可排序</strong>、元素不重复、查询速度快、</p>
<p>因为其可排序特性，经常被用来实现<strong>排行榜</strong>这样的功能。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421005100146.png" alt="image-20240421005100146" style="zoom: 50%;" /> 

<h4 id="Redis的java客户端"><a href="#Redis的java客户端" class="headerlink" title="Redis的java客户端"></a>Redis的java客户端</h4><p>提供了 Redis 命令对应的 API，方便我们操作 Redis</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421011031969.png" alt="image-20240421011031969" style="zoom:67%;" />

<p><strong>Spring Data Redis</strong> 定义了一套Api,Api底层既可以用jedis也可以用lettuce实现.我们后期直接学习Spring Data Redis.</p>
<h5 id="1-Jedis快速入门"><a href="#1-Jedis快速入门" class="headerlink" title="1.Jedis快速入门"></a>1.<strong>Jedis快速入门</strong></h5><p><strong>jedis 操作步骤:</strong></p>
<ol>
<li><p>引入依赖</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112723122.png" alt="image-20240421112723122"> </p>
</li>
<li><p>建立连接,创建jedis对象</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112741720.png" alt="image-20240421112741720" style="zoom:67%;" /> 
</li>
<li><p>测试string  使用jedis,方法名与Redis命令一致.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112812820.png" alt="image-20240421112812820" style="zoom:67%;" /> 

<ol start="4">
<li><p>释放资源</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112834150.png" alt="image-20240421112834150" style="zoom: 80%;" /> 

<p> <strong>Jedis连接池</strong></p>
<p>jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此使用jedis连接池代替jedis的直连方式</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523014644281.png" alt="image-20240523014644281" style="zoom:67%;" /></li>
</ol>
</li>
</ol>
<p><strong>SpringDataRedis</strong></p>
<p>SpringData是Spring中数据操作的模块,包含对各种数据库的集成,其中对Redis的集成模块就叫做SpringDataRedis</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421155600443.png" alt="image-20240421155600443" style="zoom:67%;" /> 

<p><strong>SpringDataRedis快速入门</strong>(<strong>重点</strong>)</p>
<p>SpringDataRedis中提供了**RedisTemplate工具类,**其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421233012858.png" alt="image-20240421233012858" style="zoom:50%;" /> 

<p><strong>1.引入依赖</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421231014908.png" alt="image-20240421231014908" style="zoom:50%;" /> 

<ol start="2">
<li><p><strong>配置文件</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421232302361.png" alt="image-20240421232302361" style="zoom:67%;" /> 

<p><strong>3.注入RedisTemplate</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421232743397.png" alt="image-20240421232743397"> 4</p>
<p>4.<strong>编写测试</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421232804441.png" alt="image-20240421232804441" style="zoom:67%;" /> 

<h5 id=""><a href="#" class="headerlink" title=""></a></h5></li>
</ol>
<h5 id="2-自定义序列化的方式"><a href="#2-自定义序列化的方式" class="headerlink" title="2.自定义序列化的方式"></a>2.自定义序列化的方式</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过写入前会把Object序列化为字节形式,默认采用JDK序列化,得到的结果是这样的:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523091401635.png" alt="image-20240523091401635"></p>
<h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><p>可读性差</p>
<p>内存占用较大</p>
<p>这时候就需要我们自定义RedisTemplate的序列化方式:</p>
<p>自定义Redisconfig类,添加@Configuration标记为配置类</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523093642108.png" alt="image-20240523093642108"></p>
<p>这里采用了<strong>JSON序列化来替代默认的JDK序列化方式</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523093912096.png" alt="image-20240523093912096"></p>
<p>能将java对象自动的序列化为JSON字符串,并且查询时能自动将JSON反序列化为java对象.</p>
<p>写入了JSON的同时,也写入了class属性,对应的就是java对象字节码的名称,正是因为有这样的属性,所以在序列化的时候能读取对应的字节码也就是类的名称,然后将json实现反序列化.</p>
<p>但这样会带来<strong>额外的内存开销.</strong></p>
<h5 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a><strong>StringRedisTemplate</strong></h5><p>为了节省内存空间,我们并不会使用JSON序列化器来处理value,而是统一使用String序列化器,要求只能存储Sring类型的key和value,当需要存储java对象时,<strong>手动完成对象的序列化和反序列化.</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523102557410.png" alt="image-20240523102557410"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523103914868.png" alt="image-20240523103914868"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240422150118545.png" alt="image-20240422150118545" style="zoom: 67%;" /> 



















<h1 id="Redis企业实战"><a href="#Redis企业实战" class="headerlink" title="Redis企业实战"></a>Redis企业实战</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240422152145710.png" alt="image-20240422152145710" style="zoom: 67%;" /> 

<p><strong>短信登录</strong>:   利用Redis的共享session来实现</p>
<p><strong>商户缓存查询</strong>:企业的缓存使用技巧,了解缓存雪崩、穿透击穿等问题及解决方案</p>
<p><strong>优惠券秒杀：</strong>Redis的计数器、lua脚本Redis 、Redis分布式锁的原理，Redis的三种消息队列</p>
<p><strong>达人探店：</strong>基于List的点赞列表，基于SortedSet的点赞排行榜</p>
<p><strong>好友关注</strong>：基于Set集合的关注、取关、共同关注、消息推送等功能</p>
<p><strong>附近商铺：</strong>Redis的Geohash的应用</p>
<p><strong>用户签到：</strong>Redis的BitMap数据统计功能</p>
<p><strong>UV统计：</strong>Redis的HyperLog的统计功能</p>
<p>该项目是个单体项目，采用前后端分离模式，前端部署在NGINX服务器上，后端部署在tomact上。当pc端发起请求的时候，请求页面也就是向NGINX发起请求得到静态资源，页面通过nigix向服务端发起请求去查询数据，数据可能来自mysql集群或者Redis集群，把查询到的数据返回给前端，前端完成渲染就ok了。</p>
<p>项目开始前，在<strong>application.yaml</strong>中要进行项目配置，数据的连接池配置，redis地址</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523150334083.png" alt="image-20240523150334083" style="zoom:50%;" /> 



<h2 id="1-短信登录"><a href="#1-短信登录" class="headerlink" title="1.短信登录"></a>1.短信登录</h2><h5 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240423004145660.png" alt="image-20240423004145660"></p>
<p> <strong>1.发送短信验证码</strong></p>
<p>用户提交自己手机号,服务端接收到手机号去校验手机号是否合法,不合法重新提交手机号,合法的话,生成一个验证码保存在session中后 将验证码发送给用户.</p>
<p><strong>2.短信验证码登录、注册</strong>(两功能合二为一)</p>
<p>用户提交手机号和验证码,后台拿到session之前保存的验证码和用户输入的验证码进行对比,不一致的话校验不通过,一致的话后台再根据手机号去查询用户是否存在,如果不存在的话就注册新用户,为该手机号创建账号信息,保存到数据库中,并将<strong>新创建</strong>的用户登录信息保存到session中,如果存在的话就直接将用户信息保存在session中.</p>
<p><strong>3.校验登录状态.</strong></p>
<p>登录成功后,用户访问一些关键的业务的时候,需要校验登录状态.</p>
<p>session是基于cookie的, 每一个session都有一个sessionid保存在浏览器cookie当中</p>
<p>用户请求访问的时候,会携带cookie,cookie中就有个sessionid,后台通过sessionid找到对应session,看是否存在该用户信息,存在的话讲用户信息<strong>缓存到threadLocal</strong>中后续的业务可以直接从threadlocal中获取用户,并放行,没有的话,则进行拦截.</p>
<p>threadLocal是一个线程域对象，每一个请求到达我们的服务它都是一个独立的线程，如果没有使用threadlocal而是使用本地变量的话，可能会出现多线程修改并发的安全问题，threadLocal会将数据保存到每一个线程的内部，在线程内部创建有一个map去保存，每个线程都有自己独立的存储空间，每一个请求来了会有自己的空间，相互间不干扰。后续的业务都可以直接从threadlocal中取出自己的用户信息。</p>
<p>1.发送短信验证码代码实现:（调用阿里云短信平台  ）</p>
<p>编写一个业务的接口来实现前端的请求,然后按照业务流程来逐一实现.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523155444017.png" alt="image-20240523155444017" style="zoom:50%;" />



<p>在service接口的实现类中写的代码:</p>
<p>发送验证码:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523165857041.png" alt="image-20240523165857041"></p>
<p>2.短信验证码校验登录:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523203735827.png" alt="image-20240523203735827" style="zoom: 50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523203749286.png" alt="image-20240523203749286" style="zoom:50%;" />

<p>3.校验登录状态</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523204352374.png" alt="image-20240523204352374" style="zoom:80%;" />

<p>前端传递过来的请求都先经过拦截器</p>
<p>想将拦截器拦截到的用户信息传递到Controller中去,传递的过程中需要注意线程安全问题:将用户信息保存到<strong>ThreadLocal</strong>中去</p>
<p>设置一个登录拦截器,loginInterceptor,实现HandlderInterceptor接口中的preHandle前置拦截（<strong>做登录校验的</strong>）和afterCompletion(<strong>业务执行完毕</strong>，<strong>移除用户,避免内存泄漏</strong>).拦截器在session中获取用户信息,再存储到线程池</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524002620938.png" alt="image-20240524002620938" style="zoom: 50%;" /> 

<p>在Mvcconfig类中去配置拦截器的拦截范围.配置类用@Configuration告诉spring在启动时候加载配置,在配置类中将拦截的对象@Autowired,再去配置拦截的过滤属性.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524002811236.png" alt="image-20240524002811236" style="zoom:50%;" /> 



<p>**集群的session共享问题:**多台Tomcat并不共享session存储空间, 当请求切换到 不同tomcat服务时导致数据丢失的问题.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524003427092.png" alt="image-20240524003427092" style="zoom: 50%;" />

<p>每个 tomcat 中都有一份属于自己的 session, 假设用户第一次访问第一台 tomcat，并且把自己的信息存放到第一台服务器的 session 中，但是第二次这个用户访问到了第二台 tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的 session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是 session 拷贝，就是说虽然每个 tomcat 上都有不同的 session，但是每当任意一台服务器的 session 修改时，都会同步给其他的 Tomcat 服务器的 session，这样的话，就可以实现 session 的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份 session 数据，服务器压力过大。</p>
<p>2、session 拷贝数据时，可能会出现延迟</p>
<p>所以咱们后来采用的方案都是基于 redis 来完成，我们把 session 换成 redis，redis 数据本身就是共享的，就可以避免 session 共享的问题了。redis是在tomcat以外的一个存储方案，任何一台tomcat都能访问到redis。</p>
<p><strong>session的替代方案应该满足:</strong></p>
<p>数据共享</p>
<p>内存存储</p>
<p>key、value结构</p>
<h5 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a><strong>基于Redis实现共享session登录</strong></h5><p>Redis的实现思路:</p>
<p>设计存储的key和value:</p>
<p>key使用子串,value使用map&lt;k,v&gt;结构</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524005906113.png" alt="image-20240524005906113" style="zoom: 80%;" /> 

<p><strong>优化后的流程</strong>:</p>
<p>将<strong>session</strong>替换成<strong>了redis</strong>,发送短信验证码时候,保存验证码到redis中时**,key是手机号<strong>，</strong>value是验证码**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524010937204.png" alt="image-20240524010937204"></p>
<p>以<strong>随机token</strong>为key存储用户数据,再将用户保存到redis之后,还要将token返回给客户端(浏览器)并保存,以便再校验登录状态时,请求中携带Token,从Redis中获取用户.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524011048843.png" alt="image-20240524011048843"></p>
<p>将基于Redis共享session实现短信登录功能改动部分:</p>
<p><strong>1.在发送短信验证码部分:</strong></p>
<p>只有一个改动,保存验证码不在保存在session中,而是保存在Redis中,保存到Redis中时,<strong>key不再是”code”,而是手机号</strong>.确保每个手机号都有自己唯一的key,在登陆时能基于手机号取到验证码,从而实现验证.</p>
<p><strong>2.短信验证码登录和注册部分:</strong></p>
<p>2.1将从session中获取验证码改成从Redis中获取验证码</p>
<p>2.2将保存用户信息到session中改成保存用户信息到Redis中,并且以随机token为key存储用户数据(使用uuid获取随机数),将User对象转换成Hash存储,最后返回token给客户端,可以理解成返回给前端,保存在浏览器（如何实现？前端把token保存在请求头中）,并设置token有效期.</p>
<p><strong>3.效验登录状态部分,修改拦截器:</strong></p>
<p>3.1.显示获取请求头中的token</p>
<p>3.2.然后基于token获取redis中的用户</p>
<p>3.3判断用户是否存在:不存在就拦截,存在的话将查询到的hash数据转换成UserDTO对象</p>
<p>3.4将用户信息保存在ThreadLocal中</p>
<p>3.5.最后刷新token有效期,放行.</p>
<p>**登录拦截器的优化:**为什么要去优化呢?因为我们给token设置了有效期，需要实现只要用户一直访问  token有效期就一直刷新这个功能。</p>
<p>如果用户一直访问的是不需要校验的路径比如首页,拦截器不会生效，当设置的token有效期过期时,他再去访问一些需要校验的路径那么就会出错,所以先设置一个拦截器来来拦截所有的路径,然后刷新token有效期.</p>
<p>**第一个拦截器的作用是得到用户,保存在ThreadLocal中,并且确保一切行为都会触发token刷新有效期这个动作.**不存在的话也会放行。拦截一切路径</p>
<p><strong>第二个拦截器其实做的是拦截的动作，查询threadlocal中的用户，不存在的话就拦截，存在的话就放行。</strong>拦截需要登录校验的路径。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240425000523202.png" alt="image-20240425000523202" style="zoom:67%;" /> 

<p>配置拦截器的部分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524141429899.png" alt="image-20240524141429899"></p>
<p>Redis代替session需要考虑的问题：</p>
<p>选择合适的数据结构：验证码 这种 就选用string类型的就行，像对象类型的这种采用hash，因为占用的存储空间更小，可以对单个字段进行修改，更加的灵活。</p>
<p>选择合适的key：一方面考虑他的唯一性，另一方面考虑下一次取的时候更加方便</p>
<p>设置有效期   ：避免长期存储，占用过多内存</p>
<p>选择合适的存储力度：只存储一些不敏感的数据 </p>
<p>thread的内存泄漏如何解决：在生成拦截器的时候实现了请求前和请求后，请求前存入threadlocal，请求后释放</p>
<h2 id="2-商户查询缓存"><a href="#2-商户查询缓存" class="headerlink" title="2.商户查询缓存"></a>2.商户查询缓存</h2><h5 id="2-1缓存："><a href="#2-1缓存：" class="headerlink" title="2.1缓存："></a>2.1<strong>缓存</strong>：</h5><p>数据交换的缓冲区，<strong>临时存储数据的地方</strong>，一般读写性能比较高</p>
<p>cpu会把经常需要读写的数据放到缓存中去</p>
<p><strong>缓存的作用：</strong></p>
<p>降低后端负载、提高读写效率、降低响应时间</p>
<p>缓存的成本：</p>
<p><strong>数据一致性成本</strong>（比如说我在redis缓存了数据库中的部分数据，当用户查询的时候 优先去查redis，减轻了数据库压力，如果数据库的数据发生了变化，而缓存的还是旧的数据，两者就产生了不一致。</p>
<p>代码维护成本</p>
<p>运维成本</p>
<p>缓存的作用模型和根据id查询商铺缓存的流程图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524184240374.png" alt="image-20240524184240374"></p>
<h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>是为了解决数据不一致的问题.Redis缓存了数据库中部分数据,但是后来数据库更新了,我们读取到的还是旧数据.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427000259422.png" alt="image-20240427000259422" style="zoom: 50%;" /> 

<p><strong>由缓存的调用者，在更新数据库的同时更新缓存。（在企业开发中常用）</strong></p>
<p><strong>操作缓存和数据库的时候有三个问题需要考虑：</strong></p>
<p><strong>1.删除缓存还是更新缓存？</strong></p>
<p>更新缓存：每次更新数据库都更新缓存，无效写操作较多</p>
<p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存(一般选这个)</p>
<p><strong>2.如何保证缓存与数据库的操作同时成功或失败？</strong></p>
<p>单体系统：将缓存与数据库操作放在一个事务</p>
<p>分布式系统：利用TCC等分布式事务方案</p>
<p><strong>3.先操作缓存还是先操作数据库</strong></p>
<p>看情况</p>
<p>一般来说先 更新数据库，再删除缓存的容错率更高些。</p>
<p><strong>缓存更新策略的最佳实践方案：</strong></p>
<p>1.低一致性需求：使用Redis自带的内存淘汰机制</p>
<p>2.高一致性需求：主动更新，并以超时剔除作为兜底方案</p>
<p><strong>读操作：</strong></p>
<p>缓存命中直接返回</p>
<p>缓存未命中则查询数据库，并写入缓存，设定超时时间</p>
<p><strong>写操作</strong>：</p>
<p>先写数据库，再删除缓存</p>
<p>要确保数据库与缓存操作的原子性</p>
<p>需求：给查询商铺的缓存添加超时剔除和主动更新的策略</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>1.根据id查询店铺，如果缓存未命中，则查询数据库，将数据库写入缓存，并设置超时时间</p>
<p>2.根据id修改店铺，先修改数据库，再删除缓存</p>
<p><strong>案例：实现商铺缓存和数据库缓存的双写一致</strong></p>
<p>思路:修改ShopController中的业务逻辑：</p>
<p>根据id查询去查询商家店铺，如果缓存未命中的话，则在数据库中查询，将数据库中的结果写入缓存，并设置超时时间。</p>
<p>根据id去更新商家店铺的时候，<strong>先修改数据库，再删除缓存</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524235539673.png" alt="image-20240524235539673" style="zoom:67%;" />







<h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a><strong>缓存穿透</strong>：</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525001450918.png" alt="image-20240525001450918" style="zoom: 67%;" />

<p>如果恶意用户，整无数的线程<strong>并发</strong>的来向这个不存在 数据发起请求的话，所有的请求都会到达数据库，很有可能把我们的数据库搞垮。</p>
<p>常见的解决方案：</p>
<p>1.<strong>缓存空对象</strong>：就是把null缓存在redis中</p>
<p>优点：实现简单，维护方便                                                        </p>
<p>缺点：额外的内存消耗       可能造成短期的不一致      </p>
<p>​                                                   </p>
<p><strong>2.布隆过滤</strong> 在redis和客户端之间加了一层拦截. 是一种算法，是利用哈希思想解决问题。通过一个庞大的二进制数组，用哈希思想去判断当前要查询的数据是否存在。但有个小缺点，就是它的判定不一定非常准确，它如果判定不存在的话，那么在数据库中一定不存在，但是如果判断存在的话，在数据库中可能不存在。</p>
<p>优点：内存占用较少，没有多余key</p>
<p>缺点：实现复杂，存在误判可能                                               </p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427160439307.png" alt="image-20240427160439307" style="zoom: 50%;" />



<p><strong>编码解决穿透的问题：</strong></p>
<p>原来的逻辑中如果请求的数据在数据库中不存在的话，会返回404，会造成缓存穿透的现象。</p>
<p>修改：</p>
<p>在缓存中未命中的话，去数据库中查询，如果存在则将数据写入到Redis缓存中，不存在将空值值写入Redis。当下一次请求进来的时候如果命中了缓存，在判断是否为空值，是的话直接返回null，不是的话返回商铺的信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525005654337.png" alt="image-20240525005654337"></p>
<p><strong>总结：</strong></p>
<p><strong>缓存穿透产生的原因是什么</strong>？</p>
<p>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大的压力</p>
<p><strong>缓存穿透的解决方案有哪些</strong>？</p>
<p>被动措施:</p>
<p>缓存null值   布隆过滤</p>
<p>主动:</p>
<p>  增强id的复杂度，避免被猜测id规律(雪花算法)</p>
<p>做好数据的基础格式校验  加强用户权限校验   做好热点参数的限流</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525013448388.png" alt="image-20240525013448388" style="zoom: 67%;" /> 

<p>缓存雪崩是指在同一时段<strong>大量的缓存key同时失效</strong>（比如说过期啊）或者<strong>Redis服务宕机</strong>,导致大量请求到达数据库,带来巨大压力.</p>
<p>解决方案:</p>
<p>给不同的key的TTL添加随机数值（避免key同时到期）</p>
<p>利用Redis集群提高服务的可用性（用来解决Redis宕机）</p>
<p>给缓存业务添加降级限流策略(微服务里面的)</p>
<p>给业务添加多级缓存</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>缓存击穿问题</strong>也叫热点key问题,就是一个被<strong>高并发访问</strong>（可能是在做活动的某件商品）并且<strong>缓存重建业务较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的压力</p>
<p>常见解决方案：</p>
<p>1.利用互斥锁来解决</p>
<p>就是当一个线程进来的时候发现未命中缓存，那么他将被上锁 ，其他线程无法对其干扰，该线程继续查询数据库并缓存数据，知道将缓存数据写入时，再释放锁。</p>
<p>缺点就是 万一有很多的线程同时访问，只能有一个线程进行写入缓存的操作，而其他的线程只能去等待。性能比较差吧。</p>
<p>2.逻辑过期（很佛系,有人在更新了,我先返回旧数据.）</p>
<p>当我们在redis中存储数据的时候，我们不再设置TTL，只是设置一个逻辑过期时间，如果线程1请求数据的时候发现逻辑时间过期了，那么他将获取一个互斥锁，并开启一个新的线程2去查询数据库并重建缓存数据，同时线程1返回过期的数据，线程2写入缓存后并设置逻辑过期时间，完成后释放锁，如果有其他的线程3在锁释放之前访问的话，也会返回过期的数据。性能比单纯的加互斥锁要好,因为线程不需要等待锁释放再执行.</p>
<p><strong>互斥锁和逻辑过期的流程:</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427205447397.png" alt="image-20240427205447397" style="zoom: 67%;" /> 

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427211529725.png" alt="image-20240427211529725" style="zoom: 50%;" /> 

<p>没有孰优孰劣之分,一个保证一致性一个保证可用性.根据需求来吧.</p>
<p><strong>基于互斥锁方式解决缓存击穿问题</strong> </p>
<p>需求:修改根据id查询商铺的业务,基于互斥锁方式来解决缓存击穿问题.</p>
<p><strong>核心的思路就是利用redis的setnx方法来表示获取锁</strong>，如果redis中没有这个key，则插入成功返回1，如果该key值已经存在了，则插入失败返回0. 成功在StringRedisTemplate中返回true，失败返回false。</p>
<p>成功插入的key的线程我们认为它是获得到锁的线程。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427214230769.png" alt="image-20240427214230769" style="zoom:67%;" /> 



<p><strong>基于逻辑过期方式解决缓存击穿问题</strong></p>
<p>该流程比较复杂:</p>
<p>当用户开始查询 Redis 的时候，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将 value 取出，判断 value 中的过期时间是否满足，如果没有过期，则直接返回 Redis 中的数据，如果过期了，则在开启独立线程后直接返回之前的数据，独立线程去实现缓存重建，重建完成后释放互斥锁。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525140933886.png" alt="image-20240525140933886" style="zoom:67%;" /> 



<h4 id="缓存工具封装类"><a href="#缓存工具封装类" class="headerlink" title="缓存工具封装类"></a>缓存工具封装类</h4><p>将缓存穿透击穿雪崩等问题的解决方案封装成工具</p>
<p>利用java提供的函数式编程的思想，去将数据库查询传递给我们的工具类，从而实现任意数据的数据库查询。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240526133246359.png" alt="image-20240526133246359" style="zoom: 67%;" />



<h2 id="3-优惠券秒杀"><a href="#3-优惠券秒杀" class="headerlink" title="3.优惠券秒杀"></a>3.优惠券秒杀</h2><h4 id="全局唯一id（下单时id的唯一性）"><a href="#全局唯一id（下单时id的唯一性）" class="headerlink" title="全局唯一id（下单时id的唯一性）"></a><strong>全局唯一id</strong>（下单时id的唯一性）</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240526143528201.png" alt="image-20240526143528201" style="zoom: 67%;" /> 

<p>当用户抢购时，会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增id就会存在一些问题：</p>
<p>1.id 的规律性太明显,能让用户猜测到一些信息(比如该商家一天卖了多少单)</p>
<p>2.受单表数据量的限制(存储数据量达到一定规模的时候,要将数据分到多张表,如果用自增加的话多个表的id会重复,违背了订单id不重复的这个逻辑)</p>
<p><strong>全局ID生成器</strong>:</p>
<p>是一种在分布式系统下用来生成<strong>全局唯一</strong>ID的工具</p>
<p>一般要满足以下特性：</p>
<p>唯一性、高可用、高性能、递增性、安全性</p>
<p>为了增强ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息.  时间戳+自增id.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240526151454258.png" alt="image-20240526151454258"></p>
<p>ID的组成部分：</p>
<p>符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2的32次方不同ID</p>
<p><strong>全局唯一ID生成策略:</strong></p>
<p>UUID</p>
<p>Redis自增</p>
<p>snowflake算法（雪花算法）</p>
<p>数据库自增（单独整一张表，单独用来做自增）</p>
<p><strong>Redis自增策略:</strong></p>
<p>每天一个key,方便统计订单量</p>
<p>ID构造是时间戳+计数器</p>
<h4 id="实现优惠券秒杀下单："><a href="#实现优惠券秒杀下单：" class="headerlink" title="实现优惠券秒杀下单："></a><strong>实现优惠券秒杀下单：</strong></h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527091138307.png" alt="image-20240527091138307" style="zoom:50%;" /> 

<p>tb_voucher:优惠券的基本信息，优惠金额，使用规则等</p>
<p>tb_seckil_voucher:优惠券的库存、开始抢购时间、结束抢购时间。特价优惠券才需要填写这些信息。</p>
<p><strong>优惠券秒杀下单流程图：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527095647692.png" alt="image-20240527095647692" style="zoom:67%;" /> 





<h4 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a><strong>库存超卖问题</strong></h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527140047524.png" alt="image-20240527140047524" style="zoom:67%;" />

<p>假设线程 1 过来查询库存，判断出来库存大于 1，正准备去扣减库存，但是还没有来得及去扣减，此时线程 2 过来，线程 2 也去查询库存，发现这个数量一定也大于 1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p>超卖问题是典型的<strong>多线程安全问题</strong>，针对这一问题常见的解决方案就是<strong>加锁</strong>：</p>
<p><strong>悲观锁：</strong></p>
<p>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</p>
<p>例如Synchronized、Lock都属于悲观锁</p>
<p><strong>乐观锁</strong>：(会出现aba问题)</p>
<p>认为线程安全问题不一定会发生，因此不加锁，<strong>只是在更新数据时去判断有没有其他线程对数据做了修改。</strong>（这一步判断是重点）</p>
<p>如果没有修改则认为是安全的，自己才更新数据</p>
<p>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</p>
<p><strong>判断之前查询到的数据是否有被修改过，常见的方式有两种：</strong></p>
<p><strong>1.修改版本号</strong>（应用最广泛和最普遍的）</p>
<p>给数据加上一个版本，每次操作数据成功后，版本号会加1，在查询库存和版本号时，查到了库存和对应的版本号，在准备修改数据时判断库存是否符合条件，并校验版本号是否还是之前查询到的版本号，如果版本号没变，则前面没有被其他人修改过，如果版本号变了，说明就被修改了。修改库存完成后，还要将版本号加1.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527142319556.png" alt="image-20240527142319556" style="zoom:50%;" />

<p><strong>2.CAS方法（用数据本身是否变化来判断线程是否安全）</strong>(会出现aba问题)</p>
<p>就是查询到库存信息 ，然后准备修改库存信息的时候，在判断库存是否和之前查询到的一样，如果不一样，则说明数据 中途被别人修改了。其实这种方法就是对修改版本号方法的一种简化。 视频中由于如果设置库存和之前查到的库存一样的话会导致成功率比较低,所以将库存判断条件设置成大于0即可.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527144654271.png" alt="image-20240527144654271" style="zoom:50%;" />



<p>优缺点：悲观锁：添加同步锁，让线程串行执行    优点：简单粗暴  缺点：性能一般</p>
<p>​               乐观锁：不加锁，在更新时判断是否有其他线程在修改   优点：性能好    缺点：存在成功率低的问题</p>
<h4 id="案例：实现优惠券一人一单"><a href="#案例：实现优惠券一人一单" class="headerlink" title="案例：实现优惠券一人一单"></a><strong>案例：实现优惠券一人一单</strong></h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527155049805.png" alt="image-20240527155049805" style="zoom: 67%;" />

<p>根据优惠券id和用户id查询订单,看在数据库中是否存在,不存在的话才允许去扣减库存</p>
<p>这部分有点难,不会.</p>
<h4 id="集群下的线程并发问题"><a href="#集群下的线程并发问题" class="headerlink" title="集群下的线程并发问题"></a>集群下的线程并发问题</h4><p>我们通过加锁可以解决在单机下的一人一单安全问题,但是在集群模式下就不行了.</p>
<p>1.将服务启动两份,搭建集群.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528091500398.png" alt="image-20240528091500398"> </p>
<p>2.修改n ginx的conf目录下的nginx.conf文件,配置反向代理和负载均衡.</p>
<p>负载均衡可以理解为一种算法来平衡多台服务器让他们根据权重来分担访问量.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528102430589.png" alt="image-20240528102430589"></p>
<p>在集群模式下,我们部署了多个tomcat,有多个jvm的存在,每个jvm内部都有自己的锁,导致每个锁都有一个线程获取,于是出现了并行问题,可能出现安全问题.</p>
<p>要解决这个问题,就是让多个jvm只能使用同一把锁.</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h4><p>原理就是一定要让让多个jvm进程看到同一个锁监视器,也就是多进程可见,能时间互斥,也就是只有一个线程能拿到锁.</p>
<p><strong>满足分布式系统或集群模式下多进程可见并且互斥的锁</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528104224700.png" alt="image-20240528104224700"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240429201918696.png" alt="image-20240429201918696" style="zoom: 50%;" /> 

<p>1.MySQL:mysql本身带有锁机制,但是mysql性能能一般,所以作为分布式锁的情况比较少见</p>
<p>2.redis:作为分布式锁是非常常见的一种使用方式,现在企业级开发中基本都使用redis或者zookeeper作为分布式锁,利用setnx方法,插入key成功,则表示获取了锁,有人插入成功则其他人无法插入,利用这套逻辑来实现分布式锁.</p>
<p>3.Zookeeper</p>
<p>  <strong>实现分布式锁时需要实现的两个基本方法:</strong></p>
<p><strong>1.获取锁</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528172858646.png" alt="image-20240528172858646"> </p>
<p>​    互斥:确保只能有一个线程获取锁</p>
<p>非阻塞:尝试一次,成功返回true,失败返回false</p>
<p>SET lock thread1 NX EX 10   添加锁,NX是互斥 ,EX是设置超时时间</p>
<p><strong>2.释放锁</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528173012343.png" alt="image-20240528173012343"> </p>
<p>​    手动释放</p>
<p>​    超时释放:获取锁时添加一个超时时间</p>
<p>​    DEL key  #释放锁,删除即可</p>
<h5 id="实现分布式锁的流程"><a href="#实现分布式锁的流程" class="headerlink" title="实现分布式锁的流程:"></a><strong>实现分布式锁的流程:</strong></h5><p>​         <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240503140136536.png" alt="image-20240503140136536" style="zoom:50%;" /></p>
<h5 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a><strong>改进Redis的分布式锁</strong></h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528221735506.png" alt="image-20240528221735506" style="zoom: 67%;" /> 

<p>1.在获取锁时存入线程标识(可以用UUID标识)</p>
<p>2.在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p>
<p>  如果一致则释放锁</p>
<p>如果不一致则不释放锁</p>
<p><strong>分布式锁的原子性问题</strong>:</p>
<p>更为极端的误删逻辑说明：</p>
<p>线程 1 现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程 2 进来，但是线程 1 他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程 1 的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653387764938.png" alt="1653387764938"></p>
<p>redis中也是有事务存在的,但是只能保证事务的原子性,但不能保证一致性,事务中的多个操作其实是个批处理,在最终是一次性执行.</p>
<p>分布式锁的原子性问题,我们可以通过Redis的Lua脚本去解决.</p>
<h5 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a><strong>Redis的Lua脚本</strong></h5><p>Redis提供了Lua脚本功能, 在一个脚本中编写多条Redis命令,确保多条命令执行时的原子性.lua是一种编程语言.</p>
<p>lua脚本在Redis中是原子性执行的，即使是 由多个命令组成的脚本，Redis会将其作为一个整体在执行，不会被其他客户端的操作打断，从而确保了操作的原子性。</p>
<p><strong>总结：</strong></p>
<p><strong>基于Redis的分布式锁实现思路：</strong></p>
<p>利用set nx ex 获取锁，并设置过期时间，保存线程标识</p>
<p>释放锁时先判断线程标识是否与自己一致，一致的话则删除锁</p>
<p><strong>特性：</strong></p>
<p>利用set nx满足互斥性</p>
<p>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</p>
<p>利用Redis集群保证高可用性和高并发特性。</p>
<p><strong>基于Redis实现的分布式锁存在下面的问题：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529150416949.png" alt="image-20240529150416949"></p>
<p>1.不可重入：同一个线程无法多次获取同一把锁</p>
<p>​                   可重入锁的意义就在于防止死锁。</p>
<p>2.不可重试：获取锁只尝试一次就返回false，没有重试机制</p>
<p>3.超时释放：锁超时释放虽然可以避免死锁，但是如果是业务执行耗时较长，也会导致锁释放，存在安全隐患。</p>
<p>4.主从一致：如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而如果在同步数据之前，主机宕机了，就会出现死锁问题。</p>
<h5 id="Redisson入门"><a href="#Redisson入门" class="headerlink" title="Redisson入门"></a><strong>Redisson</strong>入门</h5><p>是一个在Redis基础上实现的分布式工具的集合。它不仅提供了一系列的分布式的java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529101602200.png" alt="image-20240529101602200" style="zoom:50%;" /> 

<p><strong>入门步骤</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240504185248776.png" alt="image-20240504185248776" style="zoom:67%;" /> 

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240504185308624.png" alt="image-20240504185308624" style="zoom:67%;" /> 

<p><strong>Redisson可重入锁原理：</strong></p>
<p><strong>可重入锁</strong>：以前的锁是不可重入的，当一个线程中去调用多把锁的时候，就会出现第一把锁获取成功，其他锁获取失败的情况。</p>
<p>为了解决锁的可重入性质，将以前的key值为lock，value属性只有线程自己的id，改为使用<strong>hashmap存储</strong>，存储当前线程的id和线程获取锁的次数。</p>
<p>调用锁的时候，判断是不是自己的锁，是的话，次数加1，不是的话，次数减1，当统计数为0的时候，再释放锁。</p>
<p><strong>可重试：</strong>利用信号量和PubSub功能实现等待、唤醒、获取锁失败的重试机制。</p>
<p><strong>超时续约：</strong>利用watchDog（看门狗），每隔一段时间，重置超时时间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529143758001.png" alt="image-20240529143758001"></p>
<p><strong>使用lua脚本来进行实现：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529144226476.png" alt="image-20240529144226476" style="zoom:67%;" />   

<p><strong>分布式锁redission重试和看门狗机制</strong>、</p>
<p>1.重试机制：</p>
<p>在使用Redisson实现分布式锁时，为了应对网络异常、Redis服务器故障等情况，通常会配置重试机制。重试机制可以在获取锁失败后自动进行多次重试，直到获取锁成功或达到最大重试次数为止。</p>
<p>Redisson的重试机制是通过循环调用Redis 的SETNX命令来实现的。当某个节点在获取锁时失败后，会在指定的时间间隔内进行重试，直到获取锁成功或者超过最大重试次数。</p>
<p>2.看门狗机制</p>
<p>看门狗机制是用于防止锁持有者在执行业务逻辑时出现异常，导致锁没有被释放而造成死锁的情况。看门狗机制会在获取锁成功后启动一个定时任务，定时更新锁的过期时间。如果锁持有者因为异常或其他原因未能及时释放锁，锁的过期时间就会被更新，确保锁在一定时间内仍然有效，避免死锁情况的发生。</p>
<p>在redisson中，看门狗机制是通过redis的PEXPIRE（设置过期时间，带毫秒单位）命令实现的。当获取锁成功后，会启动一个定时任务定时更新锁的过期时间，保持锁的有效性。</p>
<p>综上所述，重试机制和看门狗机制是 Redisson 保证分布式锁可靠性和稳定性的重要机制。重试机制用于处理获取锁失败的情况，而看门狗机制用于防止锁的持有者出现异常导致锁未被释放而造成死锁的情况。这两种机制结合起来，可以有效地确保分布式锁的正确使用。</p>
<p><strong>Redisson分布式锁主从一致性</strong></p>
<p>redisson中的multiLock： </p>
<p>原理：利用多个独立的Redis节点，节点之间没有主从关系，就不会因为主从一致而导致锁失效，必须在所有节点都获取重入锁，才能算获取成功。</p>
<p>可以看作多个可重入锁的集合。</p>
<p>缺点：运维成本高，实现复杂</p>
<p><strong>redis异步秒杀优化</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529191332566.png" alt="image-20240529191332566"></p>
<p>·</p>
<p>是在lua脚本中实现对秒杀库存和一人一单的判断。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529192214577.png" alt="image-20240529192214577" style="zoom:67%;" />

<p>在tomcat中执行右半部分</p>
<p><strong>秒杀业务的优化思路是什么？</strong></p>
<p>1先利用Redis完成库存余量、一人一单判断，完成抢单业务</p>
<p>2.再将下单业务放入阻塞队列，利用独立线程异步下单</p>
<p><strong>基于阻塞队列的异步秒杀存在哪些问题</strong>？（可以通过消息队列来实现）</p>
<p>1.内存限制问题（高并发情况下，大量订单创建，可能超出内存上限）</p>
<p>2.数据安全问题（jvm内存没有持久化机制的，每当服务重启或者宕机的时候，阻塞队列中的所有订单任务都会丢失）</p>
<p>消息队列是在jvm以外的独立服务，不受jvm内存的限制，所以解决了我们第一个问题。</p>
<p>消息队列不仅仅做数据存储，存进消息队列中的所有消息要做持久化，不管是服务宕机还是重启数据都不会丢失。而且再将消息发送给消费者后，要求消费者进行确认，如果没有确认的话，消息会在消息队列中一直存在，下次一次会把消息继续投递给消费者，直到成功为止。确保消息至少被消费一次。</p>
<h4 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530100827650.png" alt="image-20240530100827650"></p>
<p>消息队列就是存放消息的队列.最简单的消息队列模型包括三个角色:</p>
<p>1.消息队列:存储和管理,也被称为<strong>消息代理</strong></p>
<p>2.生产者:发送消息到消息队列</p>
<p>3.消费者:从消息队列获取消息并处理消息</p>
<p>Redis提供了三种不同的方式来实现消息队列:</p>
<p>1.list结构:基于List结构模拟消息队列</p>
<p>2.PubSub:基本的点对点消息模型</p>
<p>3.Stream:比较完善的消息队列模型</p>
<p><strong>基于List结构模拟消息队列</strong></p>
<p>Redis的list数据结构是一个双向链表,很容易模拟出队列效果.</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH结合RPOP、	或者RPUSH结合LPOP来实现。</p>
<p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息，因此我们这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240505010343935.png" alt="image-20240505010343935"></p>
<p>基于List的消息队列有哪些优缺点：</p>
<p>优点：</p>
<p>利用Redis存储，不受限于JVM内存上限</p>
<p>基于Redis的持久化机制，数据安全性有保证</p>
<p>可以满足消息有序性</p>
<p>缺点：</p>
<p>无法避免消息丢失</p>
<p>只支持单消费者：一旦有一个人将消息拿走，那么消息就从队列中消除。</p>
<p><strong>基于PubSub的消息队列</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530110745651.png" alt="image-20240530110745651" style="zoom:50%;" />

<p>pubSub(发布订阅)是Redis2.0版本引入的消息传递模型，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p>SUBSCRIBE channel[channel]:订阅一个或多个频道</p>
<p>PUBLISH channel msg：向一个频道发送消息</p>
<p>PSUBSCRIBE pattern[pattern]:订阅与pattern格式匹配的所有频道</p>
<p>基于PubSub的消息队列有哪些优缺点：</p>
<p>优点：采用发布订阅模型，支持多生产、多消费</p>
<p>缺点：</p>
<p>不支持数据持久化</p>
<p>无法避免消息丢失</p>
<p>消息堆积有上限，超出时数据丢失</p>
<h4 id="基于Stream的消息队列："><a href="#基于Stream的消息队列：" class="headerlink" title="基于Stream的消息队列："></a><strong>基于Stream的消息队列</strong>：</h4><p>Stream 时Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p><strong>STREAM类型消息队列的XREAD命令特点：</strong></p>
<p>消息可回溯</p>
<p>一个消息可以被多个消费者读取</p>
<p>可以阻塞读取</p>
<p>有消息漏读的风险</p>
<p><strong>STREAM类型消息队列的XREADGROUP命令特点：</strong></p>
<p>消息可回溯</p>
<p>可以多消费者争抢消息，加快消费速度</p>
<p>可以阻塞读取</p>
<p>没有消息漏读的风险</p>
<p>有消息确认机制，保证消息至少被消费一次</p>
<p><strong>Redis消息队列总结：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240505153952670.png" alt="image-20240505153952670"></p>
<p>建议使用中间件RabbitMQ来解决，这边听不懂，直接作为项目上的难点，讲给面试官。</p>
<h4 id="4-达人探店"><a href="#4-达人探店" class="headerlink" title="4.达人探店"></a><strong>4.达人探店</strong></h4><h4 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a><strong>发布探店笔记</strong></h4><p>图文结合，对应有两张表：</p>
<p>tb_blog:探店笔记表，包含笔记中的标题、文字、图片等</p>
<p>tb_blog_comments:其他用户对探店笔记的评价</p>
<p>一共有两个接口，上传图片接口和发布接口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530141252463.png" alt="image-20240530141252463"></p>
<p>需求：点击首页的探店笔记，会进入详情页面，实现该页面的查询接口：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530144820719.png" alt="image-20240530144820719"> </p>
<p><strong>查看探店笔记</strong></p>
<h4 id="达人探店点赞功能"><a href="#达人探店点赞功能" class="headerlink" title="达人探店点赞功能"></a><strong>达人探店点赞功能</strong></h4><p>需求:完善点赞功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240506090612387.png" alt="image-20240506090612387"></p>
<p>核心就是判断用户是否点赞过:</p>
<p>思路:用一个set集合去存储已经点赞的用户列表</p>
<p>我们先去Redis中查询</p>
<p>如果查询不到,数据库点赞+1,并保存用户到Redis</p>
<p>如果查询到了,数据库点赞-1,并删除Redis中set保存的用户</p>
<h4 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a><strong>点赞排行榜</strong></h4><p>在探店笔记的详情页面,应该把给该笔记点赞的人显示出来,比如最早点赞的Top5,形成点赞排行榜</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530202645975.png" alt="image-20240530202645975"></p>
<p> 之前的点赞是放在set集合中的,但是set集合是不能排序的,所以我们采用sortedSet集合</p>
<p>步骤:使用sortedSet代替Set集合,按照保存时间的毫秒值,获取排名前五的用户</p>
<h3 id="5-好友关注"><a href="#5-好友关注" class="headerlink" title="5.好友关注"></a>5.好友关注</h3><h4 id="1-关注和取关"><a href="#1-关注和取关" class="headerlink" title="1.关注和取关"></a>1.关注和取关</h4><p>基于该表结构实现两个接口：</p>
<p>关注和取关接口</p>
<p>判断关注的接口</p>
<p>需要一张中间表来记录，关注是User之间的关系，是博主与粉丝的关系，是<strong>多对多</strong>的关系，数据库中有一张表，tb_follow表示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240602205614937.png" alt="image-20240602205614937"> </p>
<p>思路： </p>
<p>判断是关注还是未关注，关注的话就定义对象，存到表里面，未关注的话就删除表中数据。</p>
<p>是否关注用户？：如果在表中查到数据，则说明关注了</p>
<h4 id="2-共同关注"><a href="#2-共同关注" class="headerlink" title="2.共同关注"></a>2.共同关注</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603094019369.png" alt="image-20240603094019369"></p>
<p>上图是实现查询用户详情和查询用户笔记的接口</p>
<p><strong>共同关注的实现:</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603103054668.png" alt="image-20240603103054668" style="zoom:50%;" />

<p><strong>思路</strong>:在关注的时候,放入数据库的同时,指定key把当前id的关注列表以set的形式放入redis中</p>
<p>取消关注的时候,删除数据库的数据,并删除redis中数据</p>
<p>最后用set集合求交集的方法,就可以查看到共同关注</p>
<p>查看到的数据为string类型,要转化为Long类型.</p>
<h4 id="3-关注推送"><a href="#3-关注推送" class="headerlink" title="3.关注推送"></a>3.关注推送</h4><p>关注推送也叫Feed流,通过无线下拉刷新获取新的信息.</p>
<p>Feed流产品有两种常见模式:</p>
<p><strong>1.Timeline</strong>:不做内容筛选,简单的按照内容发布时间排序,常用于好友或关注.例如朋友圈</p>
<p>优点:信息全面,不会有缺失,并且实现也相对简单</p>
<p>缺点:信息噪音比较多,用户不一定感兴趣,内容获取效率低下</p>
<p><strong>2.智能排序</strong>:利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣信息来吸引用户。</p>
<p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷。</p>
<p>缺点：如果算法不精准，可能起到反作用。</p>
<p><strong>本案例中使用TimeLine的模式。该模式的实现方案有三种：</strong></p>
<p><strong>1.拉模式：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603134043235.png" alt="image-20240603134043235"></p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在根据时间进行排序</p>
<p>优点：比较节约内存空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><strong>2.推模式：</strong></p>
<p>也叫写扩散</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603134659023.png" alt="image-20240603134659023"></p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大 V 写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><strong>3.推拉结合</strong></p>
<p>也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个<code>普通的人，那么我们采用写扩散的方式</code>，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，<code>如果是大V，那么他是直接将数据先写入到一份到发件箱里边去</code>，然后再直接写一份到<code>活跃粉丝</code>收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大 V 和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603141011200.png" alt="image-20240603141011200"></p>
<p><strong>Feed流的实现方案：</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603141143759.png" alt="image-20240603141143759"></p>
<p><strong>基于推模式实现关注推送功能：</strong></p>
<p>需求：</p>
<p>1.修改新增探店笔记的内容，在保存blog到数据库的同时，推送到粉丝的收件箱</p>
<p>2.收件箱满足可以根据时间戳排序，必须用redis的数据结构实现</p>
<p>3.查询收件箱数据时，可以实现分页查询。</p>
<p><strong>Feed流的滚动分页</strong>：</p>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603145025100.png" alt="image-20240603145025100" style="zoom:67%;" />

<p>我们采用sortedSet来做，可以进行范围查询，并且还可以记录获取数据时间戳的最小值，就可以实现滚动分页了。</p>
<p>我们在保存完探店笔记后，获得该用户的粉丝，然后把数据推送到粉丝的redis中去。</p>
<p><strong>实现关注推送页面的分页查询</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603160546754.png" alt="image-20240603160546754"></p>
<p>需求：在个人主页的 “关注” 卡片中，查询并展示推送的 Blog 信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<h3 id="6-附近商户"><a href="#6-附近商户" class="headerlink" title="6.附近商户"></a>6.附近商户</h3><p>1.GEO数据结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603185354047.png" alt="image-20240603185354047"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603214304903.png" alt="image-20240603214304903"></p>
<p>我们需要将数据库表中的数据导入到Redis中GEO中去，我们需要把商铺的经纬度和id存进去，但是不能把所有的数据都传进去，因为redis是一个基于内存的数据库，存太多数据会占用很高的内存空间。</p>
<p>但是这个时候还有一个问题，就是在 redis 中并没有存储 type，所以我们无法根据 type 来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以 typeId 为 key 存入同一个 GEO 集合中即可。</p>
<p>下图是将数据存入到GEO中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604091821489.png" alt="image-20240604091821489"></p>
<p><strong>难点：</strong>不是每次都与 Redis 链接，去插入数据，而是把数据封装成 List&lt;RedisGeoCommands.GeoLocation&gt; 集合，一次插入，减小与 Redis 链接的次数，提升效率</p>
<h4 id="实现附近商户功能"><a href="#实现附近商户功能" class="headerlink" title="实现附近商户功能"></a><strong>实现附近商户功能</strong></h4><p>都是代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过 opsForGeo() 方法获取了 Redis 的 Geo 操作对象。</span><br><span class="line">调用 search() 方法执行地理位置的搜索操作。</span><br><span class="line">search() 方法接收了一系列参数：</span><br><span class="line">key：指定了要搜索的 GeoKey（地理位置的键）。</span><br><span class="line">GeoReference.fromCoordinate(x, y)：指定了搜索的中心坐标，其中 x 和 y 分别表示了经度和纬度。</span><br><span class="line">new Distance(5000)：指定了搜索的半径范围，这里设置为 5000 米。</span><br><span class="line">RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)：这是可选的参数，用于配置搜索的行为。includeDistance() 表示在搜索结果中包含距离信息，limit(end) 表示限制搜索结果的数量为 end。</span><br></pre></td></tr></table></figure>

<h3 id="7-用户签到"><a href="#7-用户签到" class="headerlink" title="7.用户签到"></a><strong>7.用户签到</strong></h3><p><strong>7.1BitMap用法</strong></p>
<p>我们可以使用数据库表来实现签到功能</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604104145026.png" alt="image-20240604104145026" style="zoom:80%;" /> 

<p>用户签到一次，就是一条记录，假如有1000万用户的话，平均每人每年签到十次的话，则这张表一年的数据量为1亿条。</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共 22 字节的内存，一个月则需要 600 多字节</p>
<p>我们可以采用以下方案来解决：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604104556560.png" alt="image-20240604104556560" style="zoom:67%;" /> 

<p>我们按月来统计用户签到信息，签到记录为 1，未签到则记录为 0.</p>
<p>把每一个 bit 位对应当月的每一天，形成了映射关系。用 0 和 1 标示业务状态，这种思路就称为<strong>位图</strong>（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis 中是利用 string 类型数据结构实现 **<code>BitMap</code>**，因此最大上限是 512M，转换为 bit 则是 2^32 个 bit 位。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604105232842.png" alt="image-20240604105232842" style="zoom: 67%;" /> 

<p><strong>7.2签到功能</strong></p>
<p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604111733932.png" alt="image-20240604111733932" style="zoom:67%;" /> 

<p>思路：我们可以把年和月作为 bitMap 的 key，然后保存到一个 bitMap 中，每次签到就到对应的位上把数字从 0 变成 1，只要对应是 1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改 bitMap。</p>
<p><strong>7.3签到统计</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604141711486.png" alt="image-20240604141711486" style="zoom:67%;" /> 

<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604142014927.png" alt="image-20240604142014927" style="zoom: 80%;" /> 





<h3 id="8-UV统计"><a href="#8-UV统计" class="headerlink" title="8.UV统计"></a>8.UV统计</h3><p><strong>1.HyperLogLog用法</strong></p>
<p>UV:也叫独立访客量,是指通过互联网访问、浏览这个网页的自然人。一天内同一个用户多次访问该网站，只记录一次。</p>
<p>PV：也叫页面访问量或点击量，用户每访问网站的一个页面，记录一次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</p>
<p>uv统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存在redis中，数据量会非常恐怖。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604160129918.png" alt="image-20240604160129918"></p>
<p><strong>2.实现UV统计</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604160936759.png" alt="image-20240604160936759"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604161825611.png" alt="image-20240604161825611"></p>
<p>1000000 存入 997593，误差率约为 0.2%.</p>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h1 id="消息队列rabbitmq"><a href="#消息队列rabbitmq" class="headerlink" title="消息队列rabbitmq"></a>消息队列rabbitmq</h1><p>概念：是一种用于在应用程序之间传递消息的通信方式，消息队列允许应用程序异步地发送和接受消息，并且不需要直接连到对方。</p>
<p>应用场景：</p>
<p>1.应用的解耦</p>
<p>2.异步发送消息</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240718161836639.png" alt="image-20240718161836639" style="zoom:50%;" /> 

<ol start="3">
<li>流量削峰（一般在秒杀场景下）</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240718162908841.png" alt="image-20240718162908841" style="zoom:50%;" /> 

<p>消息队列缺点？</p>
<p>如何保证消息没有被重复消费？</p>
<p>如何处理消息丢失的情况？</p>
<p>如何保证消息传递的顺序性？</p>
<p>如何保证数据一致性问题？</p>
<p>RabbitMq四大核心：</p>
<p>生产者  消费者 队列 交换机 </p>
<p>生产者发送消息，消息先到达交换机，交换机根据相应的配置将消息路由到相应的队列中。</p>
<p>发布订阅模式publish&#x2F;subscribe：</p>
<p>消费者订阅指定的队列，有消息时Fanout Exchange会发布到所有的队列中，这样订阅的消费者就都能收到消息了。</p>
<p>如工作原理如下图所示。因为Fanout交换机，会将所有消息转发到所有绑定的队列上，所以也不用指定routingKey了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240718173933475.png" alt="image-20240718173933475"> </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.zoulifelogs.cn">小邹</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.zoulifelogs.cn/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis-%E9%A1%B9%E7%9B%AE/">https://www.zoulifelogs.cn/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis-%E9%A1%B9%E7%9B%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.zoulifelogs.cn" target="_blank">小邹的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_10.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis%E6%80%BB%E7%BB%93/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/07/28/java%E5%90%8E%E7%AB%AF-NFT/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_5.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小邹</div><div class="author-info__description">生活博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zoujiahao22"><i class="fab fa-github"></i><span>/前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zoujiahao22/zoujiahao22.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zoujiahao2022@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2Redis-%E9%A1%B9%E7%9B%AE"><span class="toc-text">2Redis 项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">Redis快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E5%92%8Cnosql%E5%8C%BA%E5%88%AB"><span class="toc-text">sql和nosql区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-text">Redis常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">Redis常见的五种数据结构:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-String%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.String类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Hash%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.Hash类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-list%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-text">3.list类型的常见命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Set%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.Set类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.SortedSet类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">Redis的java客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Jedis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">1.Jedis快速入门</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2.自定义序列化的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-2"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringRedisTemplate"><span class="toc-text">StringRedisTemplate</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98"><span class="toc-text">Redis企业实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-text">1.短信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-text">基于Session实现登录流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABsession%E7%99%BB%E5%BD%95"><span class="toc-text">基于Redis实现共享session登录</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">2.商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-text">2.1缓存：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9A"><span class="toc-text">缓存穿透：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="toc-text">缓存工具封装类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-text">3.优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id%EF%BC%88%E4%B8%8B%E5%8D%95%E6%97%B6id%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%89"><span class="toc-text">全局唯一id（下单时id的唯一性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%EF%BC%9A"><span class="toc-text">实现优惠券秒杀下单：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-text">库存超卖问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-text">案例：实现优惠券一人一单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">集群下的线程并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">实现分布式锁的流程:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9BRedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">改进Redis的分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E7%9A%84Lua%E8%84%9A%E6%9C%AC"><span class="toc-text">Redis的Lua脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redisson%E5%85%A5%E9%97%A8"><span class="toc-text">Redisson入门</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">Redis消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-text">基于Stream的消息队列：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-text">4.达人探店</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-text">发布探店笔记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD"><span class="toc-text">达人探店点赞功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-text">点赞排行榜</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-text">5.好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E5%85%B3"><span class="toc-text">1.关注和取关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-text">2.共同关注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-text">3.关注推送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7"><span class="toc-text">6.附近商户</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E5%8A%9F%E8%83%BD"><span class="toc-text">实现附近商户功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-text">7.用户签到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-UV%E7%BB%9F%E8%AE%A1"><span class="toc-text">8.UV统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-3"><span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq"><span class="toc-text">消息队列rabbitmq</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 小邹</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.zoulifelogs.cn/categories/笔记1/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 小邹の笔记1 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.zoulifelogs.cn/categories/笔记2/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 小邹の笔记2 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.zoulifelogs.cn/categories/笔记3/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 小邹の笔记3 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.zoulifelogs.cn/categories/生活/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 小冰の生活 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.zoulifelogs.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://www.fomal.cc/static/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/06/25/2024-6-25-第二篇文章/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-25</span><a class="blog-slider__title" href="2024/06/25/2024-6-25-第二篇文章/" alt="">第二篇文章</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/06/25/2024-6-25-第二篇文章/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/06/24/java后端-华为面经/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_7.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-24</span><a class="blog-slider__title" href="2024/06/24/java后端-华为面经/" alt="">华为面经</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/06/24/java后端-华为面经/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/06/24/2024-6-24-第一篇文章/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-24</span><a class="blog-slider__title" href="2024/06/24/2024-6-24-第一篇文章/" alt="">第一篇文章</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/06/24/2024-6-24-第一篇文章/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>