<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="黑马点评项目面试题"><a href="#黑马点评项目面试题" class="headerlink" title="黑马点评项目面试题"></a>黑马点评项目面试题</h1><h2 id="登录："><a href="#登录：" class="headerlink" title="登录："></a>登录：</h2><h4 id="简述下你的登录逻辑？"><a href="#简述下你的登录逻辑？" class="headerlink" title="简述下你的登录逻辑？"></a>简述下你的登录逻辑？</h4><p>1.<strong>发送验证码</strong></p><p>首先用户提交手机号，系统去检验手机号格式是否正确，格式正确的话会生成一个验证码发送到用户手机上并保存在redis中，手机号作为key，验证码作为value，并设置有效期。</p><p>2.<strong>验证码登录注册</strong></p><p>2.然后系统根据用户提交的手机号和验证码去redis中查询比对，比对成功的话再根据手机号去数据库中查询对应的用户信息，存在的话将用户信息保存到redis中，以随机token为key存储用户数据，并把token返回给前端保存在浏览器中。如果不存在的话，则创建新用户，并保存用户到数据库中，然后在保存到redis中，并向客户端返回token。</p><p>3.<strong>校验登录状态部分</strong></p><p>这个部分我们设置了双重拦截器来检查用户的登录状态。未登录或者登录无效的用户请求将被拦截并重定向到登录界面。</p><h4 id="双重拦截器是什么？"><a href="#双重拦截器是什么？" class="headerlink" title="双重拦截器是什么？"></a>双重拦截器是什么？</h4><p>第一个拦截器里面的实现逻辑是：会拦截一切路径，用户发起并携带token，去获取redis中查询用户信息，存在的话将信息保存到threadlocal中，并刷新token有效期并放行，不存在的话也会放行。（为了刷新token有效期）</p><p>第二个拦截器其实做的是拦截动作：他会拦截需要登录的路径，查询threadlocal中的用户，存在的话就放行，不存在的话就拦截。</p><h4 id="为什么要用threadlocal，底层是什么？内存泄露问题怎么解决的？"><a href="#为什么要用threadlocal，底层是什么？内存泄露问题怎么解决的？" class="headerlink" title="为什么要用threadlocal，底层是什么？内存泄露问题怎么解决的？"></a>为什么要用threadlocal，底层是什么？内存泄露问题怎么解决的？</h4><p>threadlocal提供一种线程隔离的变量存储方式，他能确保每个线程都有独立的变量副本，避免了多线程环境下的数据共享问题。</p><p>底层：<code>ThreadLocal</code>的底层实现依赖于每个线程的<code>ThreadLocalMap</code>。这个<code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的一个静态内部类，它实际上是一个以<code>ThreadLocal</code>实例为键、用户定义的值为value的哈希表。每个线程在创建时都会关联一个这样的<code>ThreadLocalMap</code>，用于存储该线程私有的变量</p><p>内存泄露问题：在设置登录拦截器的时候，实现HandlderInterceptor接口中的preHandle前置拦截（<strong>做登录校验的</strong>）和afterCompletion，其中afterCompletion就是用来业务执行完毕之后，移除用户，从而避免用户的泄露。</p><p>阿里云短信验证步骤:1.引入阿里云sdk依赖  2.在项目中创建配置类初始化阿里云客户端</p><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存:"></a>商户查询缓存:</h2><p>自定义布隆过滤器解决缓存穿透? 布隆过滤器满了怎么办? 布隆过滤器的数据怎么迁移?从一个小的变成更大的布隆过滤器可以么?</p><p>实现商铺缓存与数据库的双写一致.延时双删说一下?</p><p><strong>定义布隆过滤器:</strong></p><p>将数据库中所有存在的商户id通过布隆过滤器进行初始化.对于数据库中的每一个商户id,使用多个哈希函数计算其哈希值,并将对应数组中的位置设置为1.</p><p><strong>布隆过滤器满了如何解决?</strong></p><p>当布隆过滤器误判率过高时候,最直接的方法就是重建一个新的布隆过滤器,通过增加位数组的大小或者哈希函数的数量.</p><p><strong>新建布隆过滤器的数据如何进行迁移?</strong></p><p>创建好新的布隆过滤器之后,初始化数数组都设置为0.根据元素重新根据新的布隆过滤器中的哈希函数计算哈希值,和更新位数组.</p><p><strong>如何实现商铺缓存和数据库缓存的双写一致?</strong></p><p>延时双删策略,常用于读多写少的场景</p><p>就是我们首先更新去数据库中的数据,然后去尝试删除缓存中对应的数据,然而这个步骤可能会受一些原因影响不一定百分百成功,为了确保缓存中的旧数据被彻底删除,可以设置一个延时任务(使用消息队列,延时队列或者定时器).这个延时任务会在一段时间后执行,再次尝试删除缓存中可能还存在的旧数据.</p><p>更新成功但是第二次删除失败怎么办?</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透?"></a>缓存穿透?</h4><p>客户端请求的数据在缓存和数据库中都不存在,如果有大量的线程并发的向这个不存在数据发起请求的话,这些请求会直接达到数据库,给数据库造成巨大压力,很有可能导致数据库宕机。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p><strong>1.缓存空对象，并给这个空对象设置一个过期时间。</strong></p><p>缺点：1.当空对象过多时，会浪费存储空间。</p><p>  2.即使设置了很短的过期时间，还是有可能会导致这段时间内数据库和缓存中存储数据不一致。（原因是在新增或者更新数据库的时候，没有即使更新缓存，取到的还是空对象）</p><p><strong>2.使用布隆过滤器</strong>（一种数据结构）</p><p>是一种数据结构能够快速的判断某个元素是否在一个集合中，速度很快，并且内存占用少。</p><p>优点：速度快，占用内存少</p><p>缺点：存在误判的可能性，无法删除已经添加的数据</p><p><strong>原理：</strong></p><p>它是由位数组和哈希函数两部分组成的，当要查询某个元素是否在集合中时，对该元素进行哈希处理，然后看哈希值（索引）对应的位数组索引的值是否为1，如果哈希值对应的位数组的值都为1的话，说明该元素可能在集合中，否则一定不在集合中。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240611235309507.png" alt="image-20240611235309507" style="zoom:50%;" /><h4 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h4><p>缓存中的某个热点key过期了，并且在该热点key重新载入缓存之前，大量的查询请求穿过缓存，直接到达数据库，可能导致数据库宕机。</p><h5 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h5><p><strong>1使用互斥锁来解决</strong></p><p>使用互斥锁来保证同一时刻只有一个查询请求重新加载热点key到缓存中，其他线程只需等待该线程加载完毕，即可重新从redis中获取数据。</p><p>优点：能保证数据一致性，实现简单</p><p>缺点：线程需要等待性能差，可能有死锁的风险</p><p><strong>2.使用逻辑过期方案</strong></p><p>在redis中存储数据的时候设置逻辑过期时间，虽然键可能在缓存中已经过期，但是仍然能在高并发的情况下，返回缓存中的旧值，同时后台异步更新缓存，这样能保证数据不会直接打到数据库上。后台任务更新缓存时，就可以从数据库中获取最新值，并且设置逻辑过期时间。</p><p>当我们在redis中存储数据的时候，只是设置一个逻辑过期时间，如果线程1请求数据的时候发现逻辑时间过期了，那么他将获取一个互斥锁，并开启一个新的线程2去查询数据库并重建缓存数据，同时线程1返回过期的数据，线程2写入缓存后并设置逻辑过期时间，完成后释放锁，如果有其他的线程3在锁释放之前访问的话，也会返回过期的数据。</p><p>优点：线程无需等待，性能好。</p><p>缺点：不能保证数据的一致性，有额外的内存消耗，实现比较复杂</p><h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><p>缓存中有大量的key在同一时刻过期，或者redis直接宕机了，导致大量的查询请求直接到达数据库带来巨大压力，可能导致宕机。</p><p>解决方案：</p><p>1.将不同的key的自动过期时间设置成随机值，避免key同时过期。</p><p>2.如果是redis发生故障的话：使用redis集群来提高服务的可用性</p><p>3.给业务添加多级缓存。</p><h4 id="如何使用redis实现唯一的全局id？"><a href="#如何使用redis实现唯一的全局id？" class="headerlink" title="如何使用redis实现唯一的全局id？"></a>如何使用redis实现唯一的全局id？</h4><p>在本项目中自己实现了一个id生成器，采用数值类型,java中的long型,有三个部分组成 用的long类型,8个字节,64bit位</p><p>第一位符号位永远为0</p><p>自定义的时间戳:31bit,以秒为单位可以用69年</p><p>序列号 ,redis自增的值:32个bit位,这个使用redis中的incr函数实现的.</p><h4 id="乐观锁和悲观锁是什么-是用来干什么的-超卖问题"><a href="#乐观锁和悲观锁是什么-是用来干什么的-超卖问题" class="headerlink" title="乐观锁和悲观锁是什么?是用来干什么的?(超卖问题)"></a>乐观锁和悲观锁是什么?是用来干什么的?(超卖问题)</h4><p><strong>乐观锁和悲观锁是两种思想,用于解决并发场景下的数据竞争问题</strong></p><p>悲观锁:</p><p>认为线程安全问题一定会发生,所以在操作数据时会加锁,直到操作完成后才释放锁,上锁期间其他人不能修改数据.</p><p>乐观锁:</p><p>认为线程安全不一定会发生,所以不加锁,<strong>只在更新数据的时候去判断其他线程有没有对数据做了修改.</strong></p><p>如果没有修改则认为是安全的,才去更新操作. 如果被修改了则放弃操作.</p><p><strong>乐观锁的实现方式一般有两种:</strong></p><p>版本号机制(最普遍,最常用的)</p><p>CAS机制(用数据本身是否变化来判断线程是否安全)</p><h4 id="超卖的问题解决方案"><a href="#超卖的问题解决方案" class="headerlink" title="超卖的问题解决方案"></a>超卖的问题解决方案</h4><p>1.使用悲观锁在下单的业务上使用sync关键字,这样会导致秒杀业务变成串行执行严重降低并发性.</p><p>2.使用乐观锁在更新库存的时候判断一下是否和查询库存的时候结果一样,如果一样则说明数据没有被修改过可以执行操作,如果库存和之前不一样则回滚.</p><h4 id="分布式锁是什么"><a href="#分布式锁是什么" class="headerlink" title="分布式锁是什么?"></a>分布式锁是什么?</h4><p>原理就是一定要让多个jvm进程看到同一个锁监视器,也就是多进程可见,能时间互斥,也就是同一时间只有一个线程能拿到锁.</p><p><strong>利用redis实现分布式锁:   利用redis中setnx命令加以并设置过期时间:</strong></p><p>setnx满足互斥性多个线程执行只有一个返回true,</p><p>使用过期时间可以保证出现故障后锁依然可以释放不会出现死锁问题.</p><p>利用redis集群来提高可用性.</p><p>释放锁的时候需要判断当前的锁是不是自己加的,只有当前的锁是自己加的才能删除.</p><p>删除锁的动作需要具备原子性因此我们使用了lua脚本实现多条指令的原子性.</p><h4 id="lua脚本是什么-为什么要用到lua脚本"><a href="#lua脚本是什么-为什么要用到lua脚本" class="headerlink" title="lua脚本是什么?为什么要用到lua脚本?"></a>lua脚本是什么?为什么要用到lua脚本?</h4><p>redis提供lua脚本功能,在一个脚本中编写多条redis命令,确保多条命令执行时的原子性,lua是一种编程语言.</p><h4 id="lua脚本如何保证线程安全"><a href="#lua脚本如何保证线程安全" class="headerlink" title="lua脚本如何保证线程安全?"></a>lua脚本如何保证线程安全?</h4><p>lua脚本作为一个整体执行,具备原子性,对客户端来说,lua要么不可见,要么已经执行完毕.</p><h4 id="redis中的zset是一个怎样的数据类型？为什么它能根据点赞时间保证数据的有序性？"><a href="#redis中的zset是一个怎样的数据类型？为什么它能根据点赞时间保证数据的有序性？" class="headerlink" title="redis中的zset是一个怎样的数据类型？为什么它能根据点赞时间保证数据的有序性？"></a>redis中的zset是一个怎样的数据类型？为什么它能根据点赞时间保证数据的有序性？</h4><p>Zset是redis中一个有序集合,元素的类型是string类型的,不允许有重复的元素,不同的就是每个元素都会关联一个double类型的分数.redis通过分数来为集合中的成员进行从小到大的排序.有序集合的元素是唯一的,但是分数是可以重复的.</p><h4 id="好友点赞和关注列表式如何实现的"><a href="#好友点赞和关注列表式如何实现的" class="headerlink" title="好友点赞和关注列表式如何实现的?"></a>好友点赞和关注列表式如何实现的?</h4><p>好友点赞的问题应该保证一个好友一个笔记只能点赞一次,因此考虑使用redis中set集合这个功能.</p><p><strong>具体实现方法:</strong></p><p>在redis中建立set集合,每一个日志对应一个set集合,set集合中保存的数据就是用户点赞的用户id,这样在用户点赞的时候就可以先查询一下是否点过赞如果点过赞则返回错误信息,否则就将用户id记录到set集合之中.</p><h4 id="好友共同关注功能如何实现"><a href="#好友共同关注功能如何实现" class="headerlink" title="好友共同关注功能如何实现?"></a>好友共同关注功能如何实现?</h4><p>好友共同关注可以利用Redis中的集合求交集来实现,在redis中保存set集合,每个集合对应一个用户集合里面的关注用户id,就是该用户关注的用户id,这两个用户求共同关注只需要使用交集运算sinter即可实现.</p><h4 id="1-使用Redis实现店铺信息缓存、使持续并发放问下的接口响应时间由平均305ms减少到75ms"><a href="#1-使用Redis实现店铺信息缓存、使持续并发放问下的接口响应时间由平均305ms减少到75ms" class="headerlink" title="1.使用Redis实现店铺信息缓存、使持续并发放问下的接口响应时间由平均305ms减少到75ms"></a>1.使用Redis实现店铺信息缓存、使持续并发放问下的接口响应时间由平均305ms减少到75ms</h4><p>流程：提交商铺的id，从redis中查询商铺缓存，如果未命中的话根据id查询数据库，判断商铺是否存在，存在的话，将商铺信息写入redis，并返回商铺信息，不存在数据库的话直接返回错误信息。</p><h4 id="2-实现优惠券的抢购功能：使用Redis、Lua脚本解决并发环境下库存超买、一人一单问题"><a href="#2-实现优惠券的抢购功能：使用Redis、Lua脚本解决并发环境下库存超买、一人一单问题" class="headerlink" title="2.实现优惠券的抢购功能：使用Redis、Lua脚本解决并发环境下库存超买、一人一单问题"></a>2.实现优惠券的抢购功能：使用Redis、Lua脚本解决并发环境下库存超买、一人一单问题</h4><p><strong>库存超卖的问题就是多线程安全的问题：解决的方案就是加锁。</strong></p><p>锁有两种，悲观锁和乐观锁，该个模块里面使用了乐观锁，使用乐观锁在更新库存的时候，判断是否与之前查询的库存值一样，如果一样的话，说明数据没被修改过，则执行更新操作，不一样的话就回滚。</p><p><strong>lua脚本实现高并发环境下的一人一单问题：</strong></p><p>使用分布式锁和lua脚本来解决一人一单的问题，首先利用redis实现一个分布式锁，利用redis中setnx命令设置锁，如果插入key成功别人就获取不到，相当于加锁，用senex获取锁的过期时间，在完成业务逻辑之后，再去删除释放锁，但是在删除释放锁的时候需要判断当前的锁是不是自己加的，只有自己当前的锁是自己加的才可以删除，删除锁的动作需要具备原子性的因此我们使用了lua脚本实现多条指令的原子性。</p><p>但是基于redis实现的分布式锁会有很多考虑不足的地方比如说不可重入，不可重试，超时释放等问题，后面都是引入redis的依赖，使用redisson的分布式锁实现的，底层会有看门狗机制解决死锁的问题，看门狗机制会在获取锁成功后启动任务，更新锁的过期时间，避免死锁的发生。</p><h4 id="redis分布式锁的key-value问题"><a href="#redis分布式锁的key-value问题" class="headerlink" title="redis分布式锁的key value问题"></a>redis分布式锁的key value问题</h4><p>key是设置业务名+用户id，value需要设置为uuid+线程id，因为在集群环境下可能会出现线程id相同的问题 ，这样在删除锁的时候线程需要先根据value值判断是不是自己加的锁如果不是则说明其他线程已经获取到锁那么自己执行的业务就应该回滚。如果是自己的锁那么可以直接释放。</p><h4 id="3-使用Zset实现点赞取消、点赞排序、共同关注等功能；使用ZSET实现已关注博主的博客推送功能"><a href="#3-使用Zset实现点赞取消、点赞排序、共同关注等功能；使用ZSET实现已关注博主的博客推送功能" class="headerlink" title="3.使用Zset实现点赞取消、点赞排序、共同关注等功能；使用ZSET实现已关注博主的博客推送功能"></a>3.使用Zset实现点赞取消、点赞排序、共同关注等功能；使用ZSET实现已关注博主的博客推送功能</h4><p>点赞取消：在redis中创建set集合，每个日志对应一个set集合，set集合中保存的就是用户点赞的id，这样用户在点赞的时候可以先查询一下是否点过赞，点过赞则返回错误信息，没点过赞则将用户id记录到set集合中。</p><p>点赞排序：使用Zset集合，是个有序集合，每个元素都会关联一个double类型的分数，redis通过分数来为集合中的成员从小大排序。</p><p>共同关注：将用户关注的 用户id存储在set集合中，然后用set求交集的interset（）方法求得共同的好友集。</p><h4 id="4-使用GEO实现按距离分页查询附近店铺功能"><a href="#4-使用GEO实现按距离分页查询附近店铺功能" class="headerlink" title="4.使用GEO实现按距离分页查询附近店铺功能"></a>4.<strong>使用GEO实现按距离分页查询附近店铺功能</strong></h4><p>地理位置GEO:用于存储地理位置的数据结构,我们在数据库中将存放地理位置坐标的位置信息用stringredisTemplete.opsForGeo接口的add方法存储到redis中去,</p><p>再调用Geodistance查找距离,GeoRadius查询一定范围内的餐厅.</p><p>(需要先把商铺位置信息存储到redis中去)</p><h4 id="5-使用HyperLogLog实现笔记访问量统计功能。"><a href="#5-使用HyperLogLog实现笔记访问量统计功能。" class="headerlink" title="5.使用HyperLogLog实现笔记访问量统计功能。"></a>5.使用HyperLogLog实现笔记访问量统计功能。</h4><p>HyperLogLog:基于基数的数据结构,支持对大量元素的去重统计,占用和误差很小</p><p>用于网站的访问统计等,底层是概率估算.</p><p>我们首先在线程池中获取当前用户的唯一标识,</p><p>针对访客数和访客量要获取不同的标识</p><p>针对访客数,因为是不可以重复的,可以选用唯一账户id等</p><p>针对访问量,可以重复,用当前线程中拿到的cookie即可.</p><p>基数:集合中不重复元素的数量</p><h4 id="spring常用的注解："><a href="#spring常用的注解：" class="headerlink" title="spring常用的注解："></a>spring常用的注解：</h4><p>首先是启动注解：@springbootApplication   里面是包含了三个注解</p><p>然后就是三层架构里面的</p><p>@Restcontroller ,@Service @ Mapper</p><p>在controller层用来处理请求HTTP相关的注解:</p><p>@GetMapping  @postMapping @DeleteMapping</p><p>值传递相关的注解：</p><p>@RequestBody  @pathvariable @Requestparam等</p><p>（请求实体绑定到方法参数上） 。。请求路径。。。  请求参数。。</p><p>mapper层的注解：</p><p>@insert @delete @select等</p><p>还有通用的：@Autowired  @configuration @ Transcactional等</p><h4 id="mybatis-和-mybatisPlus-的联系区别"><a href="#mybatis-和-mybatisPlus-的联系区别" class="headerlink" title="mybatis 和 mybatisPlus 的联系区别"></a>mybatis 和 mybatisPlus 的联系区别</h4><p>mybatis就是java用来操作数据库的持久层框架，主要使用xml或者通过注解的方式来配置sql语句。</p><p>使用的时候，会创建数据库连接池，解决了资源复用，提高响应。</p><p>mp内置了增删改查，通过扫描实体类，基于反射获取实体类的信息，作为数据库的信息表。</p><p>一般来说，单表的增删改查可以用mp实现</p><p>多表的联合查询，就要用mybatis去写。</p><p>mp自带了分页查询的插件，不用去引用第三方的依赖，很方便。</p><p>创建一个page对象，然后调用selectpage（）方法。</p><p>redis和Mysql如何做到读写一致性？</p><p>1.给缓存设置过期时间，定期的从数据库中加载最新的数据</p><p>2.做数据更改的时候，不直接更新redis而是删除缓存，下次命中时候未命中在更新。</p><p>3.最终一致性：使用消息队列进行异步处理。</p><h4 id="后端如何实现前端的接口功能？或者前后端配合的一个流程？"><a href="#后端如何实现前端的接口功能？或者前后端配合的一个流程？" class="headerlink" title="后端如何实现前端的接口功能？或者前后端配合的一个流程？"></a>后端如何实现前端的接口功能？或者前后端配合的一个流程？</h4><p>首先定义前后端之间的API接口，包括 URL路径、http请求方法、请求参数、响应格式等。这一般通过API规范文档进行详细说明。</p><p>然后后端创建controller层 service层 和Dao层</p><p>controller层接受前端传来的HTTP请求，调用sercice层处理业务逻辑，并返回响应。格式一般是json或者其他格式</p><p>service层就是用于处理业务逻辑。</p><p>dao层就是用来与数据库交互。</p><h4 id="spring框架"><a href="#spring框架" class="headerlink" title="spring框架"></a>spring框架</h4><p>spring框架是java的开发框架，有很多模块</p><p>其中springmvc就是spring框架的web开发模块</p><p>springmvc+spring framework+mybatis就是ssm</p><p>springboot整合了ssm，快速开发。springboot简化了spring 的开发。</p><p>使用的第三方类库:</p><p>pytorch:由于搭建和训练神经网络模型,以及嵌入注意力机制</p><p>librosa:用于处理音频数据,将咳嗽音频转换成语谱图作为模型的输入.</p><p>Matplotlib:用于可视化训练过程中的损失曲线和准确率变化</p><h4 id="咳嗽项目"><a href="#咳嗽项目" class="headerlink" title="咳嗽项目:"></a>咳嗽项目:</h4><p>在本研究中，我们进行了广泛的数据收集，包括诊断良好的呼吸道疾病（如慢性阻塞性肺疾病、肺癌、COVID-19和肺炎）和健康参与者的自愿咳嗽录音，共收集了2610个音频样本。我们在ResNet18神经网络中每个残差块的最后一个卷积块中添加了通道注意机制CAM，然后构建了CAM-ResNet18神经网络模型。 我们将收集到的咳嗽音频记录转换为谱图，并建立相应的数据集，利用这些谱图作为CAM-ResNet18神经网络模型的输入数据。随后，我们使用该数据集中的训练集训练CAM-ResNet18神经网络模型，调整模型参数，并训练模型直到模型收敛。最后，我们将测试集的谱图输入到预先训练的神经网络模型中进行精确分类。</p><p>小组其他成员:负责数据的预处理部分:将音频转化成统一格式,人工干预去除有背景噪声的片段,裁剪成多个三秒片段</p><p>​                      生成对应的语谱图:横轴表示时间,纵轴表示频率,结合频谱图和时域波形的特征.</p><p>通道注意机制（CAM）是一种用于图像处理的注意机制。它通过自动学习每个通道的重要性来增强图像的表达能力。这有助于网络关注关键特征，抑制不重要的特征，提高图像分类性能</p><p>原理:，将输入特征图沿着空间维度同时进行全局最大池化和全局平均池化操作。执行这些操作是为了压缩空间维度，从而更容易地提取特征地图中最重要的区域。 接下来，将全局最大池化和平均池化的结果输入多层感知器（MLP）进行特征学习，这涉及到信道维度上的特征学习和单个信道的重要性。随后，对MLP的输出进行加法，然后应用激活函数获得输入特征图中每个通道的注意权值。最后，将得到的注意权重与初始输入的特征图相乘，得到由通道注意加权的特征图</p><h4 id="为什么要将注意力机制嵌入到每个残差块中的最后一个卷积块"><a href="#为什么要将注意力机制嵌入到每个残差块中的最后一个卷积块" class="headerlink" title="为什么要将注意力机制嵌入到每个残差块中的最后一个卷积块?"></a>为什么要将注意力机制嵌入到每个残差块中的最后一个卷积块?</h4><p>是因为最后一个卷积块是每个残余块内的最终卷积操作，并且由于ResNet18中每个残余块的结构是相同的，这里合并通道注意机制（CAM）允许有针对性地改进每个残余块的特征学习能力。重要的是，它并不影响其他残差块的特征提取，从而增强了模型区分不同类型的咳嗽声音的能力</p><p>神经网络模型resnet18组成:</p><p>输入层、卷积层和最大池化层</p><p>残差块：包括两个3*3卷积层和一个跳跃连接层组成，用于解决神经网络中梯度消失和梯度爆炸的问题。</p><p>梯度消失：在反向传播的过程中，随着梯度从输出层传递到输入层，梯度值逐渐变小，最后趋于0，会导致网络的前几层几乎没有更新，从而无法有效的训练这些层。</p><p>梯度爆炸：在反向传播的过程中，随着梯度从输出层传递到输入层，梯度值逐渐变大，会变得非常大，导致网络更新的权重过大，训练变得不稳定，甚至导致数值溢出。</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-%E9%9D%A2%E7%BB%8F%E5%8F%8A%E9%87%8D%E7%82%B9%E5%85%AB%E8%82%A1/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-%E9%9D%A2%E7%BB%8F%E5%8F%8A%E9%87%8D%E7%82%B9%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="华为面经"><a href="#华为面经" class="headerlink" title="华为面经"></a>华为面经</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="osi七层模型应用层是干什么的？"><a href="#osi七层模型应用层是干什么的？" class="headerlink" title="osi七层模型应用层是干什么的？"></a>osi七层模型应用层是干什么的？</h4><p>为计算机用户提供服务</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240512110255994.png" alt="image-20240512110255994" style="zoom: 50%;" /> <h4 id="udp数据包用在哪一层？"><a href="#udp数据包用在哪一层？" class="headerlink" title="udp数据包用在哪一层？"></a>udp数据包用在哪一层？</h4><p>在传输层</p><h4 id="计算机网络有几层模型？每一层有哪些协议？"><a href="#计算机网络有几层模型？每一层有哪些协议？" class="headerlink" title="计算机网络有几层模型？每一层有哪些协议？"></a>计算机网络有几层模型？每一层有哪些协议？</h4><p>有osi七层模型和TCP&#x2F;IP四层模型</p><p>传输层：UDP和TCP协议</p><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><p>jdk各个版本的特性</p><p>jdk8：interface里面可以有静态方法，有方法体</p><p>数据结构里面增加了红黑树</p><p>Lambda表达式，是个是匿名函数，jdk8允许把函数作为参数传递进方法中</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p><strong>进程</strong>：是程序的一次执行过程，是系统运行程序的基本单位。</p><p><strong>线程</strong>：线程是操作系统进行运算调度的最小单位，它是被包含在进程之中，是进程中的实际运行单位。</p><p>简单理解:应用软件中互相独立,可以同时运行的功能(例如运行360软件是个<strong>进程</strong>,运行360中的木马查杀、电脑清理功能就是<strong>线程</strong>)</p><p><strong>线程和进程的关系，区别及优缺点</strong>：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240508100944328.png" alt="image-20240508100944328" style="zoom:67%;" /> <p><strong>关系</strong>：一个进程中可以有多个线程，这多个线程共享该进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p><p><strong>区别</strong>：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于各进程间是相互独立的，而各线程则不一定，同一进程中的线程可能会相互影响。</p><p><strong>优缺点</strong>：线程执行开销小，但不利于资源的管理和保护，而进程相反。</p><h4 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a><strong>如何创建线程？</strong></h4><p>一般来说创建线程的方式很很多种：比如继承thread类、实现Runnable接口、实现Callable接口和Future接口、使用线程池等、使用CompleteFuture类等等。准确的说这些都是属于在java代码中<strong>使用</strong>多线程的方法。</p><p>严格来说，java只有一种方式可以创建线程，就是通过new Thread().start()创建，不管哪种方式，最终都是依赖于new Thread().start().</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p><p>RUNNABLE: 可运行状态或就绪状态，线程被调用 <code>start()</code>等待运行状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p><h4 id="可以直接调用Thread类的run方法么"><a href="#可以直接调用Thread类的run方法么" class="headerlink" title="可以直接调用Thread类的run方法么?"></a>可以直接调用Thread类的run方法么?</h4><p>如果直接执行run()方法的话，只是把run()方法当成main线程下的普通方法去执行，并不会在某个线程中执行它，这种就不是多线程工作，只有调用start()方法才能启动线程并使线程进入就绪状态。</p><h4 id="线程池如何创建？线程池的优点？"><a href="#线程池如何创建？线程池的优点？" class="headerlink" title="线程池如何创建？线程池的优点？"></a>线程池如何创建？线程池的优点？</h4><p><strong>线程池的概念：</strong>就是管理一系列线程的资源池，当有任务要处理的时候，直接从线程池中获取线程来处理，处理完线程并不会被立即销毁，而是等待下一个任务。</p><p><strong>线程池的优点</strong>：</p><p>1.<strong>减少线程创建和销毁的开销</strong>：重复利用创建的线程来处理任务，降低新线程创建和销毁造成的消耗。</p><p>2.<strong>提高响应的速度</strong>：当有任务时，不用等新线程创建就能立即执行</p><p>3<strong>提高线程的可管理性和系统稳定性</strong>：线程是个稀缺资源，如果无限制的创建，不仅会消耗系统资源，而且还会降低系统的稳定性，使用线程池的话可以进行统一的分配，调优和监控。</p><p><strong>线程池的缺点</strong>：</p><p>1**.资源的消耗**：即使没有任务执行，线程池中的线程也会消耗系统资源</p><p>2.<strong>复杂的调试</strong>：在线程池环境下调试程序可能比单线程程序更复杂，因为线程的执行是异步的，可能涉及到线程同步和资源共享的问题</p><p>3<strong>潜在的资源泄露</strong>：如果线程池中的线程在完成任务后没有正确的释放资源，例如没有关闭文件或网络连接，可能会导致资源泄露。</p><p>4.<strong>可能造成死锁</strong>：线程池中的线程都在相互等待对方释放资源，从而导致死锁。</p><p><strong>线程池如何创建：</strong></p><p>1.通过ThreadPoolExecutor构造函数来创建（推荐）</p><p>2.通过Executor框架的工具类Executors来创建</p><h4 id="死锁是什么-如何避免"><a href="#死锁是什么-如何避免" class="headerlink" title="死锁是什么,如何避免?"></a>死锁是什么,如何避免?</h4><p>定义:死锁就是多个进程或者线程执行的过程中,因为相互等待对方释放资源而无法继续执行的状态.</p><p><strong>如何避免</strong>:在资源分配的时候,借助于算法对资源分配进行计算评估,使其进入安全状态.</p><h4 id="volatile关键字和synchronized区别"><a href="#volatile关键字和synchronized区别" class="headerlink" title="volatile关键字和synchronized区别"></a>volatile关键字和synchronized区别</h4><p>volatile关键字用于<strong>确保变量的修改对所有的线程都是立即可见的</strong>,并<strong>防止指令重新排序</strong>,在一定程度上保证了线程的安全.</p><p>当一个变量被声明为volatile时,每次读取该变量的值都会从主内存中读取,每次修改该变量时都会立即写回主内存.这样任何一个线程对这个变量的修改都会立即对其他线程可见,避免了缓存中的变量值与主内存中的值不同步的问题.</p><p><strong>volatile关键字和synchronized关键字有什么区别</strong></p><p>这两个是互补的存在,不是对立的存在.</p><p>1.volatile关键字是线程同步的轻量级实现,所以volatile性能肯定比synchronized关键字要好.但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块.</p><p>2.<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。</p><p><code>synchronized</code> 关键字两者都能保证。</p><p>3.volatile关键字主要用于解决变量在多个线程之间的可见性,而synchronized关键字解决的是多个线程之间访问资源的同步性.</p><p>java的理解？</p><h4 id="面向对象三大特征？"><a href="#面向对象三大特征？" class="headerlink" title="面向对象三大特征？"></a>面向对象三大特征？</h4><p>封装、继承、多态</p><p><strong>封装：</strong></p><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p><p><strong>继承：</strong></p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p><strong>多态：</strong></p><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>特点:</p><p>对象类型和引用类型之间具有继承(类)&#x2F;实现(接口)的关系</p><p>引用类型变量发出的方法到底是调用哪个类中的方法，必须在程序运行期间才能确定。</p><p>多态不能调用“只在子类存在但在父类中不存在的方法”</p><p>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</p><h4 id="java垃圾回收机制？讲下里面的算法"><a href="#java垃圾回收机制？讲下里面的算法" class="headerlink" title="java垃圾回收机制？讲下里面的算法"></a>java垃圾回收机制？讲下里面的算法</h4><p>垃圾回收机制是一种自动内存管理系统，自动检测和回收不再使用的内存。</p><p><strong>可达性分析算法</strong>，通过gc Root作为起始点进行搜索，当gc root到对象不可达时，证明此对象是不可用的，不可达的对象会被回收。</p><p>gc root对象的选取，可作为 gc root的对象包括下面几种</p><p>1、虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。<br>2、本地方法栈中JNI(Native方法)引用的对象。<br>3、方法区中的类静态属性引用的对象。<br>4、 方法区中常量引用的对象。</p><h4 id="对于多态有什么深层次的理解？"><a href="#对于多态有什么深层次的理解？" class="headerlink" title="对于多态有什么深层次的理解？"></a>对于多态有什么深层次的理解？</h4><h4 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h4><p>重载：发生在同一个类中，方法名相同，参数的类型、个数、顺序、返回值、修饰符可以不同。</p><p>重写：发生在运行期，是子类继承父类的相同方法，输入的数据一样，但要做出有别于父类的响应，覆盖父类的方法。</p><h4 id="对面向对象-的理解？java该怎么去注意这方面？-：讲了java三大特性"><a href="#对面向对象-的理解？java该怎么去注意这方面？-：讲了java三大特性" class="headerlink" title="对面向对象 的理解？java该怎么去注意这方面？  ：讲了java三大特性"></a>对面向对象 的理解？java该怎么去注意这方面？  ：讲了java三大特性</h4><h4 id="用的jdk版本，和以前的有啥变化"><a href="#用的jdk版本，和以前的有啥变化" class="headerlink" title="用的jdk版本，和以前的有啥变化"></a>用的jdk版本，和以前的有啥变化</h4><p>用过stream流式计算？在处理大量数据的情况下的实现？</p><p>单例模式下如何破坏当前的构造器私有？</p><p>反射 setaccessible&#x3D;true，该如何避免？ 答案：使用双&#x2F;三重检测锁，最安全的方法是用枚举类</p><h4 id="forkjoin是什么？"><a href="#forkjoin是什么？" class="headerlink" title="forkjoin是什么？"></a>forkjoin是什么？</h4><p>答案：在jdk1.7并行执行任务的，在处理大量数据时候可以提高效率</p><h4 id="forkjoin底层是什么？"><a href="#forkjoin底层是什么？" class="headerlink" title="forkjoin底层是什么？"></a>forkjoin底层是什么？</h4><p>forkjoin是基于一种称为工作窃取的算法实现的。</p><p>在 Fork&#x2F;Join 框架中，每个工作线程都有自己的双端队列（deque）来存储任务。这种队列支持两端的操作：工作线程通常从队列的一端添加（fork）新的任务，并从同一端取出（pop）任务来执行。当一个线程完成了自己队列中的所有任务，它可以从其他线程的队列的另一端窃取（steal）任务来执行。</p><h4 id="java默认几个线程？"><a href="#java默认几个线程？" class="headerlink" title="java默认几个线程？"></a>java默认几个线程？</h4><p>2个     main和辅助gc线程</p><p>讲讲工厂模式？它的作用？</p><h4 id="一个单线程处理文件，怎么改造成多线程？"><a href="#一个单线程处理文件，怎么改造成多线程？" class="headerlink" title="一个单线程处理文件，怎么改造成多线程？"></a>一个单线程处理文件，怎么改造成多线程？</h4><p>要求之后主任务线程在其他线程处理完之后发送一个最后的通知</p><p>AOP的概念，切点、切面？</p><h4 id="equals-和hashcode-的关系"><a href="#equals-和hashcode-的关系" class="headerlink" title="equals()和hashcode()的关系?"></a>equals()和hashcode()的关系?</h4><p>hashcode()和equals()都是用来比较两个对象是否相等</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值一定相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li><li>如果重写equals()没有重写hashcode()方法的话可能会导致equals方法判断是相等的两个对象，hashcode值却不相等。</li></ul><h4 id="spring框架中的设计模式了解么？"><a href="#spring框架中的设计模式了解么？" class="headerlink" title="spring框架中的设计模式了解么？"></a>spring框架中的设计模式了解么？</h4><p>详细说一下单例模式？</p><p>spring 中单例模式下的 bean 是线程安全的吗？如果多线程访问这个单例 bean 时，spring</p><p>是怎么实现的？</p><p>spring中注解的底层原理？  答案：注解是基于javaconfig实现的</p><p>JvM中，类加载机制了解么  答案：（双亲委派机制）</p><p>tomacat 里的类加载机制了解吗？也是双亲委派机制吗</p><p>秒杀系统的设计？</p><p>秒杀系统中缓存重要还是消息队列重要</p><p>redis为什么能做缓存？</p><p>mybaits的原理？</p><p>dao 接口里面的方法是怎么和 xml 里面的语句进行关联的</p><p>MySQL 默认事务隔离级别，讲一下全部的隔离级别</p><p>MySQL 可重复读会产生幻读的问题吗？</p><p>表里面有两个字段，一个字段是主键索引，一个是唯一索引，哪个效率更高？</p><p>spring事务传播</p><p>jvm内存模型？</p><p>栈和线程是什么关系？</p><p>堆里面分为哪些区域？新生代又分为几个区？</p><p>Linux命令说几个常用的？</p><p>kill kill-9有什么区别？</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库执行一条语句的过程？</p><p>数据库的左右内外连接？</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>最快最稳定的排序算法</p><p>长用的排序算法</p><p>知道的数据结构？</p><p>数组：数组是可以在内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中</p><p>的元素通过数组下标进行访问，数组下标从 0 开始。</p><p>栈：栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。</p><p>栈的特点是：先进后出，或者说是后进先出。</p><p>队列：队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取</p><p>出元素，也就是：先进先出。</p><p>链表：链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链</p><p>表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个</p><p>是指向下一个结点地址的指针域。</p><p>树：树是一种数据结构，它是由 n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合。</p><p>散列表：散列表，也叫哈希表，是根据关键码和值 (key 和 value) 直接进行访问的数据结构，</p><p>通过 key 和 value 来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><p>堆：堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><p>堆中某个节点的值总是不大于或不小于其父节点的值；</p><p>堆总是一棵完全二叉树。</p><p>图：图是由结点的有穷集合 V 和边的集合 E 组成。</p><p>list，set，map 的数据存储区别</p><p>list 和 set 继承自 Collection 接口，是一个个数据存进去的。</p><p>list 里面的元素是有序的，按插入顺序排列的，且是可重复的。</p><p>set 里面的元素是无序的，一般都是使用对应的 map 实现功能，将数据存在 key 上保证唯一性</p><p>map 继承自 Map 接口，map 里面有一个 entry，对应键值对，键值 key 映射着对应的值，</p><p>key 是唯一的，但是 value 不是。</p><p>知道多少种排序？冒泡排序 选择排序 插入排序 希尔排序 快速排序 归并排序 基数排序  堆排序</p><p>说说快速排序？</p><p>1．先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><h4 id="1-TCP、UDP协议是什么？"><a href="#1-TCP、UDP协议是什么？" class="headerlink" title="1.TCP、UDP协议是什么？"></a>1.TCP、UDP协议是什么？</h4><p><strong>UDP协议</strong></p><p>用户数据报协议(User Datagram Protocol)</p><p>UDP是面向无连接的通信协议</p><p>特点：速度快，有大小限制一次最多发送64k，数据不安全，易丢失数据</p><p><strong>TCP协议</strong></p><p>传输控制协议TCP(Transmission Control Protocol)</p><p>TCP协议是面向连接的通信协议，它在通信的两端各建立一个Socket对象，通过Socket产生IO流进行网络通信。</p><p>特点:速度慢，没有大小限制，数据安全</p><h4 id="2-TCP三次握手和四次挥手"><a href="#2-TCP三次握手和四次挥手" class="headerlink" title="2.TCP三次握手和四次挥手"></a>2.TCP三次握手和四次挥手</h4><p><strong>TCP三次握手</strong></p><p>是TCP协议建立连接的一个过程，作用是确保通信端点的双方能够准确的开始数据传输。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507153756698.png" alt="image-20240507153756698" style="zoom:67%;" /> <p>过程：客户端向服务器发出连接请求，等待服务器确认。</p><p>​          服务器向客户端返回一个响应，告诉客户端收到了请求。</p><p>​        客户端向服务器再次发出确认信息，连接建立。</p><p><strong>TCP四次挥手</strong></p><p>是TCP协议关闭连接的一个过程，作用是确保连接双方数据完全处理完毕后，能够被正确的关闭。</p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507154824937.png" alt="image-20240507154824937" style="zoom:67%;" /> <p>过程：客户端向服务器发出取消连接的请求。</p><p>​            服务器向客户端返回一个响应，表示收到客户端取消请求。</p><p>​           服务器将数据处理完毕后，服务器向客户端发出确认取消信息</p><p>​           客户端再次发送确认消息，连接取消。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="9-大顶堆小顶堆怎么删除根节点？"><a href="#9-大顶堆小顶堆怎么删除根节点？" class="headerlink" title="9.大顶堆小顶堆怎么删除根节点？"></a>9.大顶堆小顶堆怎么删除根节点？</h4><h4 id="10-CSRF攻击是什么，怎么预防"><a href="#10-CSRF攻击是什么，怎么预防" class="headerlink" title="10.CSRF攻击是什么，怎么预防"></a>10.CSRF攻击是什么，怎么预防</h4><p>11.springboot常用的注解有哪些？</p><p>12.springboot的配置文件</p><p>13.redis集群的几种方式详细说一下</p><p>14.redis缓存雪崩，缓存击穿，缓存穿透是什么，怎么解决</p><p>15.mysql索引？为什么用B+树</p><h4 id="16-mysql常用数据类型"><a href="#16-mysql常用数据类型" class="headerlink" title="16.mysql常用数据类型"></a>16.mysql常用数据类型</h4><p>数值类型、字符串类型、日期类型</p><h4 id="17-char和varchar的区别"><a href="#17-char和varchar的区别" class="headerlink" title="17.char和varchar的区别"></a>17.char和varchar的区别</h4><p><strong>char是定长字符串,varchar是变长字符串</strong></p><p>18.mysql建索引的原则，索引是不是越多越好，为什么？</p><p>19.springboot用到了哪些设计模式，从源码层面说说你熟悉的以及实现</p><p>20.jvm调优你用什么工具，具体怎么做的，怎么调优</p><p>21.线程优先级，操作系统线程与jvm线程</p><p>22.cas怎么交换</p><h2 id="2024-5-13华为面试问题"><a href="#2024-5-13华为面试问题" class="headerlink" title="2024.5.13华为面试问题"></a>2024.5.13华为面试问题</h2><h4 id="Stringbuilder和Stringbuffer的区别有哪些？"><a href="#Stringbuilder和Stringbuffer的区别有哪些？" class="headerlink" title="Stringbuilder和Stringbuffer的区别有哪些？"></a>Stringbuilder和Stringbuffer的区别有哪些？</h4><p>Stringbuilder对方法或者调用的方法没有加同步锁：<strong>非线程安全</strong></p><p>Stringbuffer对方法或调用的方法添加了同步锁：<strong>是线程安全的</strong></p><p>相同情况下，Stringbuilder会比Stringbuffer性能高，但要冒多线程不安全的风险。</p><h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p>浅拷贝：不管这个对象的内部属性是基本类型还引用类型都完全拷贝过来</p><p>深拷贝：将这个对象内部属性的基本数据类型拷贝过来，字符串类型复用串池里面的，引用数据类型会创建一个新的空间（拷贝过后记录的地址值不同）。</p><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p><strong>关系</strong>：一个进程中可能包含多个线程，线程共享该进程中堆和方法区的资源，同时每个线程也有自己的程序计数器，虚拟机栈和本地方法栈</p><p><strong>区别</strong>：线程是进程划分成的更小执行单位，他们最大的不同就是各个进程之间的运行是相互独立的，线程则不一定，同一进程中的线程之间可能会相互影响。</p><p>线程执行开销小，但不利于资源的管理和保护，进程相反</p><h4 id="Exception-和Error-的区别"><a href="#Exception-和Error-的区别" class="headerlink" title="Exception 和Error 的区别"></a>Exception 和Error 的区别</h4><p>Error：属于程序无法处理错误，不建议使用catch捕获。比如内存溢出、java虚拟机运行错误。</p><p>Exception：属于程序本身可以处理的异常，可以通过catch来捕获。</p><h4 id="聊不了解JVM"><a href="#聊不了解JVM" class="headerlink" title="聊不了解JVM"></a>聊不了解JVM</h4><h4 id="了解反射机制么？"><a href="#了解反射机制么？" class="headerlink" title="了解反射机制么？"></a>了解反射机制么？</h4><h4 id="io输入输出流有哪些？"><a href="#io输入输出流有哪些？" class="headerlink" title="io输入输出流有哪些？"></a>io输入输出流有哪些？</h4><h4 id="数据库索引的底层结构是什么？还有哪些"><a href="#数据库索引的底层结构是什么？还有哪些" class="headerlink" title="数据库索引的底层结构是什么？还有哪些?"></a>数据库索引的底层结构是什么？还有哪些?</h4><p>B+树     Hash    full-text.</p><h4 id="数据库锁有哪些？"><a href="#数据库锁有哪些？" class="headerlink" title="数据库锁有哪些？"></a>数据库锁有哪些？</h4><h4 id="数据库的事务？"><a href="#数据库的事务？" class="headerlink" title="数据库的事务？"></a>数据库的事务？</h4><h4 id="数据库的字段类型有哪些？"><a href="#数据库的字段类型有哪些？" class="headerlink" title="数据库的字段类型有哪些？"></a>数据库的字段类型有哪些？</h4><h4 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h4><h4 id="timedate和timestamp的区别"><a href="#timedate和timestamp的区别" class="headerlink" title="timedate和timestamp的区别"></a>timedate和timestamp的区别</h4><h4 id="2024-5-28运维开发"><a href="#2024-5-28运维开发" class="headerlink" title="2024.5.28运维开发:"></a><strong>2024.5.28运维开发</strong>:</h4><p>1.进程和线程的区别</p><p>2.TCP和UDP协议的区别?</p><p>3.三次握手和四次挥手?</p><p>4.ping属于什么协议?</p><p>5.事务的四大特性?</p><p>6.索引是干什么的?</p><p>7.索引存储过程?(这个没听太清楚)</p><p>8.数据库中针对字段从高到低排序,用什么?</p><p>9.delete和drop的区别?</p><p>10.数据库中对锁有没有了解?锁的性质?</p><p>11.怎么保证数据库高可靠性?</p><p>12.数据库数据丢失的话,怎么解决(比如说宕机)</p><p>13.sql注入??</p><h1 id="手撕代码："><a href="#手撕代码：" class="headerlink" title="手撕代码："></a>手撕代码：</h1><p>力扣：</p><p>02.05链表求和</p><p>328： 奇偶链表</p><p>409 ：最长回文串</p><p>49：字母异位词分组</p><p>1019：链表中的下一个更大节点</p><p>划分字符串</p><p>最长公共字数组</p><p>斐波那契数列</p><p>优化空间复杂度</p><p>224：基本计算器</p><p>1047：删除字符串中的所有相邻重复项</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>项目中遇到的问题，怎么解决？</p><p>项目中遇到委屈的事</p><p>项目中另外几个同学负责什么</p><p>遇到的挫折？怎么解决</p><p>对华为的看法？对华为云的了解</p><p>为什么跨专业学编程？</p><p>自己的优势</p><p>个人的规划？</p><p>项目中学习到了什么？</p><h1 id="重点八股"><a href="#重点八股" class="headerlink" title="重点八股"></a>重点八股</h1><h3 id="java基础-1"><a href="#java基础-1" class="headerlink" title="java基础"></a>java基础</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>概念：通过反射我们可以获取任意一个类的所有属性和方法，并且可以调用这些属性和方法</p><p>应用场景：像Spring&#x2F;SpringBoot、Mybatis等框架中都大量使用了反射机制。这些框架中大量使用了动态代理，而动态代理的实现也是依赖反射机制。在注解中也用到了反射。</p><p>优缺点：优点：让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p><p>​                缺点：增加了一些安全问题，比如可以无视泛型参数的安全检查，另外反射的性能也稍微差点，不过对框架实际影响并不大。</p><p>​        </p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-%E7%AE%80%E5%8E%86%E7%9B%B8%E5%85%B3%E5%85%AB%E8%82%A1/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-%E7%AE%80%E5%8E%86%E7%9B%B8%E5%85%B3%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h1><h4 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h4><p>索引是高效帮助数据库获取数据的数据结构。</p><p>优点：1.提高数据查询的效率、降低数据库io成本</p><p>​            2.通过索引对数据进行排序，降低数据排序的成本，降低菜谱消耗。</p><p>缺点：</p><p>1.索引会占用存储空间</p><p>2.提高查询效率，同时降低了insert、update、delete的效率。</p><p>使用create index …为字段创建索引,一般来讲是where字句中频繁出现的列，在表的特定列上创建索引。</p><p>主键会自动创建索引</p><p>索引的底层是用过B+树存放的，我们创建索引时候会将当前字段插入B+树</p><p>B+树是一个多路平衡搜索树：每一个节点可以存储多个key，所有的数据都存储在叶子节点中，<strong>非叶子节点只用于索引数据</strong>，<strong>叶子节点形成了一颗双向链表，便于数据的排序和查询</strong>。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240513011726368.png" alt="image-20240513011726368"></p><h4 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h4><p>就是在并发访问时候，解决数据一致性和有效性的机制。</p><p>全局锁：对整个数据库加锁</p><p>表级锁：锁表</p><p>行级锁：锁行</p><h4 id="sql优化："><a href="#sql优化：" class="headerlink" title="sql优化："></a>sql优化：</h4><p>1.建表的时候选择合适的类型</p><p><strong>2.使用索引</strong></p><p>3.sql语句的编写：</p><p>尽量避免select*的情况，查询具体的字段</p><p>尽量少用子查询，用join关联查询代替</p><p>尽量不使用or，导致索引失效，分开几条sql写</p><p>执行的时候，批量插入，而不是一条一条插入，分批删除</p><p>避免索引失效的写法</p><p>4.读写分离</p><p>3.sql的执行顺序</p><p>select*from where groupby  having orderby limit</p><p>先执行from语句，查询确定查的表</p><p>再是链接条件，join on</p><p>再是where过滤符合条件的</p><p>再是groupby分组</p><p>having分组后过滤</p><p>最后排序，limit输出</p><p>where是分组前的过滤，having是分组后的过滤</p><p>事务：</p><p>一系列数据库操作被当作是一个单独的逻辑单元，要么全部执行，要么全部回滚</p><p>数据库事务是为了确保事务的完整性和一致性</p><p>数据库由四个属性组成ACID</p><p>原子性：要么全部执行，要么全部回滚</p><p>一致性：事务执行前后，数据库的数据处于一致状态</p><p>隔离性：每个事务独立于其他的事务</p><p>持久性：事务执行成功，就是持久的</p><p>在sql中使用 start Transaction作为事务的开启，rollback回滚，commit提交</p><p>在spring框架中，在service层使用注解@Transactional开启事务</p><p>SpringBoot常用注解：</p><p>启动注解@Springbootapplication,里面包含三个注解。</p><p>然后就是三层架构的：</p><p>@RestController  @Service @Mapper</p><p>在controller层去处理HTTP相关的注解</p><p>@GetMapping @PostMapping @DeleteMapping</p><p>传值相关的注解</p><p>@RequestBody   @pathVariable @RequestParam等</p><p>mapper层的数据库注解</p><p>@insert @Select @Delete等等</p><p>还有通用的@Autwired @configuration @Transcational等等</p><p>华为云计算部门提供广泛的云服务和解决方案，涉及计算、存储、网络和大数据等领域。它利用自主研发的鲲鹏和昇腾处理器提供高性能服务，并通过全球分布的数据中心确保服务的高效和合规。华为云特别强调其在安全性、人工智能和行业定制化解决方案方面的能力，致力于支持企业的数字化转型。同时，华为云在全球范围内建立了强大的合作伙伴网络，推动技术创新和生态系统发展。这些特点使华为云在全球云计算市场中占有一席之地。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-%E5%A4%96%E5%8D%96/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h4 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程:"></a>软件开发流程:</h4><p>需求分析:需求规格说明书、产品原型</p><p>设计：ui设计、数据库设计、接口设计         </p><p>编码：项目代码、单元测试</p><p>测试：测试用例、测试报告</p><p>上线运维：软件环境安装、配置</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240704000209100.png" alt="image-20240704000209100" style="zoom: 80%;" />  <p><strong>软件环境：</strong></p><p><img src="https://img-blog.csdnimg.cn/ece3131c0afb4b0a9e9b2744dee01bc4.png" alt="img"></p><p><strong>项目导入：</strong></p><p>打开ideal  open 选择工程文件的pom文件即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>常见数据结构：栈 、队列、数组、链表、二叉树、二叉查找树、平衡二叉树、红黑树</p><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.<strong>栈</strong></h2><p>特点： 后进先出，先进后出（压子弹）</p><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><p>先进先出，后进后出（排队买票）</p><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.<strong>数组</strong></h2><p>查询快 增删慢</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229162459198.png" alt="image-20240229162459198" style="zoom:50%;" /><h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h2><p>有单向链表和双向链表 </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229163504661.png" alt="image-20240229163504661" style="zoom:50%;" /><p>（1）链表是以节点的方式来存储</p><p>（2）每个节点包含data域即数据域：存储的数据   和  next域即指针域：存放地址值，指向下一个节点的地址</p><p>（3）链表的各个节点不一定是连续存储的</p><p>（4）链表分为带头节点的链表和没有头节点链表，根据实际需求。head节点不存放任何数据，只表示单链表头。</p><h2 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5.二叉树"></a>5.二叉树</h2><p>度：每一个节点的子节点数量</p><p>二叉树中，任意节点的度&lt;&#x3D;2。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229214353467.png" alt="image-20240229214353467" style="zoom: 67%;" /><p><strong>二叉查找树：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229214549814.png" alt="image-20240229214549814" style="zoom: 50%;" /><p><strong>平衡二叉树：</strong></p><p>任意节点左右子树高度差不超过1</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229230823113.png" alt="image-20240229230823113" style="zoom:50%;" /><p>左左：当根节点左子树有节点插入，导致二叉树不平衡</p><p><strong>红黑树：</strong></p><p>红黑树的增删改查的性能都很好</p><p>1.是一个二叉查找树 2.但不是高度平衡的 3.特有的红黑规则</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240301103346683.png" alt="image-20240301103346683" style="zoom:50%;" /><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240301111619619.png" alt="image-20240301111619619" style="zoom:50%;" /> ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h4 id="1二分查找"><a href="#1二分查找" class="headerlink" title="1二分查找"></a>1二分查找</h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312201147800.png" alt="image-20240312201147800"></p><p>二分查找方法用于数组是按照规定顺序，取数组中间值middle与目标值进行比较，不断缩小范围从而得到目标值**</p><h4 id="2-搜索插入位置"><a href="#2-搜索插入位置" class="headerlink" title="2.搜索插入位置"></a><strong>2.搜索插入位置</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240426230638532.png" alt="image-20240426230638532" style="zoom: 67%;" /><p><strong>题解: 用二分法 不断找，然后考虑在数组外的情况即可。</strong></p><h4 id="3在排序数组中查找元素的第一个和最后一个位置"><a href="#3在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="3在排序数组中查找元素的第一个和最后一个位置"></a>3在排序数组中查找元素的第一个和最后一个位置</h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240426230925522.png" alt="image-20240426230925522"></p><p>题解:分别定义两个方法,来获取数组的左边界和右边界,然后调用这两个方法.,在寻找边界的过程中,需要定义一个变量来记录边界值,因为会一直向左或者向右寻找边界.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240429215331604.png" alt="image-20240429215331604"></p><p>题解：要注意 不能用middle*middle来判断大于或者等于 不然会乘法溢出。这里也不能用 middle&#x3D;（left+right）&gt;&gt;&gt;1;     最后return left和right都一样。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240429231026977.png" alt="image-20240429231026977"></p><p>传统二分法来做就行，做了很长时间。。。考虑到乘法溢出的问题  将类型改成long。</p><h4 id="4移除元素"><a href="#4移除元素" class="headerlink" title="4移除元素"></a>4移除元素</h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312210604659.png" alt="image-20240312210604659"></p><p>解题方案：使用双指针来记录位置，快慢指针初始位置都一样,快指针来遍历数组获取要移除之外的元素，将每一个获取的元素赋值给慢指针，慢指针来记录新数组中的元素，从而移除目标元素。</p><h4 id="5-删除有序数组中的重复项"><a href="#5-删除有序数组中的重复项" class="headerlink" title="5.删除有序数组中的重复项"></a>5.删除有序数组中的重复项</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240505214453067.png" alt="image-20240505214453067" style="zoom:80%;" /> <p>题解:首先注意到数组是有序的,说明重复的元素肯定是相邻的,要求删除重复的元素,其实就是将不重复的元素移动到数组的左边</p><p>定义两个指针,快慢指针,low为索引0,fast为索引1,判断快慢指针对应的元素是否相等,如果相等的话,快指针+1,如果不相等的话讲快指针的值 赋值给慢指针+1,然后low++,fast++,直到fast为数组的长度-1时候,结束这个循环.</p><h4 id="6-移动零"><a href="#6-移动零" class="headerlink" title="6.移动零"></a><strong>6.移动零</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240505223901088.png" alt="image-20240505223901088" style="zoom: 67%;" /><p>题解:使用快慢指针,用count记录零出现的次数,首先将数组中零元素移除,移除完之后再将数组末尾添加0元素.</p><h4 id="有序数据的平方"><a href="#有序数据的平方" class="headerlink" title="有序数据的平方"></a>有序数据的平方</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313101706960.png" alt="image-20240313101706960" style="zoom:200%;" /><p>解题: 1.暴力求解直接for循环遍历数组,获得每个元素的平方值,然后再调用Arrays.sort方法对数组进行从小到大的排序.</p><p>2.利用双指针思想,前指针i,末尾指针j,定义新数组,定义变量k为数组长度,通过for循环比较i和j元素的平方大小,将大的存入新数组.</p><h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title=".长度最小的子数组**"></a>.长度最小的子数组**</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313223034996.png" alt="image-20240313223034996" style="zoom: 200%;" /><p>题解： 1暴力求解 两个for循环</p><p>​             2.滑动窗口法：定义一个初始位置和 终止位置，for循环中的变量表示终止位置，当终止位置满足条件时候，起始位置往后面+1 ，总和要减去起始位置的值，在重新从新的起始位置开始往后累加。</p><h4 id="！！螺旋矩阵"><a href="#！！螺旋矩阵" class="headerlink" title="！！螺旋矩阵"></a>！！螺旋矩阵</h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314205520508.png" alt="image-20240314205520508"></p><p>题解： 绕   不会</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis%E6%80%BB%E7%BB%93/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想:"></a>基本思想:</h5><p>缓存可以提高系统性能以及减少请求的响应时间,其本质思想就是利用<strong>空间换时间</strong>这一经典性能优化策略</p><p><strong>其他空间换时间的例子</strong>: </p><p>1.索引:将数据库表中的某些列或者字段按照一定的规则组织成一个单独的数据结构,需要占用额外的内存,但是大大加快了数据库中数据搜索的效率.</p><p>2.数据库表字段冗余:将需要经常联合查询的数据冗余存储在同一张表中,以此来减少多张表的关联查询,进而提升查询性能,减轻数据库压力.</p><p>3.CDN(内容分发网络):将静态资源分发到多个不同的地方以此来实现就近访问,进而加快静态资源的访问素服,减轻服务器以及带宽的压力.</p><h5 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类:"></a><strong>缓存的分类:</strong></h5><p>1.本地缓存</p><p>用的较多,特别是在单体架构,数据量不大,并且没有分布式要求的时候可以使用</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240624103636876.png" alt="image-20240624103636876" style="zoom:50%;" /><p>常见的单体架构图,使用Nginx来做负载均衡,部署两个相同的应用到服务器,两个服务使用同一个数据库,并且使用本地缓存.</p><p>2.分布式缓存</p><p>分布式缓存脱离于应用独立存在,多个应用可以直接的使用同一个分布式缓存服务.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240624103948318.png" alt="image-20240624103948318" style="zoom:50%;" /><p>用Niginx来做负载均衡,部署两个相同的应用到服务器,两个服务器使用同一个数据库和缓存.</p><p>3.多级缓存(很少用)</p><p>也就是本地缓存加分布式缓存</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240624104452328.png" alt="image-20240624104452328" style="zoom:50%;" /><p>为什么使用了分布式缓存还需要本地缓存呢?</p><p>因为本地缓存的访问速度要远大于分布式缓存,因为访问本地缓存不需要额外的网络开销.读取数据先从L1读取,读不到再从L2读取,还是没有的话去数据库中查,查询成功后将数据写入L1和L2.</p><p>多级缓存适用的业务场景:</p><p>1.缓存的数据不会频繁修改</p><p>2.数据访问量很大比如说秒杀</p><h5 id="Redis的基本数据类型及其应用场景"><a href="#Redis的基本数据类型及其应用场景" class="headerlink" title="Redis的基本数据类型及其应用场景:"></a>Redis的基本数据类型及其应用场景:</h5><p><strong>1.string类型:</strong></p><p>是redis中最简单也是最常用的一种数据类型.</p><p>可以用来存储各种数据类型比如字符串、整数、浮点数、图片、序列化后的对象</p><p><strong>应用场景：</strong></p><p>缓存session、token、图片地址、序列化后的对象等。</p><p><strong>2.List类型</strong></p><p>Redis的实现是一个双向链表，支持反向查找和遍历</p><p><strong>应用场景：</strong></p><p>信息流展示：最新动态，最新文章</p><p>消息队列：list可以用来做消息队列，只是功能过于简单存在很多缺陷，一般不建议。</p><p><strong>3.Hash类型</strong></p><p>是一个string类型的键值对的映射表，适合用于存储对象。类似于jdk1.8之前的Hashmap，内部实现为数组+链表</p><p><strong>应用场景</strong>：</p><p><strong>一般是对象数据存储场景</strong>：</p><p>用户信息、商品信息、购物车信息</p><p><strong>4.set集合</strong></p><p>set集合中的元素无序，但是唯一。</p><p><strong>应用场景：</strong></p><p><strong>需要存放的数据不能重复</strong>：比如动态点赞</p><p>共同关注、</p><p><strong>随机获取数据源中的元素：</strong></p><p>抽奖系统、随机点名</p><p><strong>5.SortedSet有序集合</strong></p><p>和set相比增加了一个权重参数score，使得集合中的元素按照score进行有序排列</p><p><strong>应用场景</strong>：各种各样的排行榜</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis-%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-Redis-%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="2Redis-项目"><a href="#2Redis-项目" class="headerlink" title="2Redis 项目"></a>2Redis 项目</h1><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418141457766.png" alt="image-20240418141457766"></p><h1 id="Redis快速入门"><a href="#Redis快速入门" class="headerlink" title="Redis快速入门"></a>Redis快速入门</h1><h4 id="sql和nosql区别"><a href="#sql和nosql区别" class="headerlink" title="sql和nosql区别"></a>sql和nosql区别</h4><p><strong>关系型数据库SQL  和 非关系型数据库 NoSQL的区别:</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418234841852.png" alt="image-20240418234841852" style="zoom:67%;" /> <p><strong>Redis是一个基于内存的键值型NoSQL数据库,有以下的特征:</strong></p><p>1.键值型,value支持多种不同数据结构,功能丰富</p><p>2.单线程,每个命令具备原子性</p><p>3.低延迟,速度快(基于内存、IO多路复用、良好的编码)</p><p>4.支持主从集群、分片集群</p><p>5.支持多语言客户端</p><h4 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h4><p><strong>Redis数据结构介绍</strong></p><p>Redis是一个key-value的数据库，<strong>key</strong>一般是<strong>String类型</strong>，不过value的类型多种多样</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418235953715.png" alt="image-20240418235953715" style="zoom:67%;" /><p><strong>Redis通用命令</strong> </p><p>对任何数据类型都适用的命令,常见的有:</p><p><strong>KEYS</strong>:查看符合模版的所有key,</p><p><strong>DEL</strong>:删除一个指定的key</p><p><strong>EXISTS</strong>:判断key是否存在</p><p><strong>EXPIRE</strong>:给一个key设置有效期,有效期到期时key会被自动删除</p><p><strong>TTL</strong>:查看一个key的剩余有效期</p><p>通过<strong>help [command]</strong> 可以查看一个命令的具体用法,例如:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419003533546.png" alt="image-20240419003533546" style="zoom:67%;" /><h4 id="Redis常见的五种数据结构"><a href="#Redis常见的五种数据结构" class="headerlink" title="Redis常见的五种数据结构:"></a>Redis常见的五种数据结构:</h4><h5 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1.String类型"></a>1.<strong>String类型</strong></h5><p>也就是字符串类型,是Redis最简单的存储形式</p><p>其中value是字符串,不过根据字符串的格式不同,分为三类:</p><p><strong>1.string</strong>:普通字符串</p><p><strong>2.int:整数类型</strong>,可以做自增、自减操作</p><p><strong>3.float浮点类型</strong>，可以做自增、自减操作</p><p>不管哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512M</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419004332753.png" alt="image-20240419004332753" style="zoom:67%;" /> <p><strong>String类型的常见命令</strong> </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419010959587.png" alt="image-20240419010959587" style="zoom:50%;" /> <p><strong>key的结构</strong></p><p>Redis的key允许有多个单词形成<strong>层级结构</strong>，多个单词之间用‘ ：’隔开，格式如下：</p><p>​         项目名：业务名：类型：id              格式并非固定</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419012005325.png" alt="image-20240419012005325" style="zoom:67%;" /> <h5 id="2-Hash类型"><a href="#2-Hash类型" class="headerlink" title="2.Hash类型"></a>2.<strong>Hash类型</strong></h5><p>Hash类型，也叫散列，其value是一个无序字典，类似于java中的HashMap结构</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419130743896.png" alt="image-20240419130743896" style="zoom: 67%;" /> <p><strong>Hash类型常见命令</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419132300636.png" alt="image-20240419132300636" style="zoom:67%;" /> <h5 id="3-list类型的常见命令"><a href="#3-list类型的常见命令" class="headerlink" title="3.list类型的常见命令"></a>3.<strong>list类型的常见命令</strong></h5><p>List中的List类型与java中的LinkedList类似，可以看成是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><p>有序   元素可以重复   插入与删除快  查询速度一般    </p><p>常用来存储一个有序数据，比如<strong>朋友圈点赞列表</strong>，<strong>评论列表</strong>等。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240419134349259.png" alt="image-20240419134349259" style="zoom:67%;" /> <h5 id="4-Set类型"><a href="#4-Set类型" class="headerlink" title="4.Set类型"></a>4.<strong>Set类型</strong></h5><p>redis的set结构与java中的hashset类似，可以看作是一个value为null的HashMap。因为它是一个hash表，因此具备与HashSet类似的特征：</p><p><strong>无序</strong>、<strong>元素不可重复</strong>、查找快、支持交集、并集、差集等功能</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421001657154.png" alt="image-20240421001657154" style="zoom:67%;" /> <h5 id="5-SortedSet类型"><a href="#5-SortedSet类型" class="headerlink" title="5.SortedSet类型"></a>5.SortedSet类型</h5><p>redis的sortset是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大。sortedset中的每个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个<strong>跳表SkipList加hash表</strong></p><p>sortedSet具有下列特性：</p><p><strong>可排序</strong>、元素不重复、查询速度快、</p><p>因为其可排序特性，经常被用来实现<strong>排行榜</strong>这样的功能。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421005100146.png" alt="image-20240421005100146" style="zoom: 50%;" /> <h4 id="Redis的java客户端"><a href="#Redis的java客户端" class="headerlink" title="Redis的java客户端"></a>Redis的java客户端</h4><p>提供了 Redis 命令对应的 API，方便我们操作 Redis</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421011031969.png" alt="image-20240421011031969" style="zoom:67%;" /><p><strong>Spring Data Redis</strong> 定义了一套Api,Api底层既可以用jedis也可以用lettuce实现.我们后期直接学习Spring Data Redis.</p><h5 id="1-Jedis快速入门"><a href="#1-Jedis快速入门" class="headerlink" title="1.Jedis快速入门"></a>1.<strong>Jedis快速入门</strong></h5><p><strong>jedis 操作步骤:</strong></p><ol><li><p>引入依赖</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112723122.png" alt="image-20240421112723122"> </p></li><li><p>建立连接,创建jedis对象</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112741720.png" alt="image-20240421112741720" style="zoom:67%;" /> </li><li><p>测试string  使用jedis,方法名与Redis命令一致.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112812820.png" alt="image-20240421112812820" style="zoom:67%;" /> <ol start="4"><li><p>释放资源</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421112834150.png" alt="image-20240421112834150" style="zoom: 80%;" /> <p> <strong>Jedis连接池</strong></p><p>jedis本身是线程不安全的,并且频繁的创建和销毁连接会有性能损耗,因此使用jedis连接池代替jedis的直连方式</p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523014644281.png" alt="image-20240523014644281" style="zoom:67%;" /></li></ol></li></ol><p><strong>SpringDataRedis</strong></p><p>SpringData是Spring中数据操作的模块,包含对各种数据库的集成,其中对Redis的集成模块就叫做SpringDataRedis</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421155600443.png" alt="image-20240421155600443" style="zoom:67%;" /> <p><strong>SpringDataRedis快速入门</strong>(<strong>重点</strong>)</p><p>SpringDataRedis中提供了**RedisTemplate工具类,**其中封装了各种对Redis的操作.并且将不同数据类型的操作API封装到了不同的类型中:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421233012858.png" alt="image-20240421233012858" style="zoom:50%;" /> <p><strong>1.引入依赖</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421231014908.png" alt="image-20240421231014908" style="zoom:50%;" /> <ol start="2"><li><p><strong>配置文件</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421232302361.png" alt="image-20240421232302361" style="zoom:67%;" /> <p><strong>3.注入RedisTemplate</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421232743397.png" alt="image-20240421232743397"> 4</p><p>4.<strong>编写测试</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240421232804441.png" alt="image-20240421232804441" style="zoom:67%;" /> <h5 id=""><a href="#" class="headerlink" title=""></a></h5></li></ol><h5 id="2-自定义序列化的方式"><a href="#2-自定义序列化的方式" class="headerlink" title="2.自定义序列化的方式"></a>2.自定义序列化的方式</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p>RedisTemplate可以接收任意Object作为值写入Redis,只不过写入前会把Object序列化为字节形式,默认采用JDK序列化,得到的结果是这样的:</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523091401635.png" alt="image-20240523091401635"></p><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><p>可读性差</p><p>内存占用较大</p><p>这时候就需要我们自定义RedisTemplate的序列化方式:</p><p>自定义Redisconfig类,添加@Configuration标记为配置类</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523093642108.png" alt="image-20240523093642108"></p><p>这里采用了<strong>JSON序列化来替代默认的JDK序列化方式</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523093912096.png" alt="image-20240523093912096"></p><p>能将java对象自动的序列化为JSON字符串,并且查询时能自动将JSON反序列化为java对象.</p><p>写入了JSON的同时,也写入了class属性,对应的就是java对象字节码的名称,正是因为有这样的属性,所以在序列化的时候能读取对应的字节码也就是类的名称,然后将json实现反序列化.</p><p>但这样会带来<strong>额外的内存开销.</strong></p><h5 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a><strong>StringRedisTemplate</strong></h5><p>为了节省内存空间,我们并不会使用JSON序列化器来处理value,而是统一使用String序列化器,要求只能存储Sring类型的key和value,当需要存储java对象时,<strong>手动完成对象的序列化和反序列化.</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523102557410.png" alt="image-20240523102557410"></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523103914868.png" alt="image-20240523103914868"></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240422150118545.png" alt="image-20240422150118545" style="zoom: 67%;" /> <h1 id="Redis企业实战"><a href="#Redis企业实战" class="headerlink" title="Redis企业实战"></a>Redis企业实战</h1><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240422152145710.png" alt="image-20240422152145710" style="zoom: 67%;" /> <p><strong>短信登录</strong>:   利用Redis的共享session来实现</p><p><strong>商户缓存查询</strong>:企业的缓存使用技巧,了解缓存雪崩、穿透击穿等问题及解决方案</p><p><strong>优惠券秒杀：</strong>Redis的计数器、lua脚本Redis 、Redis分布式锁的原理，Redis的三种消息队列</p><p><strong>达人探店：</strong>基于List的点赞列表，基于SortedSet的点赞排行榜</p><p><strong>好友关注</strong>：基于Set集合的关注、取关、共同关注、消息推送等功能</p><p><strong>附近商铺：</strong>Redis的Geohash的应用</p><p><strong>用户签到：</strong>Redis的BitMap数据统计功能</p><p><strong>UV统计：</strong>Redis的HyperLog的统计功能</p><p>该项目是个单体项目，采用前后端分离模式，前端部署在NGINX服务器上，后端部署在tomact上。当pc端发起请求的时候，请求页面也就是向NGINX发起请求得到静态资源，页面通过nigix向服务端发起请求去查询数据，数据可能来自mysql集群或者Redis集群，把查询到的数据返回给前端，前端完成渲染就ok了。</p><p>项目开始前，在<strong>application.yaml</strong>中要进行项目配置，数据的连接池配置，redis地址</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523150334083.png" alt="image-20240523150334083" style="zoom:50%;" /> <h2 id="1-短信登录"><a href="#1-短信登录" class="headerlink" title="1.短信登录"></a>1.短信登录</h2><h5 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h5><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240423004145660.png" alt="image-20240423004145660"></p><p> <strong>1.发送短信验证码</strong></p><p>用户提交自己手机号,服务端接收到手机号去校验手机号是否合法,不合法重新提交手机号,合法的话,生成一个验证码保存在session中后 将验证码发送给用户.</p><p><strong>2.短信验证码登录、注册</strong>(两功能合二为一)</p><p>用户提交手机号和验证码,后台拿到session之前保存的验证码和用户输入的验证码进行对比,不一致的话校验不通过,一致的话后台再根据手机号去查询用户是否存在,如果不存在的话就注册新用户,为该手机号创建账号信息,保存到数据库中,并将<strong>新创建</strong>的用户登录信息保存到session中,如果存在的话就直接将用户信息保存在session中.</p><p><strong>3.校验登录状态.</strong></p><p>登录成功后,用户访问一些关键的业务的时候,需要校验登录状态.</p><p>session是基于cookie的, 每一个session都有一个sessionid保存在浏览器cookie当中</p><p>用户请求访问的时候,会携带cookie,cookie中就有个sessionid,后台通过sessionid找到对应session,看是否存在该用户信息,存在的话讲用户信息<strong>缓存到threadLocal</strong>中后续的业务可以直接从threadlocal中获取用户,并放行,没有的话,则进行拦截.</p><p>threadLocal是一个线程域对象，每一个请求到达我们的服务它都是一个独立的线程，如果没有使用threadlocal而是使用本地变量的话，可能会出现多线程修改并发的安全问题，threadLocal会将数据保存到每一个线程的内部，在线程内部创建有一个map去保存，每个线程都有自己独立的存储空间，每一个请求来了会有自己的空间，相互间不干扰。后续的业务都可以直接从threadlocal中取出自己的用户信息。</p><p>1.发送短信验证码代码实现:（调用阿里云短信平台  ）</p><p>编写一个业务的接口来实现前端的请求,然后按照业务流程来逐一实现.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523155444017.png" alt="image-20240523155444017" style="zoom:50%;" /><p>在service接口的实现类中写的代码:</p><p>发送验证码:</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523165857041.png" alt="image-20240523165857041"></p><p>2.短信验证码校验登录:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523203735827.png" alt="image-20240523203735827" style="zoom: 50%;" /><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523203749286.png" alt="image-20240523203749286" style="zoom:50%;" /><p>3.校验登录状态</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240523204352374.png" alt="image-20240523204352374" style="zoom:80%;" /><p>前端传递过来的请求都先经过拦截器</p><p>想将拦截器拦截到的用户信息传递到Controller中去,传递的过程中需要注意线程安全问题:将用户信息保存到<strong>ThreadLocal</strong>中去</p><p>设置一个登录拦截器,loginInterceptor,实现HandlderInterceptor接口中的preHandle前置拦截（<strong>做登录校验的</strong>）和afterCompletion(<strong>业务执行完毕</strong>，<strong>移除用户,避免内存泄漏</strong>).拦截器在session中获取用户信息,再存储到线程池</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524002620938.png" alt="image-20240524002620938" style="zoom: 50%;" /> <p>在Mvcconfig类中去配置拦截器的拦截范围.配置类用@Configuration告诉spring在启动时候加载配置,在配置类中将拦截的对象@Autowired,再去配置拦截的过滤属性.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524002811236.png" alt="image-20240524002811236" style="zoom:50%;" /> <p>**集群的session共享问题:**多台Tomcat并不共享session存储空间, 当请求切换到 不同tomcat服务时导致数据丢失的问题.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524003427092.png" alt="image-20240524003427092" style="zoom: 50%;" /><p>每个 tomcat 中都有一份属于自己的 session, 假设用户第一次访问第一台 tomcat，并且把自己的信息存放到第一台服务器的 session 中，但是第二次这个用户访问到了第二台 tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的 session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是 session 拷贝，就是说虽然每个 tomcat 上都有不同的 session，但是每当任意一台服务器的 session 修改时，都会同步给其他的 Tomcat 服务器的 session，这样的话，就可以实现 session 的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份 session 数据，服务器压力过大。</p><p>2、session 拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于 redis 来完成，我们把 session 换成 redis，redis 数据本身就是共享的，就可以避免 session 共享的问题了。redis是在tomcat以外的一个存储方案，任何一台tomcat都能访问到redis。</p><p><strong>session的替代方案应该满足:</strong></p><p>数据共享</p><p>内存存储</p><p>key、value结构</p><h5 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a><strong>基于Redis实现共享session登录</strong></h5><p>Redis的实现思路:</p><p>设计存储的key和value:</p><p>key使用子串,value使用map&lt;k,v&gt;结构</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524005906113.png" alt="image-20240524005906113" style="zoom: 80%;" /> <p><strong>优化后的流程</strong>:</p><p>将<strong>session</strong>替换成<strong>了redis</strong>,发送短信验证码时候,保存验证码到redis中时**,key是手机号<strong>，</strong>value是验证码**</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524010937204.png" alt="image-20240524010937204"></p><p>以<strong>随机token</strong>为key存储用户数据,再将用户保存到redis之后,还要将token返回给客户端(浏览器)并保存,以便再校验登录状态时,请求中携带Token,从Redis中获取用户.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524011048843.png" alt="image-20240524011048843"></p><p>将基于Redis共享session实现短信登录功能改动部分:</p><p><strong>1.在发送短信验证码部分:</strong></p><p>只有一个改动,保存验证码不在保存在session中,而是保存在Redis中,保存到Redis中时,<strong>key不再是”code”,而是手机号</strong>.确保每个手机号都有自己唯一的key,在登陆时能基于手机号取到验证码,从而实现验证.</p><p><strong>2.短信验证码登录和注册部分:</strong></p><p>2.1将从session中获取验证码改成从Redis中获取验证码</p><p>2.2将保存用户信息到session中改成保存用户信息到Redis中,并且以随机token为key存储用户数据(使用uuid获取随机数),将User对象转换成Hash存储,最后返回token给客户端,可以理解成返回给前端,保存在浏览器（如何实现？前端把token保存在请求头中）,并设置token有效期.</p><p><strong>3.效验登录状态部分,修改拦截器:</strong></p><p>3.1.显示获取请求头中的token</p><p>3.2.然后基于token获取redis中的用户</p><p>3.3判断用户是否存在:不存在就拦截,存在的话将查询到的hash数据转换成UserDTO对象</p><p>3.4将用户信息保存在ThreadLocal中</p><p>3.5.最后刷新token有效期,放行.</p><p>**登录拦截器的优化:**为什么要去优化呢?因为我们给token设置了有效期，需要实现只要用户一直访问  token有效期就一直刷新这个功能。</p><p>如果用户一直访问的是不需要校验的路径比如首页,拦截器不会生效，当设置的token有效期过期时,他再去访问一些需要校验的路径那么就会出错,所以先设置一个拦截器来来拦截所有的路径,然后刷新token有效期.</p><p>**第一个拦截器的作用是得到用户,保存在ThreadLocal中,并且确保一切行为都会触发token刷新有效期这个动作.**不存在的话也会放行。拦截一切路径</p><p><strong>第二个拦截器其实做的是拦截的动作，查询threadlocal中的用户，不存在的话就拦截，存在的话就放行。</strong>拦截需要登录校验的路径。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240425000523202.png" alt="image-20240425000523202" style="zoom:67%;" /> <p>配置拦截器的部分</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524141429899.png" alt="image-20240524141429899"></p><p>Redis代替session需要考虑的问题：</p><p>选择合适的数据结构：验证码 这种 就选用string类型的就行，像对象类型的这种采用hash，因为占用的存储空间更小，可以对单个字段进行修改，更加的灵活。</p><p>选择合适的key：一方面考虑他的唯一性，另一方面考虑下一次取的时候更加方便</p><p>设置有效期   ：避免长期存储，占用过多内存</p><p>选择合适的存储力度：只存储一些不敏感的数据 </p><p>thread的内存泄漏如何解决：在生成拦截器的时候实现了请求前和请求后，请求前存入threadlocal，请求后释放</p><h2 id="2-商户查询缓存"><a href="#2-商户查询缓存" class="headerlink" title="2.商户查询缓存"></a>2.商户查询缓存</h2><h5 id="2-1缓存："><a href="#2-1缓存：" class="headerlink" title="2.1缓存："></a>2.1<strong>缓存</strong>：</h5><p>数据交换的缓冲区，<strong>临时存储数据的地方</strong>，一般读写性能比较高</p><p>cpu会把经常需要读写的数据放到缓存中去</p><p><strong>缓存的作用：</strong></p><p>降低后端负载、提高读写效率、降低响应时间</p><p>缓存的成本：</p><p><strong>数据一致性成本</strong>（比如说我在redis缓存了数据库中的部分数据，当用户查询的时候 优先去查redis，减轻了数据库压力，如果数据库的数据发生了变化，而缓存的还是旧的数据，两者就产生了不一致。</p><p>代码维护成本</p><p>运维成本</p><p>缓存的作用模型和根据id查询商铺缓存的流程图</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524184240374.png" alt="image-20240524184240374"></p><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>是为了解决数据不一致的问题.Redis缓存了数据库中部分数据,但是后来数据库更新了,我们读取到的还是旧数据.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427000259422.png" alt="image-20240427000259422" style="zoom: 50%;" /> <p><strong>由缓存的调用者，在更新数据库的同时更新缓存。（在企业开发中常用）</strong></p><p><strong>操作缓存和数据库的时候有三个问题需要考虑：</strong></p><p><strong>1.删除缓存还是更新缓存？</strong></p><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多</p><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存(一般选这个)</p><p><strong>2.如何保证缓存与数据库的操作同时成功或失败？</strong></p><p>单体系统：将缓存与数据库操作放在一个事务</p><p>分布式系统：利用TCC等分布式事务方案</p><p><strong>3.先操作缓存还是先操作数据库</strong></p><p>看情况</p><p>一般来说先 更新数据库，再删除缓存的容错率更高些。</p><p><strong>缓存更新策略的最佳实践方案：</strong></p><p>1.低一致性需求：使用Redis自带的内存淘汰机制</p><p>2.高一致性需求：主动更新，并以超时剔除作为兜底方案</p><p><strong>读操作：</strong></p><p>缓存命中直接返回</p><p>缓存未命中则查询数据库，并写入缓存，设定超时时间</p><p><strong>写操作</strong>：</p><p>先写数据库，再删除缓存</p><p>要确保数据库与缓存操作的原子性</p><p>需求：给查询商铺的缓存添加超时剔除和主动更新的策略</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>1.根据id查询店铺，如果缓存未命中，则查询数据库，将数据库写入缓存，并设置超时时间</p><p>2.根据id修改店铺，先修改数据库，再删除缓存</p><p><strong>案例：实现商铺缓存和数据库缓存的双写一致</strong></p><p>思路:修改ShopController中的业务逻辑：</p><p>根据id查询去查询商家店铺，如果缓存未命中的话，则在数据库中查询，将数据库中的结果写入缓存，并设置超时时间。</p><p>根据id去更新商家店铺的时候，<strong>先修改数据库，再删除缓存</strong>。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524235539673.png" alt="image-20240524235539673" style="zoom:67%;" /><h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a><strong>缓存穿透</strong>：</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525001450918.png" alt="image-20240525001450918" style="zoom: 67%;" /><p>如果恶意用户，整无数的线程<strong>并发</strong>的来向这个不存在 数据发起请求的话，所有的请求都会到达数据库，很有可能把我们的数据库搞垮。</p><p>常见的解决方案：</p><p>1.<strong>缓存空对象</strong>：就是把null缓存在redis中</p><p>优点：实现简单，维护方便                                                        </p><p>缺点：额外的内存消耗       可能造成短期的不一致      </p><p>​                                                   </p><p><strong>2.布隆过滤</strong> 在redis和客户端之间加了一层拦截. 是一种算法，是利用哈希思想解决问题。通过一个庞大的二进制数组，用哈希思想去判断当前要查询的数据是否存在。但有个小缺点，就是它的判定不一定非常准确，它如果判定不存在的话，那么在数据库中一定不存在，但是如果判断存在的话，在数据库中可能不存在。</p><p>优点：内存占用较少，没有多余key</p><p>缺点：实现复杂，存在误判可能                                               </p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427160439307.png" alt="image-20240427160439307" style="zoom: 50%;" /><p><strong>编码解决穿透的问题：</strong></p><p>原来的逻辑中如果请求的数据在数据库中不存在的话，会返回404，会造成缓存穿透的现象。</p><p>修改：</p><p>在缓存中未命中的话，去数据库中查询，如果存在则将数据写入到Redis缓存中，不存在将空值值写入Redis。当下一次请求进来的时候如果命中了缓存，在判断是否为空值，是的话直接返回null，不是的话返回商铺的信息。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525005654337.png" alt="image-20240525005654337"></p><p><strong>总结：</strong></p><p><strong>缓存穿透产生的原因是什么</strong>？</p><p>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大的压力</p><p><strong>缓存穿透的解决方案有哪些</strong>？</p><p>被动措施:</p><p>缓存null值   布隆过滤</p><p>主动:</p><p>  增强id的复杂度，避免被猜测id规律(雪花算法)</p><p>做好数据的基础格式校验  加强用户权限校验   做好热点参数的限流</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525013448388.png" alt="image-20240525013448388" style="zoom: 67%;" /> <p>缓存雪崩是指在同一时段<strong>大量的缓存key同时失效</strong>（比如说过期啊）或者<strong>Redis服务宕机</strong>,导致大量请求到达数据库,带来巨大压力.</p><p>解决方案:</p><p>给不同的key的TTL添加随机数值（避免key同时到期）</p><p>利用Redis集群提高服务的可用性（用来解决Redis宕机）</p><p>给缓存业务添加降级限流策略(微服务里面的)</p><p>给业务添加多级缓存</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>缓存击穿问题</strong>也叫热点key问题,就是一个被<strong>高并发访问</strong>（可能是在做活动的某件商品）并且<strong>缓存重建业务较复杂</strong>的key突然失效了,无数的请求访问会在瞬间给数据库带来巨大的压力</p><p>常见解决方案：</p><p>1.利用互斥锁来解决</p><p>就是当一个线程进来的时候发现未命中缓存，那么他将被上锁 ，其他线程无法对其干扰，该线程继续查询数据库并缓存数据，知道将缓存数据写入时，再释放锁。</p><p>缺点就是 万一有很多的线程同时访问，只能有一个线程进行写入缓存的操作，而其他的线程只能去等待。性能比较差吧。</p><p>2.逻辑过期（很佛系,有人在更新了,我先返回旧数据.）</p><p>当我们在redis中存储数据的时候，我们不再设置TTL，只是设置一个逻辑过期时间，如果线程1请求数据的时候发现逻辑时间过期了，那么他将获取一个互斥锁，并开启一个新的线程2去查询数据库并重建缓存数据，同时线程1返回过期的数据，线程2写入缓存后并设置逻辑过期时间，完成后释放锁，如果有其他的线程3在锁释放之前访问的话，也会返回过期的数据。性能比单纯的加互斥锁要好,因为线程不需要等待锁释放再执行.</p><p><strong>互斥锁和逻辑过期的流程:</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427205447397.png" alt="image-20240427205447397" style="zoom: 67%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427211529725.png" alt="image-20240427211529725" style="zoom: 50%;" /> <p>没有孰优孰劣之分,一个保证一致性一个保证可用性.根据需求来吧.</p><p><strong>基于互斥锁方式解决缓存击穿问题</strong> </p><p>需求:修改根据id查询商铺的业务,基于互斥锁方式来解决缓存击穿问题.</p><p><strong>核心的思路就是利用redis的setnx方法来表示获取锁</strong>，如果redis中没有这个key，则插入成功返回1，如果该key值已经存在了，则插入失败返回0. 成功在StringRedisTemplate中返回true，失败返回false。</p><p>成功插入的key的线程我们认为它是获得到锁的线程。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240427214230769.png" alt="image-20240427214230769" style="zoom:67%;" /> <p><strong>基于逻辑过期方式解决缓存击穿问题</strong></p><p>该流程比较复杂:</p><p>当用户开始查询 Redis 的时候，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将 value 取出，判断 value 中的过期时间是否满足，如果没有过期，则直接返回 Redis 中的数据，如果过期了，则在开启独立线程后直接返回之前的数据，独立线程去实现缓存重建，重建完成后释放互斥锁。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240525140933886.png" alt="image-20240525140933886" style="zoom:67%;" /> <h4 id="缓存工具封装类"><a href="#缓存工具封装类" class="headerlink" title="缓存工具封装类"></a>缓存工具封装类</h4><p>将缓存穿透击穿雪崩等问题的解决方案封装成工具</p><p>利用java提供的函数式编程的思想，去将数据库查询传递给我们的工具类，从而实现任意数据的数据库查询。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240526133246359.png" alt="image-20240526133246359" style="zoom: 67%;" /><h2 id="3-优惠券秒杀"><a href="#3-优惠券秒杀" class="headerlink" title="3.优惠券秒杀"></a>3.优惠券秒杀</h2><h4 id="全局唯一id（下单时id的唯一性）"><a href="#全局唯一id（下单时id的唯一性）" class="headerlink" title="全局唯一id（下单时id的唯一性）"></a><strong>全局唯一id</strong>（下单时id的唯一性）</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240526143528201.png" alt="image-20240526143528201" style="zoom: 67%;" /> <p>当用户抢购时，会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增id就会存在一些问题：</p><p>1.id 的规律性太明显,能让用户猜测到一些信息(比如该商家一天卖了多少单)</p><p>2.受单表数据量的限制(存储数据量达到一定规模的时候,要将数据分到多张表,如果用自增加的话多个表的id会重复,违背了订单id不重复的这个逻辑)</p><p><strong>全局ID生成器</strong>:</p><p>是一种在分布式系统下用来生成<strong>全局唯一</strong>ID的工具</p><p>一般要满足以下特性：</p><p>唯一性、高可用、高性能、递增性、安全性</p><p>为了增强ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息.  时间戳+自增id.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240526151454258.png" alt="image-20240526151454258"></p><p>ID的组成部分：</p><p>符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2的32次方不同ID</p><p><strong>全局唯一ID生成策略:</strong></p><p>UUID</p><p>Redis自增</p><p>snowflake算法（雪花算法）</p><p>数据库自增（单独整一张表，单独用来做自增）</p><p><strong>Redis自增策略:</strong></p><p>每天一个key,方便统计订单量</p><p>ID构造是时间戳+计数器</p><h4 id="实现优惠券秒杀下单："><a href="#实现优惠券秒杀下单：" class="headerlink" title="实现优惠券秒杀下单："></a><strong>实现优惠券秒杀下单：</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527091138307.png" alt="image-20240527091138307" style="zoom:50%;" /> <p>tb_voucher:优惠券的基本信息，优惠金额，使用规则等</p><p>tb_seckil_voucher:优惠券的库存、开始抢购时间、结束抢购时间。特价优惠券才需要填写这些信息。</p><p><strong>优惠券秒杀下单流程图：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527095647692.png" alt="image-20240527095647692" style="zoom:67%;" /> <h4 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a><strong>库存超卖问题</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527140047524.png" alt="image-20240527140047524" style="zoom:67%;" /><p>假设线程 1 过来查询库存，判断出来库存大于 1，正准备去扣减库存，但是还没有来得及去扣减，此时线程 2 过来，线程 2 也去查询库存，发现这个数量一定也大于 1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p>超卖问题是典型的<strong>多线程安全问题</strong>，针对这一问题常见的解决方案就是<strong>加锁</strong>：</p><p><strong>悲观锁：</strong></p><p>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</p><p>例如Synchronized、Lock都属于悲观锁</p><p><strong>乐观锁</strong>：(会出现aba问题)</p><p>认为线程安全问题不一定会发生，因此不加锁，<strong>只是在更新数据时去判断有没有其他线程对数据做了修改。</strong>（这一步判断是重点）</p><p>如果没有修改则认为是安全的，自己才更新数据</p><p>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</p><p><strong>判断之前查询到的数据是否有被修改过，常见的方式有两种：</strong></p><p><strong>1.修改版本号</strong>（应用最广泛和最普遍的）</p><p>给数据加上一个版本，每次操作数据成功后，版本号会加1，在查询库存和版本号时，查到了库存和对应的版本号，在准备修改数据时判断库存是否符合条件，并校验版本号是否还是之前查询到的版本号，如果版本号没变，则前面没有被其他人修改过，如果版本号变了，说明就被修改了。修改库存完成后，还要将版本号加1.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527142319556.png" alt="image-20240527142319556" style="zoom:50%;" /><p><strong>2.CAS方法（用数据本身是否变化来判断线程是否安全）</strong>(会出现aba问题)</p><p>就是查询到库存信息 ，然后准备修改库存信息的时候，在判断库存是否和之前查询到的一样，如果不一样，则说明数据 中途被别人修改了。其实这种方法就是对修改版本号方法的一种简化。 视频中由于如果设置库存和之前查到的库存一样的话会导致成功率比较低,所以将库存判断条件设置成大于0即可.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527144654271.png" alt="image-20240527144654271" style="zoom:50%;" /><p>优缺点：悲观锁：添加同步锁，让线程串行执行    优点：简单粗暴  缺点：性能一般</p><p>​               乐观锁：不加锁，在更新时判断是否有其他线程在修改   优点：性能好    缺点：存在成功率低的问题</p><h4 id="案例：实现优惠券一人一单"><a href="#案例：实现优惠券一人一单" class="headerlink" title="案例：实现优惠券一人一单"></a><strong>案例：实现优惠券一人一单</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240527155049805.png" alt="image-20240527155049805" style="zoom: 67%;" /><p>根据优惠券id和用户id查询订单,看在数据库中是否存在,不存在的话才允许去扣减库存</p><p>这部分有点难,不会.</p><h4 id="集群下的线程并发问题"><a href="#集群下的线程并发问题" class="headerlink" title="集群下的线程并发问题"></a>集群下的线程并发问题</h4><p>我们通过加锁可以解决在单机下的一人一单安全问题,但是在集群模式下就不行了.</p><p>1.将服务启动两份,搭建集群.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528091500398.png" alt="image-20240528091500398"> </p><p>2.修改n ginx的conf目录下的nginx.conf文件,配置反向代理和负载均衡.</p><p>负载均衡可以理解为一种算法来平衡多台服务器让他们根据权重来分担访问量.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528102430589.png" alt="image-20240528102430589"></p><p>在集群模式下,我们部署了多个tomcat,有多个jvm的存在,每个jvm内部都有自己的锁,导致每个锁都有一个线程获取,于是出现了并行问题,可能出现安全问题.</p><p>要解决这个问题,就是让多个jvm只能使用同一把锁.</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h4><p>原理就是一定要让让多个jvm进程看到同一个锁监视器,也就是多进程可见,能时间互斥,也就是只有一个线程能拿到锁.</p><p><strong>满足分布式系统或集群模式下多进程可见并且互斥的锁</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528104224700.png" alt="image-20240528104224700"></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240429201918696.png" alt="image-20240429201918696" style="zoom: 50%;" /> <p>1.MySQL:mysql本身带有锁机制,但是mysql性能能一般,所以作为分布式锁的情况比较少见</p><p>2.redis:作为分布式锁是非常常见的一种使用方式,现在企业级开发中基本都使用redis或者zookeeper作为分布式锁,利用setnx方法,插入key成功,则表示获取了锁,有人插入成功则其他人无法插入,利用这套逻辑来实现分布式锁.</p><p>3.Zookeeper</p><p>  <strong>实现分布式锁时需要实现的两个基本方法:</strong></p><p><strong>1.获取锁</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528172858646.png" alt="image-20240528172858646"> </p><p>​    互斥:确保只能有一个线程获取锁</p><p>非阻塞:尝试一次,成功返回true,失败返回false</p><p>SET lock thread1 NX EX 10   添加锁,NX是互斥 ,EX是设置超时时间</p><p><strong>2.释放锁</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528173012343.png" alt="image-20240528173012343"> </p><p>​    手动释放</p><p>​    超时释放:获取锁时添加一个超时时间</p><p>​    DEL key  #释放锁,删除即可</p><h5 id="实现分布式锁的流程"><a href="#实现分布式锁的流程" class="headerlink" title="实现分布式锁的流程:"></a><strong>实现分布式锁的流程:</strong></h5><p>​         <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240503140136536.png" alt="image-20240503140136536" style="zoom:50%;" /></p><h5 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a><strong>改进Redis的分布式锁</strong></h5><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240528221735506.png" alt="image-20240528221735506" style="zoom: 67%;" /> <p>1.在获取锁时存入线程标识(可以用UUID标识)</p><p>2.在释放锁时先获取锁中的线程标识,判断是否与当前线程标识一致</p><p>  如果一致则释放锁</p><p>如果不一致则不释放锁</p><p><strong>分布式锁的原子性问题</strong>:</p><p>更为极端的误删逻辑说明：</p><p>线程 1 现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程 2 进来，但是线程 1 他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程 1 的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653387764938.png" alt="1653387764938"></p><p>redis中也是有事务存在的,但是只能保证事务的原子性,但不能保证一致性,事务中的多个操作其实是个批处理,在最终是一次性执行.</p><p>分布式锁的原子性问题,我们可以通过Redis的Lua脚本去解决.</p><h5 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a><strong>Redis的Lua脚本</strong></h5><p>Redis提供了Lua脚本功能, 在一个脚本中编写多条Redis命令,确保多条命令执行时的原子性.lua是一种编程语言.</p><p>lua脚本在Redis中是原子性执行的，即使是 由多个命令组成的脚本，Redis会将其作为一个整体在执行，不会被其他客户端的操作打断，从而确保了操作的原子性。</p><p><strong>总结：</strong></p><p><strong>基于Redis的分布式锁实现思路：</strong></p><p>利用set nx ex 获取锁，并设置过期时间，保存线程标识</p><p>释放锁时先判断线程标识是否与自己一致，一致的话则删除锁</p><p><strong>特性：</strong></p><p>利用set nx满足互斥性</p><p>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</p><p>利用Redis集群保证高可用性和高并发特性。</p><p><strong>基于Redis实现的分布式锁存在下面的问题：</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529150416949.png" alt="image-20240529150416949"></p><p>1.不可重入：同一个线程无法多次获取同一把锁</p><p>​                   可重入锁的意义就在于防止死锁。</p><p>2.不可重试：获取锁只尝试一次就返回false，没有重试机制</p><p>3.超时释放：锁超时释放虽然可以避免死锁，但是如果是业务执行耗时较长，也会导致锁释放，存在安全隐患。</p><p>4.主从一致：如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而如果在同步数据之前，主机宕机了，就会出现死锁问题。</p><h5 id="Redisson入门"><a href="#Redisson入门" class="headerlink" title="Redisson入门"></a><strong>Redisson</strong>入门</h5><p>是一个在Redis基础上实现的分布式工具的集合。它不仅提供了一系列的分布式的java常用对象,还提供了许多分布式服务,其中就包含了各种分布式锁的实现.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529101602200.png" alt="image-20240529101602200" style="zoom:50%;" /> <p><strong>入门步骤</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240504185248776.png" alt="image-20240504185248776" style="zoom:67%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240504185308624.png" alt="image-20240504185308624" style="zoom:67%;" /> <p><strong>Redisson可重入锁原理：</strong></p><p><strong>可重入锁</strong>：以前的锁是不可重入的，当一个线程中去调用多把锁的时候，就会出现第一把锁获取成功，其他锁获取失败的情况。</p><p>为了解决锁的可重入性质，将以前的key值为lock，value属性只有线程自己的id，改为使用<strong>hashmap存储</strong>，存储当前线程的id和线程获取锁的次数。</p><p>调用锁的时候，判断是不是自己的锁，是的话，次数加1，不是的话，次数减1，当统计数为0的时候，再释放锁。</p><p><strong>可重试：</strong>利用信号量和PubSub功能实现等待、唤醒、获取锁失败的重试机制。</p><p><strong>超时续约：</strong>利用watchDog（看门狗），每隔一段时间，重置超时时间。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529143758001.png" alt="image-20240529143758001"></p><p><strong>使用lua脚本来进行实现：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529144226476.png" alt="image-20240529144226476" style="zoom:67%;" />   <p><strong>分布式锁redission重试和看门狗机制</strong>、</p><p>1.重试机制：</p><p>在使用Redisson实现分布式锁时，为了应对网络异常、Redis服务器故障等情况，通常会配置重试机制。重试机制可以在获取锁失败后自动进行多次重试，直到获取锁成功或达到最大重试次数为止。</p><p>Redisson的重试机制是通过循环调用Redis 的SETNX命令来实现的。当某个节点在获取锁时失败后，会在指定的时间间隔内进行重试，直到获取锁成功或者超过最大重试次数。</p><p>2.看门狗机制</p><p>看门狗机制是用于防止锁持有者在执行业务逻辑时出现异常，导致锁没有被释放而造成死锁的情况。看门狗机制会在获取锁成功后启动一个定时任务，定时更新锁的过期时间。如果锁持有者因为异常或其他原因未能及时释放锁，锁的过期时间就会被更新，确保锁在一定时间内仍然有效，避免死锁情况的发生。</p><p>在redisson中，看门狗机制是通过redis的PEXPIRE（设置过期时间，带毫秒单位）命令实现的。当获取锁成功后，会启动一个定时任务定时更新锁的过期时间，保持锁的有效性。</p><p>综上所述，重试机制和看门狗机制是 Redisson 保证分布式锁可靠性和稳定性的重要机制。重试机制用于处理获取锁失败的情况，而看门狗机制用于防止锁的持有者出现异常导致锁未被释放而造成死锁的情况。这两种机制结合起来，可以有效地确保分布式锁的正确使用。</p><p><strong>Redisson分布式锁主从一致性</strong></p><p>redisson中的multiLock： </p><p>原理：利用多个独立的Redis节点，节点之间没有主从关系，就不会因为主从一致而导致锁失效，必须在所有节点都获取重入锁，才能算获取成功。</p><p>可以看作多个可重入锁的集合。</p><p>缺点：运维成本高，实现复杂</p><p><strong>redis异步秒杀优化</strong>：</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529191332566.png" alt="image-20240529191332566"></p><p>·</p><p>是在lua脚本中实现对秒杀库存和一人一单的判断。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240529192214577.png" alt="image-20240529192214577" style="zoom:67%;" /><p>在tomcat中执行右半部分</p><p><strong>秒杀业务的优化思路是什么？</strong></p><p>1先利用Redis完成库存余量、一人一单判断，完成抢单业务</p><p>2.再将下单业务放入阻塞队列，利用独立线程异步下单</p><p><strong>基于阻塞队列的异步秒杀存在哪些问题</strong>？（可以通过消息队列来实现）</p><p>1.内存限制问题（高并发情况下，大量订单创建，可能超出内存上限）</p><p>2.数据安全问题（jvm内存没有持久化机制的，每当服务重启或者宕机的时候，阻塞队列中的所有订单任务都会丢失）</p><p>消息队列是在jvm以外的独立服务，不受jvm内存的限制，所以解决了我们第一个问题。</p><p>消息队列不仅仅做数据存储，存进消息队列中的所有消息要做持久化，不管是服务宕机还是重启数据都不会丢失。而且再将消息发送给消费者后，要求消费者进行确认，如果没有确认的话，消息会在消息队列中一直存在，下次一次会把消息继续投递给消费者，直到成功为止。确保消息至少被消费一次。</p><h4 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530100827650.png" alt="image-20240530100827650"></p><p>消息队列就是存放消息的队列.最简单的消息队列模型包括三个角色:</p><p>1.消息队列:存储和管理,也被称为<strong>消息代理</strong></p><p>2.生产者:发送消息到消息队列</p><p>3.消费者:从消息队列获取消息并处理消息</p><p>Redis提供了三种不同的方式来实现消息队列:</p><p>1.list结构:基于List结构模拟消息队列</p><p>2.PubSub:基本的点对点消息模型</p><p>3.Stream:比较完善的消息队列模型</p><p><strong>基于List结构模拟消息队列</strong></p><p>Redis的list数据结构是一个双向链表,很容易模拟出队列效果.</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH结合RPOP、或者RPUSH结合LPOP来实现。</p><p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息，因此我们这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240505010343935.png" alt="image-20240505010343935"></p><p>基于List的消息队列有哪些优缺点：</p><p>优点：</p><p>利用Redis存储，不受限于JVM内存上限</p><p>基于Redis的持久化机制，数据安全性有保证</p><p>可以满足消息有序性</p><p>缺点：</p><p>无法避免消息丢失</p><p>只支持单消费者：一旦有一个人将消息拿走，那么消息就从队列中消除。</p><p><strong>基于PubSub的消息队列</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530110745651.png" alt="image-20240530110745651" style="zoom:50%;" /><p>pubSub(发布订阅)是Redis2.0版本引入的消息传递模型，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>SUBSCRIBE channel[channel]:订阅一个或多个频道</p><p>PUBLISH channel msg：向一个频道发送消息</p><p>PSUBSCRIBE pattern[pattern]:订阅与pattern格式匹配的所有频道</p><p>基于PubSub的消息队列有哪些优缺点：</p><p>优点：采用发布订阅模型，支持多生产、多消费</p><p>缺点：</p><p>不支持数据持久化</p><p>无法避免消息丢失</p><p>消息堆积有上限，超出时数据丢失</p><h4 id="基于Stream的消息队列："><a href="#基于Stream的消息队列：" class="headerlink" title="基于Stream的消息队列："></a><strong>基于Stream的消息队列</strong>：</h4><p>Stream 时Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p><strong>STREAM类型消息队列的XREAD命令特点：</strong></p><p>消息可回溯</p><p>一个消息可以被多个消费者读取</p><p>可以阻塞读取</p><p>有消息漏读的风险</p><p><strong>STREAM类型消息队列的XREADGROUP命令特点：</strong></p><p>消息可回溯</p><p>可以多消费者争抢消息，加快消费速度</p><p>可以阻塞读取</p><p>没有消息漏读的风险</p><p>有消息确认机制，保证消息至少被消费一次</p><p><strong>Redis消息队列总结：</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240505153952670.png" alt="image-20240505153952670"></p><p>建议使用中间件RabbitMQ来解决，这边听不懂，直接作为项目上的难点，讲给面试官。</p><h4 id="4-达人探店"><a href="#4-达人探店" class="headerlink" title="4.达人探店"></a><strong>4.达人探店</strong></h4><h4 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a><strong>发布探店笔记</strong></h4><p>图文结合，对应有两张表：</p><p>tb_blog:探店笔记表，包含笔记中的标题、文字、图片等</p><p>tb_blog_comments:其他用户对探店笔记的评价</p><p>一共有两个接口，上传图片接口和发布接口</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530141252463.png" alt="image-20240530141252463"></p><p>需求：点击首页的探店笔记，会进入详情页面，实现该页面的查询接口：</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530144820719.png" alt="image-20240530144820719"> </p><p><strong>查看探店笔记</strong></p><h4 id="达人探店点赞功能"><a href="#达人探店点赞功能" class="headerlink" title="达人探店点赞功能"></a><strong>达人探店点赞功能</strong></h4><p>需求:完善点赞功能</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240506090612387.png" alt="image-20240506090612387"></p><p>核心就是判断用户是否点赞过:</p><p>思路:用一个set集合去存储已经点赞的用户列表</p><p>我们先去Redis中查询</p><p>如果查询不到,数据库点赞+1,并保存用户到Redis</p><p>如果查询到了,数据库点赞-1,并删除Redis中set保存的用户</p><h4 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a><strong>点赞排行榜</strong></h4><p>在探店笔记的详情页面,应该把给该笔记点赞的人显示出来,比如最早点赞的Top5,形成点赞排行榜</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240530202645975.png" alt="image-20240530202645975"></p><p> 之前的点赞是放在set集合中的,但是set集合是不能排序的,所以我们采用sortedSet集合</p><p>步骤:使用sortedSet代替Set集合,按照保存时间的毫秒值,获取排名前五的用户</p><h3 id="5-好友关注"><a href="#5-好友关注" class="headerlink" title="5.好友关注"></a>5.好友关注</h3><h4 id="1-关注和取关"><a href="#1-关注和取关" class="headerlink" title="1.关注和取关"></a>1.关注和取关</h4><p>基于该表结构实现两个接口：</p><p>关注和取关接口</p><p>判断关注的接口</p><p>需要一张中间表来记录，关注是User之间的关系，是博主与粉丝的关系，是<strong>多对多</strong>的关系，数据库中有一张表，tb_follow表示。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240602205614937.png" alt="image-20240602205614937"> </p><p>思路： </p><p>判断是关注还是未关注，关注的话就定义对象，存到表里面，未关注的话就删除表中数据。</p><p>是否关注用户？：如果在表中查到数据，则说明关注了</p><h4 id="2-共同关注"><a href="#2-共同关注" class="headerlink" title="2.共同关注"></a>2.共同关注</h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603094019369.png" alt="image-20240603094019369"></p><p>上图是实现查询用户详情和查询用户笔记的接口</p><p><strong>共同关注的实现:</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603103054668.png" alt="image-20240603103054668" style="zoom:50%;" /><p><strong>思路</strong>:在关注的时候,放入数据库的同时,指定key把当前id的关注列表以set的形式放入redis中</p><p>取消关注的时候,删除数据库的数据,并删除redis中数据</p><p>最后用set集合求交集的方法,就可以查看到共同关注</p><p>查看到的数据为string类型,要转化为Long类型.</p><h4 id="3-关注推送"><a href="#3-关注推送" class="headerlink" title="3.关注推送"></a>3.关注推送</h4><p>关注推送也叫Feed流,通过无线下拉刷新获取新的信息.</p><p>Feed流产品有两种常见模式:</p><p><strong>1.Timeline</strong>:不做内容筛选,简单的按照内容发布时间排序,常用于好友或关注.例如朋友圈</p><p>优点:信息全面,不会有缺失,并且实现也相对简单</p><p>缺点:信息噪音比较多,用户不一定感兴趣,内容获取效率低下</p><p><strong>2.智能排序</strong>:利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣信息来吸引用户。</p><p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷。</p><p>缺点：如果算法不精准，可能起到反作用。</p><p><strong>本案例中使用TimeLine的模式。该模式的实现方案有三种：</strong></p><p><strong>1.拉模式：</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603134043235.png" alt="image-20240603134043235"></p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在根据时间进行排序</p><p>优点：比较节约内存空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><strong>2.推模式：</strong></p><p>也叫写扩散</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603134659023.png" alt="image-20240603134659023"></p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大 V 写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><strong>3.推拉结合</strong></p><p>也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个<code>普通的人，那么我们采用写扩散的方式</code>，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，<code>如果是大V，那么他是直接将数据先写入到一份到发件箱里边去</code>，然后再直接写一份到<code>活跃粉丝</code>收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大 V 和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603141011200.png" alt="image-20240603141011200"></p><p><strong>Feed流的实现方案：</strong></p><p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603141143759.png" alt="image-20240603141143759"></p><p><strong>基于推模式实现关注推送功能：</strong></p><p>需求：</p><p>1.修改新增探店笔记的内容，在保存blog到数据库的同时，推送到粉丝的收件箱</p><p>2.收件箱满足可以根据时间戳排序，必须用redis的数据结构实现</p><p>3.查询收件箱数据时，可以实现分页查询。</p><p><strong>Feed流的滚动分页</strong>：</p><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603145025100.png" alt="image-20240603145025100" style="zoom:67%;" /><p>我们采用sortedSet来做，可以进行范围查询，并且还可以记录获取数据时间戳的最小值，就可以实现滚动分页了。</p><p>我们在保存完探店笔记后，获得该用户的粉丝，然后把数据推送到粉丝的redis中去。</p><p><strong>实现关注推送页面的分页查询</strong>：</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603160546754.png" alt="image-20240603160546754"></p><p>需求：在个人主页的 “关注” 卡片中，查询并展示推送的 Blog 信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><h3 id="6-附近商户"><a href="#6-附近商户" class="headerlink" title="6.附近商户"></a>6.附近商户</h3><p>1.GEO数据结构</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603185354047.png" alt="image-20240603185354047"></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240603214304903.png" alt="image-20240603214304903"></p><p>我们需要将数据库表中的数据导入到Redis中GEO中去，我们需要把商铺的经纬度和id存进去，但是不能把所有的数据都传进去，因为redis是一个基于内存的数据库，存太多数据会占用很高的内存空间。</p><p>但是这个时候还有一个问题，就是在 redis 中并没有存储 type，所以我们无法根据 type 来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以 typeId 为 key 存入同一个 GEO 集合中即可。</p><p>下图是将数据存入到GEO中</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604091821489.png" alt="image-20240604091821489"></p><p><strong>难点：</strong>不是每次都与 Redis 链接，去插入数据，而是把数据封装成 List&lt;RedisGeoCommands.GeoLocation&gt; 集合，一次插入，减小与 Redis 链接的次数，提升效率</p><h4 id="实现附近商户功能"><a href="#实现附近商户功能" class="headerlink" title="实现附近商户功能"></a><strong>实现附近商户功能</strong></h4><p>都是代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过 opsForGeo() 方法获取了 Redis 的 Geo 操作对象。</span><br><span class="line">调用 search() 方法执行地理位置的搜索操作。</span><br><span class="line">search() 方法接收了一系列参数：</span><br><span class="line">key：指定了要搜索的 GeoKey（地理位置的键）。</span><br><span class="line">GeoReference.fromCoordinate(x, y)：指定了搜索的中心坐标，其中 x 和 y 分别表示了经度和纬度。</span><br><span class="line">new Distance(5000)：指定了搜索的半径范围，这里设置为 5000 米。</span><br><span class="line">RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)：这是可选的参数，用于配置搜索的行为。includeDistance() 表示在搜索结果中包含距离信息，limit(end) 表示限制搜索结果的数量为 end。</span><br></pre></td></tr></table></figure><h3 id="7-用户签到"><a href="#7-用户签到" class="headerlink" title="7.用户签到"></a><strong>7.用户签到</strong></h3><p><strong>7.1BitMap用法</strong></p><p>我们可以使用数据库表来实现签到功能</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604104145026.png" alt="image-20240604104145026" style="zoom:80%;" /> <p>用户签到一次，就是一条记录，假如有1000万用户的话，平均每人每年签到十次的话，则这张表一年的数据量为1亿条。</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共 22 字节的内存，一个月则需要 600 多字节</p><p>我们可以采用以下方案来解决：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604104556560.png" alt="image-20240604104556560" style="zoom:67%;" /> <p>我们按月来统计用户签到信息，签到记录为 1，未签到则记录为 0.</p><p>把每一个 bit 位对应当月的每一天，形成了映射关系。用 0 和 1 标示业务状态，这种思路就称为<strong>位图</strong>（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis 中是利用 string 类型数据结构实现 **<code>BitMap</code>**，因此最大上限是 512M，转换为 bit 则是 2^32 个 bit 位。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604105232842.png" alt="image-20240604105232842" style="zoom: 67%;" /> <p><strong>7.2签到功能</strong></p><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604111733932.png" alt="image-20240604111733932" style="zoom:67%;" /> <p>思路：我们可以把年和月作为 bitMap 的 key，然后保存到一个 bitMap 中，每次签到就到对应的位上把数字从 0 变成 1，只要对应是 1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改 bitMap。</p><p><strong>7.3签到统计</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604141711486.png" alt="image-20240604141711486" style="zoom:67%;" /> <p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604142014927.png" alt="image-20240604142014927" style="zoom: 80%;" /> <h3 id="8-UV统计"><a href="#8-UV统计" class="headerlink" title="8.UV统计"></a>8.UV统计</h3><p><strong>1.HyperLogLog用法</strong></p><p>UV:也叫独立访客量,是指通过互联网访问、浏览这个网页的自然人。一天内同一个用户多次访问该网站，只记录一次。</p><p>PV：也叫页面访问量或点击量，用户每访问网站的一个页面，记录一次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</p><p>uv统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存在redis中，数据量会非常恐怖。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604160129918.png" alt="image-20240604160129918"></p><p><strong>2.实现UV统计</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604160936759.png" alt="image-20240604160936759"></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240604161825611.png" alt="image-20240604161825611"></p><p>1000000 存入 997593，误差率约为 0.2%.</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h1 id="消息队列rabbitmq"><a href="#消息队列rabbitmq" class="headerlink" title="消息队列rabbitmq"></a>消息队列rabbitmq</h1><p>概念：是一种用于在应用程序之间传递消息的通信方式，消息队列允许应用程序异步地发送和接受消息，并且不需要直接连到对方。</p><p>应用场景：</p><p>1.应用的解耦</p><p>2.异步发送消息</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240718161836639.png" alt="image-20240718161836639" style="zoom:50%;" /> <ol start="3"><li>流量削峰（一般在秒杀场景下）</li></ol><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240718162908841.png" alt="image-20240718162908841" style="zoom:50%;" /> <p>消息队列缺点？</p><p>如何保证消息没有被重复消费？</p><p>如何处理消息丢失的情况？</p><p>如何保证消息传递的顺序性？</p><p>如何保证数据一致性问题？</p><p>RabbitMq四大核心：</p><p>生产者  消费者 队列 交换机 </p><p>生产者发送消息，消息先到达交换机，交换机根据相应的配置将消息路由到相应的队列中。</p><p>发布订阅模式publish&#x2F;subscribe：</p><p>消费者订阅指定的队列，有消息时Fanout Exchange会发布到所有的队列中，这样订阅的消费者就都能收到消息了。</p><p>如工作原理如下图所示。因为Fanout交换机，会将所有消息转发到所有绑定的队列上，所以也不用指定routingKey了</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240718173933475.png" alt="image-20240718173933475"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-NFT/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-NFT/</url>
      
        <content type="html"><![CDATA[<h1 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h1><h4 id="项目模块功能"><a href="#项目模块功能" class="headerlink" title="项目模块功能"></a>项目模块功能</h4><img src="https://tcs-devops.aliyuncs.com/storage/113815f78b0b2d738eed7811fb68df12cd02?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjVlNzQ4MmQ2MjE1MjJiZDVjN2Y5YjMzNSIsIl9hcHBJZCI6IjVlNzQ4MmQ2MjE1MjJiZDVjN2Y5YjMzNSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTcyMjI1MjU2NCwiaWF0IjoxNzIxNjQ3NzY0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzExMzgxNWY3OGIwYjJkNzM4ZWVkNzgxMWZiNjhkZjEyY2QwMiJ9.D5VPnuKSgzoLYX2iJJrfbJbzauov2rRiHpVqRU5l7Rs" alt="img" style="zoom: 80%;" /> <p>背景：nft也叫非同质化代币或数字权益证明，可以理解成你的数字化的房产证，这个证明用区块链技术去保存，最大的特点就是永远不会被篡改，全网唯一的认证，所有的交易有迹可查。</p><h2 id="统一认证设计"><a href="#统一认证设计" class="headerlink" title="统一认证设计"></a>统一认证设计</h2><p>因为我们的项目是一个分布式的项目，每一个模块都需要去判断是不是用户已经登录了，查看的信息是不是属于这个用户的，为了方便，我们做了统一的认证，也就是说可以在一个地方做认证。只在auth这个模块做认证</p><p><strong>认证流程：</strong></p><p>用户在浏览器中发起请求，如果发现未登录的话，转到登录界面。校验手机号和验证码没问题之后，sa_token框架把用户的登录态保存到redis当中，再把框架生成的token返回到浏览器，浏览器再把token保存下来（保存到cookie中或者保存到Localstorage中）。在下一次访问其他页面的时候会把这个token带着，做一个拦截器，然后在后端通过satoken进行登录校验获取登录的信息。</p><p>sa_token框架中stputil.login()将 生成的token作为key，用户的id作为value存储到redis中去。</p><p>通过redis实现了这样的一个分布式的session。</p><p>sa-token是java中一个权限认证的框架，做登录、鉴权、认证的</p><h2 id="用户模块的权限设置"><a href="#用户模块的权限设置" class="headerlink" title="用户模块的权限设置"></a>用户模块的权限设置</h2><p>通过sa-token框架进行权限管理配置</p><p>针对不同身份的用户去配置和开放对应的地址。</p><p><strong>实现的流程：</strong></p><p>用户登录的时候在controller中把用户信息存到session当中，然后用户访问的时候，去stpinterfaceimpl中获取用户的角色和权限的列表，用户在真正访问某个路径的时候 ，去判断用户是否拥有对应的角色和权限，如果有的话直接放行，没有的话拦截请求并返回错误信息。</p><p><strong>用户信息的脱敏</strong>：</p><p>选择sensitive-logback脱敏框架，两个功能 ：将数据返回给前端的时候进行数据脱敏，将日志打印的时候数据脱敏。</p><h2 id="藏品模块"><a href="#藏品模块" class="headerlink" title="藏品模块"></a>藏品模块</h2><p>藏品基于数据库的查询</p><p>藏品的库存设计：下单时候预扣减库存，然后创建订单付款，支付完成之后真正扣减库存。</p><p>好处：不会出现超卖问题    库存的更新比较实时    大大的提高并发的性能</p><h1 id="用户邀请与排行榜："><a href="#用户邀请与排行榜：" class="headerlink" title="用户邀请与排行榜："></a>用户邀请与排行榜：</h1><p>实现逻辑：</p><p>1.用户在注册的时候生成一个唯一的邀请码：生成随机数 ，然后到布隆过滤器里面去判重</p><p>2.用户在注册的时候可以填写邀请码，可以查询到是谁邀请了我，保存邀请人的用户id</p><p>3.排名 放到redis中的zset中，value为用户id score为邀请的分数，每邀请一个人给一个用户加100分</p><p>限流器和分布式锁使用redisson（与redis交互的java客户端）</p><p>Caffeine(本地缓存)+Redis实现二级缓存</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>分布式和微服务的区别？</p><p>分散压力和分散能力</p><p>微服务：系统架构的一个设计方式，将复杂的业务拆分成多个微小的服务，让这些服务可以单独去运行和部署，服务与服务之间采用rpc来通信</p><p>分布式：系统的部署方式将同一个服务可以部署到多台机器，分摊单台机器的负载压力，一般采用集群和主备方式进行一个部署。</p><p>分开部署体现在两个方面，把一个项目完整的复制一份部署到另一台发服务器上我们也称之为集群，集群也可以理解成是分布式架构。</p><p>​                    还有一种是把项目的部分子模块单独部署在一台服务器上，把另一部分子模块部署在另一台服务器上</p><p>分布式部署不一定是微服务架构，微服务也不一定采用分布式部署。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-MySQL/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>数据库:DataBase(DB),是存储和管理数据的仓库</p><p>数据库管理系统:操纵和管理数据库的大型软件</p><p>SQL: Structured Query Language操作关系型数据库的编程语言,定义了一套操作关系型数据库统一标准</p><p>语法:</p><p>mysql -u用户名 -p密码 [ -h数据库服务器ip地址 -P端口号]</p><h4 id="MySQL数据模型"><a href="#MySQL数据模型" class="headerlink" title="MySQL数据模型"></a><strong>MySQL数据模型</strong></h4><p><strong>关系型数据库:建立在关系模型基础上,由多张相互连接的二维表组成的数据库</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311210606679.png" alt="image-20240311210606679"></p><h4 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a><strong>SQL通用语法</strong></h4><p>1.SQL语句可以单行或者多行，以分号结尾</p><p>2.SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</p><p>3.MySQL数据库的SQL语句不分大小写</p><p>4.注释：单行注释 –注释内容或者#注释内容（MySQL特有） 多行注释：&#x2F;* 注释内容 *&#x2F;</p><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><strong>SQL分类</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311212651840.png" alt="image-20240311212651840" style="zoom:67%;" /> <h4 id="开发项目流程"><a href="#开发项目流程" class="headerlink" title="开发项目流程"></a><strong>开发项目流程</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311213255232.png" alt="image-20240311213255232" style="zoom: 67%;" /> <h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a><strong>DDL</strong></h3><p>database 可以替换成 schema</p><p>全称 data definition language ，数据定义语言，用来定义数据库对象（数据库、表）</p><p><strong>数据库操作：</strong></p><p><strong>查询：</strong>所有数据库：show databases；   查询当前数据库：select database（）；</p><p><strong>使用</strong>:使用数据据库： use  数据库名；</p><p><strong>创建数据库：</strong> create database[if not exists] 数据库名</p><p><strong>删除</strong>：删除数据库 ： drop database [if exists] 数据库名；</p><h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a><strong>数据库连接</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240318221049115.png" alt="image-20240318221049115" style="zoom:67%;" /> <p>[]代表可写可不写,如果写的话不需要加[],直接写在后面即可</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312095612268.png" alt="image-20240312095612268" style="zoom:67%;" /> <h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h4><p>MySQL中的数据类型有很多，主要分为三类：    <strong>数值类型、字符串类型、日期时间类型</strong></p><p><strong>数值类型：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312105250674.png" alt="image-20240312105250674" style="zoom: 67%;" /> <p><strong>字符串类型：</strong> </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312105317413.png" alt="image-20240312105317413" style="zoom: 67%;" /> <p><strong>日期时间类型</strong>：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312105448980.png" alt="image-20240312105448980" style="zoom: 200%;" /><p><strong>char()和varchar()区别:</strong></p><p>char 是定长字符串,varchar是变长字符串</p><p><strong>char(10)和varchar(10):</strong></p><p>char(10)最多只能存10个字符,不足十个字符,占用十个字符空间   性能高   浪费空间</p><p>varchar(10)最多只能存十个字符,不足十个字符,按照实际长度存储   性能低   节省空间</p><h4 id="DDL-表操作-了解即可"><a href="#DDL-表操作-了解即可" class="headerlink" title="DDL(表操作)    了解即可"></a><strong>DDL(表操作)</strong>    了解即可</h4><p> **图形化界面对表操作 **                    <strong>已经被图形化界面工具给取代</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312145641981.png" alt="image-20240312145641981" style="zoom:67%;" /> <h3 id="DML-重点"><a href="#DML-重点" class="headerlink" title="DML 重点"></a>DML 重点</h3><p>DML全称是data manipulation language（数据操作语言），用来对数据库中表的数据记录进行增、删、改操作。</p><p>添加数据：<strong>insert</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312154404169.png" alt="image-20240312154404169" style="zoom:50%;" /> <p>修改数据：<strong>update</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312155645968.png" alt="image-20240312155645968" style="zoom:50%;" /> <p>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据</p><p>删除数据：<strong>delete</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312160912838.png" alt="image-20240312160912838" style="zoom:50%;" /> <p><strong>DML总结:</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521093534864.png" alt="image-20240521093534864" style="zoom:50%;" /> <h3 id="DQL-重点"><a href="#DQL-重点" class="headerlink" title="DQL   重点!"></a><strong>DQL</strong>   重点!</h3><p>DQL英文全称是 data query language（数据查询语言），用来查询数据库表中的记录</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240319163737543.png" alt="image-20240319163737543" style="zoom:50%;" /> <p><strong>关键词：select</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312164327980.png" alt="image-20240312164327980" style="zoom: 67%;" /> <p>  <strong>条件查询</strong>   where</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312184918821.png" alt="image-20240312184918821" style="zoom:50%;" /><p><strong>in</strong>表示只要满足条件中的一个即可    是来简化or 条件   例如查询年龄等于18或20或40的员工信息</p><p>select *from emp  where  age in(18,20,40);</p><p><strong>like模糊匹配</strong>    例如查询姓名为两个字的员工信息  select * from  emp where like ‘ _ _’; 如果三个字那么就三个下划线.</p><p>查询身份证号最后一位是x的员工信息</p><p>select *from emp where  idcard like ‘%x’;    ‘’%x’表示不管前面是什么最后一位是x.</p><p><strong>聚合函数</strong>              </p><p>将一列数据作为一个整体作为纵向计算</p><p>所有的null值是不参与聚合函数的计算的</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313103932816.png" alt="image-20240313103932816"></p><p>**分组查询  ** group by    一般配合聚合函数来操作</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313111110585.png" alt="image-20240313111110585"></p><p> 例:</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617160343869.png" alt="image-20240617160343869"></p><p><strong>面试题</strong></p><p>where和having区别</p><p>1.执行时机不同**:where是分组之前进行过滤**,不满足where条件,不参与分组,<strong>而having是分组之后对结果进行过滤</strong></p><p>2.判断条件不同**:where不能对聚合函数进行判断,而having可以** </p><p><strong>注意事项</strong>:</p><p><strong>分组之后,查询的字段一般为聚合函数的分组字段,查询其他字段无任何意义</strong></p><p>执行顺序:where&gt;聚合函数&gt;having</p><p><strong>排序查询</strong>     order by</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313123914663.png" alt="image-20240313123914663"></p><p><strong>注意事项</strong>:如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序</p><p><strong>分页查询</strong>  limit</p><p>*<em>起始索引&#x3D;(页码-1)<em>每页展示记录数.</em></em></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313125734430.png" alt="image-20240313125734430" style="zoom: 67%;" /><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313142530668.png" alt="image-20240313142530668"></p><p><strong>DQL执行顺序:</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617181346048.png" alt="image-20240617181346048"></p><h1 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h1><p><strong>外键:</strong></p><p>让两张表的数据之间建立连接,从而保证数据的一致性和完整性.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617201943093.png" alt="image-20240617201943093"></p><p>dept_id字段就是外键,关联的是部门表的主键.  有外键的表就叫子表,关联的主键所在的表叫父表,有时也叫主表和从表.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313162223646.png" alt="image-20240313162223646" style="zoom: 67%;" />   <p><strong>外键约束一般不用物理外键,用逻辑外键</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521150344851.png" alt="image-20240521150344851" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521150635871.png" alt="image-20240521150635871" style="zoom:50%;" /></p><p><strong>一对一</strong></p><p>实现:在任意一方加入外键,关联另一方的主键,并且设置外键为唯一的unique</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617210946723.png" alt="image-20240617210946723"></p><p><strong>一对多</strong></p><p>一对多的实现:在数据库表中多的一方,添加字段,来关联一的一方的主键</p><p><strong>多对多</strong></p><p>建立第三张中间表,中间表至少包含两个外键,分别关联两方主键.</p><p>通过中间表来维护,中间表的两个外键,分别关联另外两张表的主键</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h3><p>从多张表中查询数据</p><p>笛卡尔积:笛卡尔乘积是指在数学中,两个集合(A集合和B集合)的所有组合情况</p><p>在多表查询的时候需要消除无效的笛卡尔积.</p><p><strong>连接查询:</strong></p><p>内连接:相当于查询A、B交集部分数据</p><p>外连接：</p><p>左外连接：查询<strong>左表</strong>所有的数据（包括两张表交集部分数据）</p><p>右外连接：查询<strong>右表</strong>所有数据（包括两张表交集部分数据）</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521163324104.png" alt="image-20240521163324104" style="zoom:50%;" /> <p><strong>内连接</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314135356867.png" alt="image-20240314135356867" style="zoom: 67%;" /> <p><strong>外连接</strong></p><p>一般都是用左外连接，因为右外连接可以被左外连接替换。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314142321882.png" alt="image-20240314142321882" style="zoom:67%;" /> <p>on 后面是连接条件，where后面是查询条件 ， on后面有时候会再用where</p><p><strong>联合查询-union,unionall</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617215434335.png" alt="image-20240617215434335"></p><p><strong>对于联合查询的多张表的列数必须保持一致,字段类型也需要保持一致.</strong> </p><p>就是把多次查询的结果合并起来,形成一个新的查询结果集.</p><p>union直接将查询的结果合并且<strong>去重</strong>展示出来.</p><p>union  all 直接将查询的结果合并  并不去重. </p><p><strong>子查询</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314143903755.png" alt="image-20240314143903755" style="zoom:67%;" /> <p>根据子查询的位置可以分为:where 之后,from之后,select 之后</p><p><strong>标量子查询:</strong></p><p>子查询返回的结果是单个值(数字,字符串,日期等),这种子查询称为标量子查询.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617220208150.png" alt="image-20240617220208150" style="zoom:80%;" /> <p>合在一起:</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617220303740.png" alt="image-20240617220303740">  </p><p><strong>列子查询</strong></p><p>子查询的返回的结果是一列,但可以是多行,这种子查询称为列子查询.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240617221631503.png" alt="image-20240617221631503"></p><p> <strong>行子查询</strong></p><p>子查询返回的结果是一行,可以是多列,这种子查询称为行子查询,</p><p>常用的操作符:&#x3D;、&lt;&gt;、in、not in</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务</strong>是一组操作的集合,它是一个不可分割的工作单位.事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求,<strong>即这些操作要么同时成功,要么同时失败</strong></p><p>例： 如果删除一个部门，那么该部门下的所有员工也应该被删除</p><p>注意:默认MySql的事务是自动提交的,当执行一条DML语句,MySQL会立即隐式的提交事务.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314160745314.png" alt="image-20240314160745314" style="zoom:67%;" /> <p><strong>开启事物，执行操作，如果全部执行成功，则提交事物，如果出现报错，则回滚。</strong></p><p>事务四大特性:</p><p>原子性:事务是不可分割的最小单元,要么全部成功,要么全部失败</p><p>一致性:事务完成时,必须使所有的数据都保持一致状态</p><p>隔离性:事务与事物之间是独立的，不会相互影响。</p><p>持久性:事务一旦提交或者回滚,他对数据库中的改变就是永久的</p><h3 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h3><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240618085758677.png" alt="image-20240618085758677"></p><p><strong>事务隔离级别：</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240618090037827.png" alt="image-20240618090037827"></p><hr><h1 id="事务进阶"><a href="#事务进阶" class="headerlink" title="事务进阶"></a><strong>事务进阶</strong></h1><p><strong>spring事务管理</strong></p><p>注解： @Transactional    &#x2F;&#x2F;spring事务管理</p><p>位置：业务（service）层的方法上、类上、接口上</p><p>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</p><p><strong>事务属性–回滚</strong></p><p>默认情况下，只有出现RuntimeException才回滚异常。rollbackfor属性用于控制出现何种异常类型，回滚事务。</p><p>@Transactional（rollbackFor&#x3D;Exception.class） 指定所有的异常都回滚。 </p><p><strong>事务属性–传播行为</strong></p><p>事务属性-传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制？</p><p>​                 REQUIRED:大部分情况下都是用该传播</p><p>​                 REQUIRES_NEW:当我们不希望事务之间相互影响时，可以用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415091907538.png" alt="image-20240415091907538" style="zoom:50%;" /> ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-MybatisPlus/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><p>1.只做增强不做改变，引入它不会对现有工程产生影响</p><p>2.只需要简单配置，即可快速进行单表CRUD操作，从而节省大量时间。</p><p>3.代码生成、自动分页、逻辑删除、自动填充 </p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p><strong>Mybatis的使用：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240416194543236.png" alt="image-20240416194543236" style="zoom:80%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240416194803930.png" alt="image-20240416194803930" style="zoom: 67%;" /> <p><strong>BaseMapper中定义好了大量的增删改查方法</strong> </p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p><strong>条件构造器</strong></p><p><strong>MyBatisPlus</strong>支持各种复杂的where条件，可以满足日常开发的所有需求。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417012503205.png" alt="image-20240417012503205" style="zoom:50%;" /> <p><strong>自定义SQL</strong></p><p>我们可以利用MP中的Wrapper来构建复杂的where条件，然后自己定义SQL语句中剩下的部分</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417092328359.png" alt="image-20240417092328359" style="zoom:50%;" /> <p><strong>Service接口</strong></p><p>MP的Service接口使用流程是怎么样的？</p><p>1.自定义Service接口继承IService接口，具备Iservice中所有方法了</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417102051070.png" alt="image-20240417102051070" style="zoom:67%;" /> <p>2.自定义Service实现类，实现自定义接口并继承ServiceImpl类</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417102408202.png" alt="image-20240417102408202" style="zoom: 50%;" /> <p><strong>批处理方案</strong>:</p><p>普通for循环逐条插入速度极差,不推荐</p><p>mp的批量新增,基于预编译的批处理,性能不错</p><p>配置jdbc参数,开rewriteBatchedStatements 性能最好</p><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p><strong>代码生成</strong></p><p><strong>静态工具</strong></p><p>在开发业务的时候,会出现一种场景,多个service之间会相互调用.传统的autuowired注入的方式</p><p>会出现循环依赖,可以使用<strong>Db</strong><em><strong>静态工具</strong></em>*调用</p><p><strong>逻辑删除</strong></p><p>就是基于代码逻辑模拟删除效果,但并不会真正删除数据例:</p><p>在表中添加一个字段标记数据是否被删除</p><p>当删除数据时标记为1</p><p>查询时只查询标记为0的数据</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417200430385.png" alt="image-20240417200430385" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417200937393.png" alt="image-20240417200937393" style="zoom:67%;" /> <p><strong>枚举处理器</strong></p><p><strong>如何实现po类中的枚举类型变量与数据库字段的转换?</strong></p><p>1.给枚举中的与数据库对应value值添加@EnumValue注解</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417203839143.png" alt="image-20240417203839143" style="zoom:80%;" /> <p>2.在配置文件中配置统一的枚举处理器,实现类型转换</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417203855220.png" alt="image-20240417203855220" style="zoom:67%;" /> <p><strong>json处理器</strong></p><p>解决枚举类型和数据库类型之间的相互转换</p><h4 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h4><p><strong>分页插件基本用法</strong></p><ol><li></li></ol><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240417210007002.png" alt="image-20240417210007002" style="zoom:50%;" /> <p>2.配置api实现分类</p><p><strong>通用分类实体</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-javaWeb/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-javaWeb/</url>
      
        <content type="html"><![CDATA[<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307203827938.png" alt="image-20240307203827938"  /> <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>是apacghe旗下的一个开源项目，是一款管理和构建Java项目的工具</p><p>作用:1.方便的依赖管理:方便快捷的管理项目依赖的资源jar包，避免版本冲突问题</p><p>​        2.提供统一的项目结构 </p><p>​        3.标准的项目构建流程    </p><p><strong>IDEA导入maven项目：</strong>1.在idea右侧maven面板，点击加号，选中对于项目的pom.xml文件即可。</p><p>​                                           2.idea 中file &gt; project structure&gt;  modules&gt;   加号&gt;import module &gt;选择对应项目的pom.xml文件</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240407192715171.png" alt="image-20240407192715171" style="zoom: 50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307212104280.png" alt="image-20240307212104280" style="zoom: 67%;" /><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240308101525302.png" alt="image-20240308101525302"></p><h2 id="依赖管理-maven中最核心的功能"><a href="#依赖管理-maven中最核心的功能" class="headerlink" title="依赖管理(maven中最核心的功能)"></a>依赖管理(maven中最核心的功能)</h2><h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a><strong>依赖配置</strong></h4><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240308160728701.png" alt="image-20240308160728701"></p><p><strong>如果引入的依赖,在本地仓库不存在,将会连接远程仓库(公司搭建的私服)&#x2F;中央仓库,然后下载依赖</strong></p><h4 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a><strong>依赖传递</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240308190620011.png" alt="image-20240308190620011" style="zoom: 67%;" />               <p><strong>排除依赖</strong></p><p>排除依赖指主动断开依赖的资源,被排除的资源无需指定版本     通过<exclusion></p><h4 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a><strong>依赖范围</strong></h4><p>通过<scope>设置其作用范围</p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240308200420500.png" alt="image-20240308200420500" style="zoom:50%;" />                          <h4 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240308210248061.png" alt="image-20240308210248061" style="zoom:50%;" />     <p>clean:移除上一次构建生成的文件<br>compile:编译项目源码</p><p>test:使用合适的单元测试框架运行测试(例如junit)</p><p>package:将编译后的文件打包,如jar、war等</p><p>install:将打包好的jar包或war包安装到本地仓库</p><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><h4 id="1-分模块设计与开发"><a href="#1-分模块设计与开发" class="headerlink" title="1.分模块设计与开发"></a>1.分模块设计与开发</h4><p>**分模块设计:**将项目按照功能拆分成若干个子模块,方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享</p><p><strong>分模块开发：</strong>视频案例中  创建maven模块<strong>tlias-pojo</strong>，存放<strong>实体类</strong>。 创建maven模块 tlias-utils，存放相关<strong>工具类</strong>。 <strong>注意事项：</strong></p><p>  <strong>分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后在进行拆分。</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415220017422.png" alt="image-20240415220017422" style="zoom:67%;" /><h4 id="2-继承和聚合："><a href="#2-继承和聚合：" class="headerlink" title="2.继承和聚合："></a>2.<strong>继承和聚合：</strong></h4><p><strong>继承：</strong></p><p><strong>继承</strong>描述的是两个工程之间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</p><p>作用：简化依赖配置、统一管理依赖</p><p>实现：<parent>….<parent>       父工程的坐标</p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415223710813.png" alt="image-20240415223710813" style="zoom: 67%;" /><p><strong>常见的打包方式</strong>：</p><p>jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</p><p>war：普通web程序打包，需要部署在外部的tomcat服务器中运行</p><p>pom：父工程或者聚合工程，该模块不写代码，仅进行依赖管理</p><p><strong>继承关系实现：</strong>1.创建maven模块tlias-parent，该工程为<strong>父工程</strong>，设置<strong>打包方式pom</strong>(默认jar)。</p><p>​                           2.<strong>子工程</strong>的pom.xml文件中，配置继承关系</p><p>​                           3.在<strong>父工程</strong>中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）</p><p><strong>版本锁定：</strong>在maven中，可以在父工程的pom文件中通过<dependencyManagement>来统一管理依赖版本。<strong>注意事项：</strong>子工程引入依赖时，无需指定<version>版本号，父工程统一管理。变更依赖版本，只需在父工程中统一变更。</p><p><strong>（面试题</strong>）**<dependencyMangement>与<dependencies>的区别是什么？**</p><p>1.<dependencies>是直接依赖，在父工程配置了依赖，子工程会直接继承下来</p><p>2.<dependencyManagement>是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖（无需指定依赖版本）</p><p><strong>聚合</strong>：</p><p>将多个模块组织成一个整体，同时进行项目的构建。</p><p>聚合工程：一个不具有业务功能的”空”工程（有且仅有一个pom文件）</p><p>聚合的作用：快速构建项目（无序根据依赖关系手动构建，直接在聚合工程上构建即可）</p><p><strong>聚合的实现</strong>：maven中通过<modules>设置当前聚合工程所包含的子模块名称</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240405222300050.png" alt="image-20240405222300050" style="zoom:67%;" /> <h4 id="3-私服："><a href="#3-私服：" class="headerlink" title="3.私服："></a>3.<strong>私服：</strong></h4><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415232953007.png" alt="image-20240415232953007" style="zoom:50%;" /> <p><strong>资源上传与下载</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415233717743.png" alt="image-20240415233717743" style="zoom:50%;" /> <h1 id="SpringBoot-面试高频知识点"><a href="#SpringBoot-面试高频知识点" class="headerlink" title="SpringBoot(面试高频知识点)"></a>SpringBoot(面试高频知识点)</h1><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240310202042273.png" alt="image-20240310202042273" style="zoom:50%;" /> <p>http代表请求协议    localhost访问当前本机的服务   8080代表访问的端口    &#x2F;hello代表访问的资源</p><h3 id="springboot配置优先级"><a href="#springboot配置优先级" class="headerlink" title="springboot配置优先级"></a><strong>springboot配置优先级</strong></h3><p><strong>优先级顺序：</strong></p><p>application.properties&gt;yml&gt;yaml</p><p>命令行参数（–xx&#x3D;xxx）  &gt;java系统属性（-Dxxx&#x3D;xxx）&gt;application.properties</p><p>在项目开发时,推荐统一使用一种格式的配置(yml是主流)</p><h3 id="spring-boot原理"><a href="#spring-boot原理" class="headerlink" title="spring boot原理"></a>spring boot原理</h3><p>通过 spring boot  来简化 spring Framework的开发</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415193713500.png" alt="image-20240415193713500" style="zoom:50%;" /><p>因为springboot底层提供了两个非常重要的功能 ：<strong>起步依赖</strong>、<strong>自动配置</strong></p><p><strong>起步依赖的原理</strong>:maven依赖传递</p><h4 id="自动配置原理（面试高频）"><a href="#自动配置原理（面试高频）" class="headerlink" title="自动配置原理（面试高频）"></a><strong>自动配置原理（面试高频）</strong></h4><p>自动配置:springboot的自动配置就是当spring容器启动后,一些配置类、bean对象就自动存入到了ioc容器中，不需要我们手动去声明，从而简化了开发，舍去了繁琐的配置操作。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><strong>HTTP</strong></h1><p>HTTP概述：超文本传输协议,规定了<strong>浏览器</strong>与<strong>服务器</strong>之间的数据传输的规则</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240310220151602.png" alt="image-20240310220151602" style="zoom:50%;" /> <h4 id="http-请求数据格式"><a href="#http-请求数据格式" class="headerlink" title="http-请求数据格式"></a><strong>http-请求数据格式</strong></h4><p>1.请求<strong>行</strong>:  请求数据第一行(请求方式、资源路径、协议) 例如:GET    &#x2F;hello     HTTP&#x2F;1.1</p><p>2.请求<strong>头</strong>：第二行开始，格式 key：value</p><p>3.请求<strong>体</strong>：POST请求，存放请求参数</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311091041740.png" alt="image-20240311091041740" style="zoom:50%;" /> <p>请求方式-GET：请求参数在请求行中，没有请求体，GET请求大小是有限制的</p><p>请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的</p><h4 id="HTTP响应格式："><a href="#HTTP响应格式：" class="headerlink" title="HTTP响应格式："></a><strong>HTTP响应格式：</strong></h4><p><strong>常见响应状态码：</strong>200  客户端请求成功</p><p>​                               404   请求资源不存在，一般是输入url有误，或者网站资源被删除</p><p>​                                500 服务器发生不可预期的错误，服务器出现异常，去查看下日志</p><p><strong>常见的响应状态码和请求头：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408010313944.png" alt="image-20240408010313944" style="zoom: 67%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311093629695.png" alt="image-20240311093629695" style="zoom: 67%;" /> <h4 id="HTTP解析协议"><a href="#HTTP解析协议" class="headerlink" title="HTTP解析协议"></a><strong>HTTP解析协议</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311102555006.png" alt="image-20240311102555006" style="zoom:50%;" /> <h1 id="Web服务器-Tomcat"><a href="#Web服务器-Tomcat" class="headerlink" title="Web服务器-Tomcat"></a><strong>Web服务器</strong>-Tomcat</h1><p>Web服务器是一个软件程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是提供网上信息浏览服务。</p><h4 id="1-web服务器"><a href="#1-web服务器" class="headerlink" title="1.web服务器"></a><strong>1.web服务器</strong></h4><p>1.对HTTP协议操作进行封装，简化web程序开发。</p><p>2.部署web，对外提供网上信息浏览服务</p><h4 id="2-Tomact"><a href="#2-Tomact" class="headerlink" title="2.Tomact"></a><strong>2.Tomact</strong></h4><p>一个轻量级的web服务器，支持servlet、jsp等少量javaEE规范</p><p>也被称为web容器、servlet容器</p><h4 id="Tomcat-基本使用"><a href="#Tomcat-基本使用" class="headerlink" title="Tomcat-基本使用"></a><strong>Tomcat-基本使用</strong></h4><p><strong>Tomcat-基本使用-Tomcat部署项目</strong></p><p>将项目放置到webapps目录下,即部署完成</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311165741456.png" alt="image-20240311165741456" style="zoom:50%;" /> <p>spring-boot-starter-web：包含了web应用开发所需要的常见依赖</p><p>spring-boot-starter-test：包含了单元测试所需要的常见依赖 </p><p>浏览器中访问的就是这个内嵌的tomcat</p><h1 id="请求响应（各类请求参数的接收与封装）"><a href="#请求响应（各类请求参数的接收与封装）" class="headerlink" title="请求响应（各类请求参数的接收与封装）"></a>请求响应（各类请求参数的接收与封装）</h1><p>请求：获取请求数据</p><p>响应：设置响应数据</p><p>BS架构：Browser&#x2F;Server 浏览器&#x2F;服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端（维护方便、体验感一般）</p><p>CS架构：Client&#x2F;Sever，客户端&#x2F;服务器架构模式（开发维护麻烦，体验不错）</p><h4 id="postman（接口测试工具）"><a href="#postman（接口测试工具）" class="headerlink" title="postman（接口测试工具）"></a><strong>postman</strong>（接口测试工具）</h4><p>因为浏览器地址栏发起的请求都是get请求,所以需要postman来接受其他请求</p><p>postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件</p><p>可以用来模拟浏览器向后端服务器发起任何形式的http请求.如(get,set)等</p><p>作用:常用于进行接口测试</p><h4 id="1-简单参数"><a href="#1-简单参数" class="headerlink" title="1.简单参数"></a>1.<strong>简单参数</strong></h4><p>**注解的作用:**用来为代码提供元数据信息的特殊标注,以便在编译,运行,框架扫描执行特定的操作.</p><p>SpringBoot方式：</p><p>简单参数：参数名与形参变量名相同，定义形参即可接收参数    ——&gt;                      例： @ResquestMapping（”&#x2F;simpleParam”）</p><p>​                                                                                                                                            public string simpleParam(<strong>String name</strong>，<strong>Integer age</strong>){}  这个两个形参与在                    </p><p>​                                                                                                                                              postman中发起的get请求传入的参数名要相同</p><p><strong>如果方法形参名称与请求参数名称不匹配，可以使用@RequestParam完成映射</strong></p><p><strong>注意：</strong>@RequestParam中的required属性默认为true，代表该请求参数必须传递，如果不传递将报错，如果参数是可选的，可以将required属性设置为false</p><p>简单参数的接收：  1 方法已经不用了解即可</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408131217410.png" alt="image-20240408131217410" style="zoom: 67%;" /> <h4 id="2-实体参数"><a href="#2-实体参数" class="headerlink" title="2.实体参数"></a>2.实体参数</h4><p>在简单参数接收的时候，如果前端传递很多参数的时候，通过简单参数接收（定义参数名与形参名相同）的这种方式比较繁琐，且不便于后期的维护</p><p>这时候考虑将所有的<strong>前端传递过来的请求参数封装到一个实体类当中</strong></p><p><strong>简单实体类对象：请求参数名与形参对象属性名相同，定义POJO接收即可。</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408135821913.png" alt="image-20240408135821913" style="zoom: 67%;" /> <h4 id="3-数组集合参数"><a href="#3-数组集合参数" class="headerlink" title="3.数组集合参数"></a>3.数组集合参数</h4><p><strong>数组参数：</strong></p><p>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</p><p><strong>在形参中声明一个数组，数组名和请求参数名保持一致，可以自动的将请求参数封装到数组中</strong></p><p><strong>集合参数</strong>：</p><p><strong>请求参数名与形参集合名称相同且请求参数为多个</strong>，**@RequestParam绑定参数关系**</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408141702345.png" alt="image-20240408141702345" style="zoom: 67%;" /> <h4 id="4-日期参数"><a href="#4-日期参数" class="headerlink" title="4.日期参数"></a>4.日期参数</h4><p>使用@DateTimeFormat注解完成日期参数格式转换 ，方法形参名必须与前端传过来的请求参数名相同</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408142541913.png" alt="image-20240408142541913" style="zoom: 67%;" /> <h4 id="5-Json参数"><a href="#5-Json参数" class="headerlink" title="5.Json参数"></a>5.<strong>Json参数</strong></h4><p><strong>json就是前后端进行数据交互的一种数据格式</strong></p><p>1.postman发送请求的时候，如何传递json格式的参数？</p><p><strong>将请求方式设置为post</strong>，<strong>设置请求体，选择raw，json</strong></p><p>2.在服务端controller中，怎么接收json格式的请求参数?</p><p><strong>通过实体对象来接收</strong>。</p><p>JSON数据<strong>键名</strong>与形参对象<strong>属性名</strong>相同，定义POJO类型形参即可接收对象，需要使用**@ResquestBody**标识。</p><p><strong>@ResquestBody将json格式的请求数据封装到一个实体对象当中</strong></p><h4 id="6-路径参数"><a href="#6-路径参数" class="headerlink" title="6.路径参数"></a>6.<strong>路径参数</strong></h4><p>所谓的路径参数就是参数已经成为url的一部分了   例：http:localhost:8080&#x2F;path&#x2F;<strong>1</strong>    其中1也是传递的请求参数</p><p><strong>路径参数</strong>：<strong>通过url直接传递参数，使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数</strong>，<strong>绑定给形参</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408153004617.png" alt="image-20240408153004617" style="zoom: 67%;" /> <h1 id="设置响应"><a href="#设置响应" class="headerlink" title="设置响应"></a>设置响应</h1><p><strong>在controller中定义的每一个方法都称为一个功能接口</strong>      <strong>@requestMapping（””）中的路径就是该接口的访问路径。</strong></p><p>前端人员发起请求，请求到我们的接口，响应回去的数据各式各样的都有（字符、对象、列表），前端人员拿到结果解析很麻烦。</p><p>所以在项目开发当中，我们给所有功能接口设置一个统一的响应结果，满足所有业务场景。使用一个<strong>实体对象Result</strong>来接受。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408161304229.png" alt="image-20240408161304229" style="zoom: 67%;" /> <p><strong>总结</strong>：<strong>1.@ResponseBody</strong>  类型：方法注解、类注解</p><p>​                                                位置：controller方法上、类上</p><p>​                                                 作用：将方法返回值直接响应，如果返回值类型是 实体对象&#x2F;集合的话 ，将会转换成json格式响应</p><p>​                                                   说明：**@ RestController**&#x3D;@Controller+@ResponseBody   </p><p>​             2.<strong>统一响应结果：</strong> Result（code、msg、data）</p><p>​                <strong>@ RestController</strong>  将内部的每个方法都会将返回值转换成json或xml格式直接作为HTTP响应体的内容返回给客户端</p><h1 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h1><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><p>1.Controller层:控制层、接收前端发送的 请求，对请求进行处理，并响应数据</p><p>2.Service层：业务逻辑层，处理具体的业务逻辑</p><p>3.Dao层：数据访问层（持久层），负责数据访问操作，包括数据的增、删、改、查</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408203856519.png" alt="image-20240408203856519" style="zoom: 80%;" /> <p><strong>总体流程:当前端发起请求时,请求先到controller层,controller层只负责接收请求,响应数据,接收到请求后,直接调用service中的方法,而service仅仅负责具体逻辑处理,service中又调用Dao,Dao来负责数据的访问操作,去查询数据,再将查询的数据返回给service,service拿到数据后,再来对数据进行逻辑处理,最后将处理后的结果返回给Controller程序,controller拿到的就是处理完毕的结果,最后再将结果响应给前端.</strong></p><hr><h4 id="分层解耦-1"><a href="#分层解耦-1" class="headerlink" title="分层解耦"></a>分层解耦</h4><p>内聚：软件中各个功能模块内部的功能联系。(比如某一个模块的service类仅仅编写与那个模块相关的逻辑处理,其他模块的逻辑处理不会写进去,内聚层度较高)</p><p>耦合：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度</p><p>软件设计原则：<strong>高内聚低耦合</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240408205450737.png" alt="image-20240408205450737"  /> <p>controller调用service,直接new了一个service的实现,但是若是service中的实现类出现变动,controller中也要变动,所以就有了<strong>ioc</strong>的出现,可与理解为一个<strong>容器</strong>,将需要的<strong>实现类对象</strong>存放在容器中,controller直接从容器中进行查找这个实现类</p><p><strong>问题在于这个对象怎么去交给容器管理呢?</strong></p><p>​               <strong>控制反转</strong></p><p><strong>容器怎么样为我们的程序(比如说controller)提供所依赖的资源</strong></p><p>​                <strong>依赖注入</strong></p><p><strong>控制反转</strong>：IOC，对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转(<strong>springboot的第一大核心</strong>)</p><p>原来在应用程序中我需要什么对象直接new什么对象,现在将所有的对象交给容器来管理.  该容器叫IOC容器或spring容器.</p><p><strong>依赖注入</strong>：DI   容器为应用程序提供运行时所依赖的资源，称为依赖注入</p><p><strong>Bean对象</strong>:<strong>IOC</strong>容器中创建、管理的对象，称之为bean</p><h4 id="IOC-DI入门"><a href="#IOC-DI入门" class="headerlink" title="IOC&amp;DI入门"></a>IOC&amp;DI入门</h4><p>1.Service层及Dao层的实现类,交给IOC容器管理:             加一个注解即可加在service和dao中 <strong>@Component</strong>:将当前的类交给ioc容器管理,成为ioc容器中的bean</p><p>2.为Controller以及Service注入运行时,依赖的对象           加一个注解即可   <strong>@Autowired</strong>是加在controller层和service层中的.运行时,ioc容器提供该类型的                               bean对象,并赋值给该变量</p><p>3.运行测试</p><h4 id="IOC详解"><a href="#IOC详解" class="headerlink" title="IOC详解"></a>IOC详解</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240409141711058.png" alt="image-20240409141711058" style="zoom: 50%;" /> <p>service和dao中的@component  可以分别替换为**@service<strong>和</strong>@Repository**(很少用,mybatis会有其他的注解替换)</p><p>@SpringBootApplication具有包扫描作用,默认扫描当前包及其子包</p><p>@Component的衍生注解:@Controller   @Service   @Repository</p><p><strong>Bean组件扫描:</strong></p><p>前面声明bean的四大注解,想要生效,还需要被组件扫描注解@ComponentScan扫描</p><p>@ComponentScan注解虽然没有显式配置,但是实际上已经包含在启动类声明注解@SpringBootApplication中,默认扫描的范围是<strong>启动类所在包及其子包</strong></p><h4 id="DI详解"><a href="#DI详解" class="headerlink" title="DI详解"></a>DI详解</h4><p>依赖注入的注解:</p><p>@Autowired:默认按照类型自动装配</p><p>如果同类型的bean存在多个:<br>1.@Primary        想让哪个bean生效,就在上面加这个注解</p><p>2.@Autowired + @Qualifier(“bean的名称”)</p><p>3.@Resource(name&#x3D;”bean的名称”)</p><p><strong>面试题</strong>: @Resource 与@Autowired区别:</p><p>​              1.@Autowired是spring框架提供的注解,而@Resource是jdk提供的注解</p><p>​              2.@Autowired是按照默认类型注入,@Resource是默认按照名称注入</p><p>​               3.当一个接口存在多个实现类的情况下，@Autowired和@Resource都需要通过名称才能准确的匹配到对应Bean。</p><p>​                    @Autowired通过@Qualifier注解来显式指定名称，@Resource 通过name属性来显式指定名称</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>数据库:DataBase(DB),是存储和管理数据的仓库</p><p>数据库管理系统:操纵和管理数据库的大型软件</p><p>SQL: Structured Query Language操作关系型数据库的编程语言,定义了一套操作关系型数据库统一标准</p><p>语法:</p><p>mysql -u用户名 -p密码 [ -h数据库服务器ip地址 -P端口号]</p><h4 id="MySQL数据模型"><a href="#MySQL数据模型" class="headerlink" title="MySQL数据模型"></a><strong>MySQL数据模型</strong></h4><p><strong>关系型数据库:建立在关系模型基础上,由多张相互连接的二维表组成的数据库</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311210606679.png" alt="image-20240311210606679"></p><h4 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a><strong>SQL通用语法</strong></h4><p>1.SQL语句可以单行或者多行，以分号结尾</p><p>2.SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</p><p>3.MySQL数据库的SQL语句不分大小写</p><p>4.注释：单行注释 –注释内容或者#注释内容（MySQL特有） 多行注释：&#x2F;* 注释内容 *&#x2F;</p><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><strong>SQL分类</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311212651840.png" alt="image-20240311212651840" style="zoom:67%;" /> <h4 id="开发项目流程"><a href="#开发项目流程" class="headerlink" title="开发项目流程"></a><strong>开发项目流程</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240311213255232.png" alt="image-20240311213255232" style="zoom: 67%;" /> <h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a><strong>DDL</strong></h3><p>database 可以替换成 schema</p><p>全称 data definition language ，数据定义语言，用来定义数据库对象（数据库、表）</p><p><strong>数据库操作：</strong></p><p><strong>查询：</strong>所有数据库：show databases；   查询当前数据库：select database（）；</p><p><strong>使用</strong>:使用数据据库： use  数据库名；</p><p><strong>创建数据库：</strong> create database[if not exists] 数据库名</p><p><strong>删除</strong>：删除数据库 ： drop database [if exists] 数据库名；</p><h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a><strong>数据库连接</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240318221049115.png" alt="image-20240318221049115" style="zoom:67%;" /> <p>[]代表可写可不写,如果写的话不需要加[],直接写在后面即可</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312095612268.png" alt="image-20240312095612268" style="zoom:67%;" /> <h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h4><p>MySQL中的数据类型有很多，主要分为三类：    <strong>数值类型、字符串类型、日期时间类型</strong></p><p><strong>数值类型：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312105250674.png" alt="image-20240312105250674" style="zoom: 67%;" /> <p><strong>字符串类型：</strong> </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312105317413.png" alt="image-20240312105317413" style="zoom: 67%;" /> <p><strong>日期时间类型</strong>：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312105448980.png" alt="image-20240312105448980" style="zoom: 200%;" /><p><strong>char()和varchar()区别:</strong></p><p>char 是定长字符串,varchar是变长字符串</p><p><strong>char(10)和varchar(10):</strong></p><p>char(10)最多只能存10个字符,不足十个字符,占用十个字符空间   性能高   浪费空间</p><p>varchar(10)最多只能存十个字符,不足十个字符,按照实际长度存储   性能低   节省空间</p><h4 id="DDL-表操作-了解即可"><a href="#DDL-表操作-了解即可" class="headerlink" title="DDL(表操作)    了解即可"></a><strong>DDL(表操作)</strong>    了解即可</h4><p> **图形化界面对表操作 **                    <strong>已经被图形化界面工具给取代</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312145641981.png" alt="image-20240312145641981" style="zoom:67%;" /> <h3 id="DML-重点"><a href="#DML-重点" class="headerlink" title="DML 重点"></a>DML 重点</h3><p>DML全称是data manipulation language（数据操作语言），用来对数据库中表的数据记录进行增、删、改操作。</p><p>添加数据：<strong>insert</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312154404169.png" alt="image-20240312154404169" style="zoom:50%;" /> <p>修改数据：<strong>update</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312155645968.png" alt="image-20240312155645968" style="zoom:50%;" /> <p>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据</p><p>删除数据：<strong>delete</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312160912838.png" alt="image-20240312160912838" style="zoom:50%;" /> <p><strong>DML总结:</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521093534864.png" alt="image-20240521093534864" style="zoom:50%;" /> <h3 id="DQL-重点"><a href="#DQL-重点" class="headerlink" title="DQL   重点!"></a><strong>DQL</strong>   重点!</h3><p>DQL英文全称是 data query language（数据查询语言），用来查询数据库表中的记录</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240319163737543.png" alt="image-20240319163737543" style="zoom:50%;" /> <p><strong>关键词：select</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312164327980.png" alt="image-20240312164327980" style="zoom: 67%;" /> <p>  <strong>条件查询</strong>   where</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240312184918821.png" alt="image-20240312184918821" style="zoom:50%;" />程</p><p><strong>聚合函数</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313103932816.png" alt="image-20240313103932816"></p><p>**分组查询  ** group by</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313111110585.png" alt="image-20240313111110585"></p><p><strong>面试题</strong></p><p>where和having区别</p><p>1.执行时机不同**:where是分组之前进行过滤**,不满足where条件,不参与分组,<strong>而having是分组之后对结果进行过滤</strong></p><p>2.判断条件不同**:where不能对聚合函数进行判断,而having可以** </p><p><strong>注意事项</strong>:</p><p>分组之后,查询的字段一般为聚合函数的分组字段,查询其他字段无任何意义</p><p>执行顺序:where&gt;聚合函数&gt;having</p><p><strong>排序查询</strong>     order by</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313123914663.png" alt="image-20240313123914663"></p><p><strong>注意事项</strong>:如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序</p><p><strong>分页查询</strong>  limit</p><p>*<em>起始索引&#x3D;(页码-1)<em>每页展示记录数.</em></em></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313125734430.png" alt="image-20240313125734430" style="zoom: 67%;" /><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313142530668.png" alt="image-20240313142530668"></p><h1 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h1><p>一对多</p><p>一对多的实现:在数据库表中多的一方,添加字段,来关联一的一方的主键</p><p>外键:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240313162223646.png" alt="image-20240313162223646" style="zoom: 67%;" />   <p><strong>外键约束一般不用物理外键,用逻辑外键</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521150344851.png" alt="image-20240521150344851" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521150635871.png" alt="image-20240521150635871" style="zoom:50%;" /></p><p><strong>一对一</strong></p><p>实现:在任意一方加入外键,关联另一方的主键,并且设置外键为唯一的unique</p><p><strong>多对多</strong></p><p>建立第三张中间表,中间表至少包含两个外键,分别关联两方主键.</p><p>通过中间表来维护,中间表的两个外键,分别关联另外两张表的主键</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h3><p>从多张表中查询数据</p><p>笛卡尔积:笛卡尔乘积是指在数学中,两个集合(A集合和B集合)的所有组合情况</p><p><strong>连接查询:</strong></p><p>内连接:相当于查询A、B交集部分数据</p><p>外连接：</p><p>左外连接：查询<strong>左表</strong>所有的数据（包括两张表交集部分数据）</p><p>右外连接：查询<strong>右表</strong>所有数据（包括两张表交集部分数据）</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240521163324104.png" alt="image-20240521163324104" style="zoom:50%;" /> <p><strong>内连接</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314135356867.png" alt="image-20240314135356867" style="zoom: 67%;" /> <p><strong>外连接</strong></p><p>一般都是用左外连接，因为右外连接可以被左外连接替换。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314142321882.png" alt="image-20240314142321882" style="zoom:67%;" /> <p><strong>子查询</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314143903755.png" alt="image-20240314143903755" style="zoom:67%;" /> <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务</strong>是一组操作的集合,它是一个不可分割的工作单位.事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求,<strong>即这些操作要么同时成功,要么同时失败</strong></p><p>例： 如果删除一个部门，那么该部门下的所有员工也应该被删除</p><p>注意:默认MySql的事务是自动提交的,当执行一条DML语句,MySQL会立即隐式的提交事务.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314160745314.png" alt="image-20240314160745314" style="zoom:67%;" /> <p>事务四大特性:</p><p>原子性:事务是不可分割的最小单元,要么全部成功,要么全部失败</p><p>一致性:事务完成时,必须使所有的数据都保持一致状态</p><p>隔离性:数据库系统提供的隔离机制,保证事务在不受外部并发操作影响的独立环境下运行</p><p>持久性:事务一旦提交或者回滚,他对数据库中的改变就是永久的</p><hr><h1 id="事务进阶"><a href="#事务进阶" class="headerlink" title="事务进阶"></a><strong>事务进阶</strong></h1><p><strong>spring事务管理</strong></p><p>注解： @Transactional    &#x2F;&#x2F;spring事务管理</p><p>位置：业务（service）层的方法上、类上、接口上</p><p>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</p><p><strong>事务属性–回滚</strong></p><p>默认情况下，只有出现RuntimeException才回滚异常。rollbackfor属性用于控制出现何种异常类型，回滚事务。</p><p>@Transactional（rollbackFor&#x3D;Exception.class） 指定所有的异常都回滚。 </p><p><strong>事务属性–传播行为</strong></p><p>事务属性-传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制？</p><p>​                 REQUIRED:大部分情况下都是用该传播</p><p>​                 REQUIRES_NEW:当我们不希望事务之间相互影响时，可以用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415091907538.png" alt="image-20240415091907538" style="zoom:50%;" /> <h1 id="AOP（spring第二大核心）"><a href="#AOP（spring第二大核心）" class="headerlink" title="AOP（spring第二大核心）"></a><strong>AOP</strong>（spring第二大核心）</h1><h4 id="AOP概述："><a href="#AOP概述：" class="headerlink" title="AOP概述："></a><strong>AOP概述：</strong></h4><p>AOP:（面向切面编程、面向方面编程），其实就是<strong>面向特定方法编程</strong>，在不改动原始方法的基础上，针对原始方法编程，可以是功能的增强，也可以是功能的改变。</p><p>@Aspect标识当前类是AOP类</p><p><strong>场景：</strong></p><p>案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时</p><p>应用场景：记录操作日志，权限控制，事务管理。。。</p><p>优势：代码无侵入，减少重复代码，提高开发效率，维护方便</p><h4 id="springAOP开发步骤"><a href="#springAOP开发步骤" class="headerlink" title="springAOP开发步骤"></a><strong>springAOP开发步骤</strong></h4><p>1.AOP开发的依赖</p><p>2.编写AOP的代码，根据业务需要进行特定的编程</p><h4 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a><strong>AOP核心概念</strong></h4><p>连接点：joinpoint ,可以被Aop控制的方法（暗含方法执行时的相关信息）</p><p>通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）</p><p>切入点：pointcut匹配连接点的条件，通知仅会在切入点方法执行时被应用</p><p>切面：Aspect，描述通知与切入点的对应关系</p><p>目标对象：Target，通知所应用的对象</p><h4 id="AOP执行流程"><a href="#AOP执行流程" class="headerlink" title="AOP执行流程"></a><strong>AOP执行流程</strong></h4><p>一旦进行了AOP程序的开发，运行的就不再是原始的目标对象，而是基于目标对象生成的代理对象</p><p><strong>实现：</strong></p><p><strong>动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。</strong></p><h1 id="AOP进阶-难点"><a href="#AOP进阶-难点" class="headerlink" title="AOP进阶(难点)"></a><strong>AOP进阶</strong>(难点)</h1><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415102545955.png" alt="image-20240415102545955" style="zoom:50%;" /> <h4 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h4><p>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行</p><p>用**@Order（数字）**加在切面类上来控制顺序</p><p>目标方法前的通知方法：数字小的先执行</p><p>目标方法后的通知方法：数字小的后执行</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415132204950.png" alt="image-20240415132204950" style="zoom: 50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415133512542.png" alt="image-20240415133512542" style="zoom: 50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415134859448.png" alt="image-20240415134859448" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415140654118.png" alt="image-20240415140654118" style="zoom:50%;" /> <p><strong>切入点表达式</strong>@annotation，用于匹配标识有特定注解的方法。</p><h4 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h4><p>在Spring中用jointPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等</p><p>对于@Around通知，获取连接点信息只能用proceedingJoinPoint</p><p>对于其他四种通知，获取连接点信息只能用JointPoint，它是ProceedingJoint的父类型</p><h1 id="索引-数据库优化最重要手段"><a href="#索引-数据库优化最重要手段" class="headerlink" title="索引(数据库优化最重要手段)"></a>索引(数据库优化最重要手段)</h1><p>索引是帮助数据库<strong>高效获取数据</strong>的<strong>数据结构.</strong></p><p><strong>索引优点:</strong></p><p>1.提高数据查询的效率,降低数据库io的成本.</p><p>2.通过索引对数据进行排序,降低数据排序的成本,降低cpu消耗.</p><p><strong>索引缺点</strong>***:</p><p>1.索引会占用存储空间</p><p>2.提高查询效率,但是同时降低了insert、update、delete的效率</p><p><strong>结构</strong> <strong>MySQL数据库中默认的索引结构式B+Tree</strong></p><p>  数据库支持的索引结构有很多，如Hash索引、B+tree索引、full-text索引。我们平常所说的索引，如果没有特别指明，都是指默认的B+Tree结构组织的索引。</p><p><strong>B+Tree（多路平衡搜索树）</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240314184846964.png" alt="image-20240314184846964" style="zoom: 80%;" /><p><strong>索引语法</strong></p><p>1.创建索引</p><p>create（unique）index  索引名  on  表名 （字段名，…）；</p><p>2.查看索引</p><p>show  index  from 表名；</p><p>3.删除索引</p><p>drop index 索引名 on 表名；</p><p>注意事项:主键字段,在建表时,会自动创建主键索引</p><p>​                 添加唯一约束时,数据库实际上会添加唯一索引</p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h1><p>并不是每次都基于图形化界化工具来操作数据库,<strong>通过java程序来完成对数据库的操作,其中最主流的操作就是mybatis</strong></p><p>MyBatis是一款优秀的持久层(dao层,数据访问层)<strong>框架</strong>，操作数据库的，<strong>在dao持久层中来操作数据库的</strong>,用于简化JDBC（操作数据库的规范）的开发    .</p><p><strong>基于springboot整合mybatis的方式讲解</strong></p><h4 id="小入门-使用mybatis查询所有用户数据"><a href="#小入门-使用mybatis查询所有用户数据" class="headerlink" title="小入门:使用mybatis查询所有用户数据"></a>小入门:使用mybatis查询所有用户数据</h4><p><strong>步骤:</strong></p><p><strong>1.准备工作（创建springboot工程、数据库表user、实体类User）</strong></p><p><strong>这个实体类就是用来封装用户信息的，在java程序当中，sql语句执行完毕之后会将结果返回给java程序，java程序就需要将这个结果给封装起来，返回的每一个数据都会封装成user对象，表中的字段会自动的封装到对象的属性当中，表中的字段名和类中的属性名保持一致，这样框架可以完成自动封装.</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410003453302.png" alt="image-20240410003453302" style="zoom:67%;" /> <p>**2.**引入Mybatis的相关依赖 ，依赖:MybatisFramework 、MySQL Driver    java程序要知道把sql语句发送给哪台数据库所以要配置Mybatis（数据库连接信息） 配置数据库连接四要素 在application.properties中进行配置</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410004017584.png" alt="image-20240410004017584" style="zoom: 80%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410003953085.png" alt="image-20240410003953085" style="zoom: 67%;" /></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410004410894.png" alt="image-20240410004410894">  </p><p>**3.**编写SQL语句(注解&#x2F;XML) </p><p>我们先按照注解来定义sql语句,根据mybatis的规范,需要定义一个持久层(dao)的接口UserMapper,在接口上加上@Mapper注解来标识当前就是mybatis 中的一个持久层接口(dao),也就是dao层的接口,也称为Mapper接口,在Mpper接口中定义一个方法加上一个注解@Select 来指定当前是一个查询操作,在注解当中写上要执行的sql语句,最终我们想执行这条sql语句,只要调用UserMapper当中的list方法就可以,框架会自动的执行这条sql语句,并自动的将sql语句执行的结果封装到方法的返回值当中.</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410005542398.png" alt="image-20240410005542398"></p><p>在mybatis的开发当中 ,我们只需定义这个mapper接口就可以了,不需要定义它的实现类,因为在程序运行时,框架会自动生成这个接口的实现类对象.你只需要定义一个该接口的实现类名字即可,在调用该接口的地方</p><p>接口不能new实现类,可以定义一个该接口的类的对象来实例化接口.</p><p>假设你有一个接口 <code>MyInterface</code>，你可以创建一个实现了 <code>MyInterface</code> 接口的类 <code>MyClass</code>，然后实例化 <code>MyClass</code> 的对象，并将其引用赋值给接口类型的引用。这样就可以通过接口引用来访问 <code>MyClass</code> 对象的方法。</p><p>全部流程: </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410005622335.png" alt="image-20240410005622335" style="zoom:80%;" /> <p>4.<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240321192407247.png" alt="image-20240321192407247" style="zoom:67%;" /></p><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h4><p>用java语言操作关系型数据库的一套api</p><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h4><p>是一个容器，负责分配、管理数据库连接（Connection）</p><p>优势：资源复用、提升系统响应速度\避免数据库遗漏</p><p>接口：DataSource</p><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a><strong>lombok</strong></h2><p>作用：Lombok是一个实用的java类库,能通过注解的形式自动生成构造器,getter&#x2F;setter、equals、hashcode、tostring、等方法 并可以自动化生成日志变量，简化java开发、提高效率.  </p><p>使用lombok需要添加对应的依赖</p><p><strong>Lombok的原理是什么</strong>：在程序编译的时候根据上面的注解生成对应的方法        例如在实体类中添加@Data注解，就可以不用再手动添加get、setter等方法</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410143641490.png" alt="image-20240410143641490" style="zoom:67%;" /> <p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240321203910352.png" alt="image-20240321203910352"></p><h4 id="mybatis基础操作"><a href="#mybatis基础操作" class="headerlink" title="mybatis基础操作"></a>mybatis<strong>基础操作</strong></h4><p>在数据库表中字段名是下划线分隔的，在实体类中采用标准的<strong>驼峰命名</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240321211639584.png" alt="image-20240321211639584" style="zoom:80%;" /> <p>1.<strong>删除</strong></p><p>创建对应的接口方法,在调用接口方法的时候,才会执行注解中的sql语句,所以要在接口方法中定义参数,sql执行时,将参数传进去就行</p><p>使用@Delete注解  里面写入要执行的sql语句,不能把id写死,要换成动态的将id值传进来,需要使用mybatis中的占位符#{}进行动态获取</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410155531281.png" alt="image-20240410155531281" style="zoom:67% ;" /><p>日志输出:看到mybatis执行的sql和对应的结果</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410163244013.png" alt="image-20240410163244013" style="zoom:67%;" /> <p>可以看到控制台有预编译sql的输出</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410163856127.png" alt="image-20240410163856127"> </p><p><strong>#{} 会被? 所替代 生成预编译的sql,第二行的数字即为要传进去的参数替换掉问号, 第三行为更新的数量</strong></p><p>sql注入:通过操作输入的数据来修改事先定义好的sql语句,以达到执行代码对服务器进行进行攻击的方法</p><p>预编译sql优势:性能更高,防止sql注入,更加安全</p><p>参数占位符:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410170004282.png" alt="image-20240410170004282" style="zoom: 50%;" /> <p>2.<strong>新增</strong></p><p>先写好sql语句,再定义接口方法  ,因为sql语句中传入的参数太多,所以把他们封装实体对象中,sql语句执行时,获取从实体对象中传递进来的属性值即可,在sql语句中用#{}获取对应的属性,在接口方法的形参传入定义实体类对象,最后到测试类中去创建这个对象并调用这个接口方法.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410195946510.png" alt="image-20240410195946510" style="zoom:50%;" /> <p><strong>（主键返回）</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240323160806778.png" alt="image-20240323160806778" style="zoom: 50%;" /><p>3.<strong>更新</strong></p><p>和新增步骤差不多,这里不详细说明.</p><p>4.<strong>查询</strong>(根据id查询)</p><p>注意查询是有返回值的,查询返回了一条数据,将这条数据封装起来,封装到员工对象当中   如果返回的数据很多,将其封装在列表中.List&lt;&gt;</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410205601462.png" alt="image-20240410205601462" style="zoom: 67%;" /> <p>数据封装:实体类属性名和数据库表查询返回的字段名一致,mybatis会自动封装</p><p>如果实体类属性名和数据库表查询返回的字段名不一致,不能自动封装</p><p>也就是说如果实体类中的属性名和数据库查询返回的字段<strong>不一样</strong>的话,返回的对应值为null,解决的方法就是在<strong>properties文件</strong>中开启<strong>驼峰命名自动开关</strong></p><p>即从数据库字段名a_column映射到java属性名aColumn</p><p>4**.查询根据条件查询**</p><p>根据条件查询接口中的方法是有返回值的,因为是多条记录,所以封装到到一个集合当中,泛型是实体类</p><p>contact 是连接符</p><h2 id="xml映射文件"><a href="#xml映射文件" class="headerlink" title="xml映射文件"></a>xml映射文件</h2><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a><strong>规范</strong></h4><p>1.xml映射文件的名称要与Mapper接口名称一致,并且将xml映射文件和Mapper接口放置在相同包下(同包同名)</p><p>2.xml映射文件的namespace属性为Mapper接口全限定名一致</p><p>3.xml映射文件中sql语句的id与Mapper接口中的方法名一致,并且保持返回值类型一致</p><p><strong>我们为什么要遵守上面三点的规范呢？</strong></p><p>通过mybatis这个框架来操作数据库，最终是调用Mapper接口中的方法来完成数据库的操作，我们要明白最终我们操作数据库并不是通过这个方法来操作这个数据库，而是执行了与这个方法对应的sql语句来完成数据库的操作</p><p>！！所以我们要根据接口的方法来找到对应的sql语句，如果我们按照这个三点规范来定义了这样的一份xml映射文件，当我们在调用接口中的方法的时候，此时mybatis框架会自动的查找namespace属性值与这个接口全类名相同的xml文件，并且在这份xml映射文件中找到id属性值与方法名相同的这条sql语句，最终来运行sql语句从而完成数据库的操作.如果我们按照这个规范来定义这个xml文件,那么mybatis框架根据这个思路很容易定位到调用这个 方法要执行的哪条sql语句.</p><p>**注解和xml应用地方:**使用mybatis的注解来完成简单的增删改查功能,如果需要实现复杂的sql功能,建议使用xml映射语句</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240324111725898.png" alt="image-20240324111725898"></p><p>在resources中创建xml文件,new  directory     要用 &#x2F; 符号来进行分隔,不能用  .  分割.</p><h3 id="xml文件中需要配置的东西"><a href="#xml文件中需要配置的东西" class="headerlink" title="xml文件中需要配置的东西"></a><strong>xml文件中需要配置的东西</strong></h3><p>1.在创建好的xml文件中,需要去mybatis中文网上找配置语句</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240410235425232.png" alt="image-20240410235425232" style="zoom:50%;" /><p>2.配置<Mapper  namespace="Mapper接口全限定名一致"> </p><p>&lt;select id&#x3D;”接口方法名”   resultType&#x3D;”返回值类型的全限定名<br>        sql语句。。。。<br>        </select></p></Mapper><h4 id="mybatis-X"><a href="#mybatis-X" class="headerlink" title="mybatis-X"></a><strong>mybatis-X</strong></h4><p>接口方法名 alt +回车  自动生成对应的sql语句</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a><strong>动态SQL</strong></h2><p><strong>随着用户的输入或外部条件的变化而变化的SQL语句,我们称为动态SQL</strong></p><p><strong>动态sql作用:如果条件成立了再进行判断</strong></p><p><if> :用于判断条件是否成立,使用test属性进行条件判断,如果条件为true,则拼接SQL</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411004253055.png" alt="image-20240411004253055"> </p><p><where>:where元素只会在子元素有内容的情况下才插入where子句.而且会自动去除子句的开头and或or</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411005120423.png" alt="image-20240411005120423" style="zoom: 67%;" /> <p><set>:动态地在首行插入set关键字,并会删掉额外的逗号(<strong>用在update语句中</strong>) </p><p><foreach>:一般用在批量操作当中,是进行循环遍历的</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240318124208403.png" alt="image-20240318124208403" style="zoom:67%;" /> <p><sql>定义可重用的sql片段,公共片段的sql抽取</p><p><include> 通过属性id,知道包含的sql片段,公共sql片段的引用</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h4 id="开发web应用流程"><a href="#开发web应用流程" class="headerlink" title="开发web应用流程"></a>开发web应用流程</h4><p><strong>我们开发这样的一个web应用,包括三个部分:前端程序    后端程序    数据库. 前端会发起请求请求后端,也就是服务端,服务端接受到请求后,再来操作数据库.</strong></p><p><strong>请求处理完毕后 ,服务端再把请求的响应结果给前端.</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240318203337328.png" alt="image-20240318203337328" style="zoom:80%;" /><h4 id="创建好工程之后结构如下"><a href="#创建好工程之后结构如下" class="headerlink" title="创建好工程之后结构如下:"></a><strong>创建好工程之后结构如下:</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411102622270.png" alt="image-20240411102622270" style="zoom:67%;" />               <p>1.controller  存放着控制层的代码</p><p>2.service     存放着 接口和对应的实现类</p><p>3.mapper   存放着mapper接口</p><p>4.pojo      存放着实体类</p><p>把这些接口和类创建出来 并交给ioc容器管理   需要加注解.  <strong>controller加@RestController    mapper加@Mapper注解   service层加@Service注解</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240325103059668.png" alt="image-20240325103059668" style="zoom:80%;" /> <p>前端人员开发前端的工程,将打包好的前端工程部署在NGINX上运行</p><p>后端人员需要开发后端的工程,也就是服务端工程,将打包好的工程运行在Tomcat服务器中</p><p>前端程序请求服务端,服务端接收到请求并处理 再响应给前端</p><h4 id="项目开发规范-Restful"><a href="#项目开发规范-Restful" class="headerlink" title="**项目开发规范:**Restful"></a>**项目开发规范:**Restful</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411105105817.png" alt="image-20240411105105817" style="zoom: 50%;" /> <p><strong>开发规范</strong>:统一的响应结果 result     前后端交互统一响应结果Result    所有的增删改查都需要返回一个统一的响应结果Result</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411105515130.png" alt="image-20240411105515130" style="zoom:67%;" /> <h4 id="项目开发流程："><a href="#项目开发流程：" class="headerlink" title="项目开发流程："></a><strong>项目开发流程：</strong></h4><p>  <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411105933138.png" alt="image-20240411105933138"></p><h4 id="部门管理功能开发"><a href="#部门管理功能开发" class="headerlink" title="部门管理功能开发:"></a>部门管理功能开发:</h4><h5 id="1-查询部门-思路"><a href="#1-查询部门-思路" class="headerlink" title="1.查询部门 -思路"></a>1.<strong>查询部门 -思路</strong></h5><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240325110756502.png" alt="image-20240325110756502" style="zoom:67%;" /> <p><strong>前端发送请求，controller接收请求，在service中调用mapper接口查询，通过mapper接口来操作数据库，执行sql语句，获取到查询结果返回给service，再返回给controller，将结果封装到一个统一响应结果result对象中响应给前端。</strong></p><p><strong>查询部门代码流程:</strong></p><p>**1.**前端发送请求之后 ,会请求controller方法,方法当中调用service来获取数据,</p><p>controller需要调用service,所以在controller中注入一个service对象.在controller方法中调用service方法查询部门数据.</p><p>然后在service接口中定义该方法,然后再到对应的service实现类中实现该接口方法  </p><p>然后在service实现类中方法里面去调用mapper的方法来查询全部的部门信息(在  return后面 调用mapper的方法), 去mapper接口中创建方法并且编写select   sql语句.</p><p>为什么还要service接口的实现类 ————&gt;   <strong>在Java中，接口（interface）定义了一组方法的规范，而实现类（class）则提供了这些方法的具体实现。实现类需要实现接口中定义的所有方法，以满足接口的合约（contract）</strong></p><p><strong>2</strong>.在service实现类中调用mapper接口当中的方法,来查询信息</p><p><strong>3</strong>.在mapper接口中会往数据库中发送sql语句,并且把查询的信息封装到集合当中,最后将这个集合的数据返回给service,service又返回给了controller</p><p>   controller拿到返回回来的数据之后,将数据再返回给前端,<strong>查询中返回方法要有参数</strong>.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411135610316.png" alt="image-20240411135610316" style="zoom: 67%;" /> <p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411155630048.png" alt="image-20240411155630048" style="zoom:50%;" />   <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411155700322.png" alt="image-20240411155700322" style="zoom: 50%;" /></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411155750181.png" alt="image-20240411155750181" style="zoom:50%;" /><p>总结:前端发送请求,请求到controller中的方法,然后在controller中的方法中调用service来获取数据</p><p>在service的实现类当中调用mapper接口中的方法,在mapper接口中往数据库发送sql语句 也就是在@selcet(“”)中写sql语句</p><p>将查询到的结果封装起来,然后数据进行返回.</p><h5 id="2-删除部门"><a href="#2-删除部门" class="headerlink" title="2.删除部门"></a><strong>2.删除部门</strong></h5><p><strong>3.新增部门</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411193105943.png" alt="image-20240411193105943" style="zoom: 33%;" /> <p>优化:我们可以将公共的路径  抽取到注解中 @RequestMapping(“公共路径”)</p><p>一个完整的请求路径应该是类上的@RequestMapping的value属性加上方法上的@RequestMapping的value属性</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411202416778.png" alt="image-20240411202416778" style="zoom: 67%;" /><h4 id="员工管理功能开发"><a href="#员工管理功能开发" class="headerlink" title="员工管理功能开发"></a>员工管理功能开发</h4><h4 id="1-分页查询"><a href="#1-分页查询" class="headerlink" title="1.分页查询"></a><strong>1.分页查询</strong></h4><p>分页查询的语法  参数1 起始索引&#x3D;(页码-1)*每页展示记录数   参数2 查询返回记录数&#x3D;每页展示记录数</p><p>例: select * from emp limit 0,5;</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411221224905.png" alt="image-20240411221224905" style="zoom:50%;" /><p>分页查询返回的结果是两个,所以要定义实体类来封装返回的结果 ,实体类为pageBean</p><p>分页查询的流程:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240411221652800.png" alt="image-20240411221652800" style="zoom: 50%;" /> <p>@RequestParam 设置默认值</p><p><strong>原始方式:</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412090556005.png" alt="image-20240412090556005" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412090624975.png" alt="image-20240412090624975" style="zoom: 67%;" /></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412090724557.png" alt="image-20240412090724557" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412090749382.png" alt="image-20240412090749382" style="zoom: 50%;" /> <p><strong>分页查询插件PageHelper</strong></p><p>设置分页参数:PageHelper.startPage(page,pageSize);   使用要要引入对应的依赖:</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412091902018.png" alt="image-20240412091902018" style="zoom: 80%;"  /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412091949220.png" alt="image-20240412091949220" style="zoom:67%;" /></p><p>总结:<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412100206725.png" alt="image-20240412100206725" style="zoom: 50%;" /></p><h4 id="2-条件分页查询"><a href="#2-条件分页查询" class="headerlink" title="2.条件分页查询"></a>2.条件分页查询</h4><p>思路:</p><p>在controller中接收分页参数和查询的条件,在service进行条件查询时,只需要把这些参数传递给service就行,service在调用mapper接口的时候再将四个参数传递给mapper接口,最终在执行查询时根据传递进来的几个参数进行查询就可以了.</p> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412105521687.png" alt="image-20240412105521687" style="zoom:50%;" /><p>就是多传递了四个参数</p><p>条件分页查询:动态sql-xml映射文件</p><p>分页查询:PageHelper分页插件</p><h4 id="3-删除员工"><a href="#3-删除员工" class="headerlink" title="3.删除员工"></a><strong>3.删除员工</strong></h4><p>只需要开发一个批量删除的接口</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412143314776.png" alt="image-20240412143314776" style="zoom: 50%;" /> <h4 id="4-新增员工"><a href="#4-新增员工" class="headerlink" title="4.新增员工"></a><strong>4.新增员工</strong></h4><p>思路:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412152245121.png" alt="image-20240412152245121" style="zoom:67%;" /> <p>其中这个EmpService中补充基础属性  是 补充createtime和updateTime</p><h4 id="5-修改员工信息"><a href="#5-修改员工信息" class="headerlink" title="5.修改员工信息"></a>5.修改员工信息</h4><ol><li>查询回显</li></ol><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240412230216771.png" alt="image-20240412230216771"></p><p>2.修改员工(根据id更新员工)</p><h2 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h2><p><strong>文件上传:将本地的图片视频文件上传到服务器,供其他用户浏览或者下载的过程</strong></p><p><strong>本地存储</strong>:将我们上传的文件全部存储在服务器本地的磁盘目录当中(很少用)</p><p>阿里云对象存储oss，是一个云存储服务，使用oss，可以通过网络随时存储和调用包括文本、图片、音频、视频等在内的各种文件。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240328161341949.png" alt="image-20240328161341949" style="zoom: 80%;" /> <p>文件上传服务端接收文件(MultipartFile)         springboot中的api</p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传:"></a>文件上传:</h4><p>1.引入阿里云oss上传文件工具类</p><p>2.上传图片接口开发</p><h3 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a><strong>yml配置文件</strong></h3><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240329160509424.png" alt="image-20240329160509424" style="zoom:67%;" /> <p><strong>工作中我们基本选择yml类型的配置文件.</strong></p><h4 id="ConfigurationProperties与-value"><a href="#ConfigurationProperties与-value" class="headerlink" title="@ConfigurationProperties与@value"></a>@ConfigurationProperties与@value</h4><p>相同点：都是用来注入外部配置的属性的</p><p>不同点：@value注解只能一个一个的进行外部属性的注入</p><p>@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。</p><h3 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h3><p>通过统一拦截的技术来拦截浏览器发来的所有请求，对请求进行校验。通过检验是否有登录标记。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240707222847433.png" alt="image-20240707222847433"> </p><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a><strong>会话技术</strong></h3><p>会话：浏览器与服务器的连接    用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以<strong>包含多次请求和响应</strong>。</p><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来源于同一浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong>。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524151943152.png" alt="image-20240524151943152" style="zoom:33%;" /> <p>会话跟踪方案：</p><p>客户端会话跟踪技术：Cookie</p><p>服务端会话跟踪技术：Session</p><p>令牌技术</p><p>**cookie:**存储在客户端浏览器的,在浏览器第一次发起请求的时候,请求完成之后会设置一个cookie,在cookie中存储一些相关的数据信息(比如用户名,用户id),服务端将数据响应给客户端的时候,也会将cookie响应给浏览器,浏览器会将cookie存储在本地.在后续浏览器发起的每次请求都会将存储cookie自动携带到服务器,判断该cookie是否存在,存在的话即可在同一次会话的不同请求之间共享数据.</p><p>优点:HTTP协议中支持的技术</p><p>缺点:</p><p>移动端App无法使用Cookie</p><p>不安全,用户可以自己禁用</p><p>不能实现跨域(只要协议、域名、端口号不同就算跨域)</p><p><strong>session</strong>：存储在服务器端的，底层就是cookie来实现的。</p><p>​        浏览器向服务器第一次发起请求的时候，服务器会自动创建一个session，每一个session都有一个session id，服务器端再给浏览器响应数据的时候，会将session id通过cookie响应给浏览器，cookie的名字就叫jsessionid浏览器会将cookie存储在本地，在后续的请求中，会将cookie中数据获取出来携带到服务端，服务器拿到这个值也就是session id，会从众多的session中找到当前请求的会话对象。</p><p><strong>优点</strong>：存储在服务端，安全</p><p><strong>缺点</strong>： 在服务器集群的环境下无法直接使用</p><p><strong>负载均衡：就是个分发命令的中间人</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240524160226183.png" alt="image-20240524160226183" style="zoom: 67%;" /> <p><strong>JWT令牌技术：</strong>其实本质是个字符串，在浏览器发起请求，在请求成功的时候会生成一个令牌，可以理解成身份证，在响应数据的时候，将令牌直接响应给前端，可以将令牌存储在cookie中也可以存储在其他存储空间中，在后续请求中都将令牌携带到服务端，校验令牌的有效性，有效的话说明用户已经登录过，无效的话说明用户并未执行过登录操作。如果在同一次会话的不同请求之间共享数据的话，将共享的数据存储在令牌当中。</p><p>优点：</p><p>支持pc端、移动端</p><p>解决集群环境下的认证问题（因为在服务端不需要存储任何的数据）</p><p>减轻服务器端存储压力</p><p>缺点：</p><p>需要自己实现：怎么生成令牌？怎么将令牌存储到客户端浏览器，以及怎么将令牌携带到服务端</p><p>实际开发的过程中，也需要前端人员配合来实现</p><h4 id="会话跟踪方案对比"><a href="#会话跟踪方案对比" class="headerlink" title="会话跟踪方案对比"></a><strong>会话跟踪方案对比</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240401134520560.png" alt="image-20240401134520560"  /> <h2 id="jwT令牌"><a href="#jwT令牌" class="headerlink" title="jwT令牌"></a><strong>jwT</strong>令牌</h2><p>就是个字符串,由三个部分组成  head头部:记录令牌类型、签名算法等</p><p>​                                                    payload(有效载荷): 携带一些自定义信息、默认信息等</p><p>​                                                     signature(签名) : 防止token被篡改、确保安全性         理解成身份证</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240401140117663.png" alt="image-20240401140117663" style="zoom: 67%;" /> <h4 id="jwt令牌的生成"><a href="#jwt令牌的生成" class="headerlink" title="jwt令牌的生成"></a>jwt令牌的生成</h4><p>引入对应的依赖，引入jwt令牌操作工具类，登陆完成后，调用工具类生成jwt令牌，并返回。</p><h4 id="fliter过滤器快速入门"><a href="#fliter过滤器快速入门" class="headerlink" title="fliter过滤器快速入门"></a><strong>fliter</strong>过滤器快速入门</h4><p>Filter过滤器是javaweb三大组件Servlet、Filter、Listen（监听器）之一</p><p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能</p><p>过滤器一般完成一些通用的操作：登录校验、统一编码处理、敏感字符处理等</p><p>1.定义Fliter：定义一个类，实现filter接口，并重写其所有方法</p><p>2.配置Fliter：Fliter类加上@webFliter注解，配置拦截资源的路径。引导类加上@ServletComponentScan开启Servlet组件支持。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240414212518425.png" alt="image-20240414212518425" style="zoom:50%;" /> <p>执行流程：浏览器发起请求，过滤器进行拦截，执行放行前的逻辑，然后放行执行对应的web资源，执行完后返回过滤器执行放行后的逻辑。</p><p><strong>登录校验的逻辑：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240708100205657.png" alt="image-20240708100205657" style="zoom:50%;" /> <p><strong>过滤器链</strong></p><p>在一个web应用中，可以配置多个过滤器，这个过滤器就形成了一个<strong>过滤器链</strong></p><h4 id="interceptor拦截器入门"><a href="#interceptor拦截器入门" class="headerlink" title="interceptor拦截器入门"></a>interceptor拦截器入门</h4><p><strong>拦截器：</strong>是一种动态拦截方法调用的机制，类似于过滤器。<strong>spring框架中提供的</strong>，用来动态拦截控制器方法的执行</p><p>作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码</p><p><strong>拦截器使用步骤</strong></p><p>1.定义拦截器，定义一个类实现Handlerinterceptior接口，并重写所有方法</p><p>2.注册配置拦截器，定义一个配置类，实现接口WebMvcConfigurer，重写方法，指定拦截路径。在类上面加上注解@Configuration，标识当前是spring中的一个</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240708100939507.png" alt="image-20240708100939507" style="zoom: 50%;" />配置类</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240414213802992.png" alt="image-20240414213802992" style="zoom: 50%;" /> <p><strong>过滤器Filter和拦截器Interceptor的区别</strong> </p><p>接口规范不同：过滤器需要实现Filter，而拦截器需要实现HandlerInterceptor接口</p><p>拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源</p><p>过滤器和拦截器使用其中一个就行</p><h4 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a><strong>全局异常处理器</strong></h4><p>@RestControllerAdvice</p><p>@ExceptionHandler</p><h1 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h1><p><strong>获取bean</strong></p><p>默认情况下，Spring项目启动时，会把bean都创建好放在ioc容器中，如果想要主动获取这些bean，可以通过以下方式：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415152954164.png" alt="image-20240415152954164" style="zoom:50%;" /> <h4 id="bean作用域"><a href="#bean作用域" class="headerlink" title="bean作用域"></a><strong>bean作用域</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240415155454938.png" alt="image-20240415155454938" style="zoom:67%;" /> <p><strong>第三方bean</strong></p><p>可以通过@Scope注解来进行配置作用域</p><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component及衍生注解声明bean 的，就需要用到@bean注解</p><p><strong>@Component及衍生注解与@Bean注解使用场景:</strong></p><p>项目中自定义的,使用@Component及其衍生注解</p><p>项目中引入第三方的,使用@Bean注解</p><h1 id="Web后端开发总结"><a href="#Web后端开发总结" class="headerlink" title="Web后端开发总结"></a>Web后端开发总结</h1><p>web后端开发基本上基于标准的三层架构进行开发的：Controller—-Service—-Dao</p><p>Controller（控制器层）：负责接收请求，响应数据</p><p>Service（业务层）：具体的业务逻辑处理</p><p>Dao（数据访问层也叫持久层）：数据访问操作来完成数据库的增删改查操作</p><p><strong>总体流程：</strong>前端发起请求会到达Controller层然后，controller层调用Service进行逻辑处理，Service再调用Dao完成数据访问操作。</p><p>如果在执行具体的业务处理之前，做一些通用的业务处理，比如统一的登录校验、字符编码等 可以借助于javaweb中三大组件之一的<strong>过滤器Filter</strong>或者spring中提供的拦截器<strong>interceptor</strong>来实现。为了实现三层架构，层与层之间的解耦，学习了spring框架当中的<strong>第一大核心IOC控制反转</strong>与DI依赖注入。</p><p>ioc控制反转：将对象创建的控制权由应用程序自身交给外部容器，该容器就是ioc容器或spring容器，声明为spring容器中的bean对象。</p><p>DI：指的是容器为程序提供运行时所需要的资源，即依赖注入。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240404190844344.png" alt="image-20240404190844344"></p><p>·</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240404193309202.png" alt="image-20240404193309202"></p><p>ssm框架：SpringMvc、Springframework、Mybatis</p><p>SpringBoot：是为了简化spring框架开发的</p><p>Mybatis：是个持久层的框架，用来操作数据库的</p><p>spring框架：<br>springframework简称为spring，有很多开发模块。</p><p>springmvc就是spring框架的web开发模块。</p><p>springmvc+springframework+mybatis就是俗称SSM。</p><p>springboot整合了ssm，简化了开发。</p><p>application.properties和pom文件：</p><p>application.properties是用于配置Springboot应用程序的各种属性和参数，例如数据库连接信息、日志级别、端口号等。</p><p>springboot在启动时会自动加载并读取这些配置。</p><p>pom文件：</p><p>是Maven项目的核心配置文件，用于描述项目的依赖关系、构建配置、插件配置等。</p><p>定义了Maven项目的基本信息、项目构建的生命周期和阶段、依赖管理等。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>@RestController  作为请求处理类</p><p>@RequestMapping   作为请求路径：getMapping、postMapping。。。。。</p><p>@requestbody 将方法返回值中的对象以json的格式返回给前端。前端传递过来的json参数，后端可以通过实体类来接收，但需要在实体类前面加上注解。将json格式的数据封装到实体类当中。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240706001451559.png" alt="image-20240706001451559"> </p><p>@pathvariable 是接受参数路径的</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240705164819098.png" alt="image-20240705164819098"> </p><p>@RequestMapping  抽取公共路径的。将前面一样的路径给抽取出来，后面不需要再写。完整的请求路径就是类上的@RequestMapping的value属性+方法上的@RequestMapping的value属性</p><p>@RequestParam 用来设置默认值的，如果前端没传递这个参数，就设置一个默认值。</p><p>@DateTimeFormat 指定前端传递的日期类型的格式</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240706142052854.png" alt="image-20240706142052854"> </p><p>@component 将类交给ioc容器管理.</p><p>@Data给类提供对应的get、set方法 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-JavaSE/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-JavaSE/</url>
      
        <content type="html"><![CDATA[<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>区分成员变量和局部变量</p><p>例如:public void set Name(string name){</p><p>this.name&#x3D;name;}</p><p>将测试类调用方法传递过来的name值(局部变量),赋值给成员变量中的name. this表示成员变量的name</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>作用:创建对象的时候,虚拟机自动调用构造方法,给成员变量进行初始化的</p><p>构造方法有两种:无参构造:初始化对象时,成员变量均采用默认值</p><p>​                             有参构造:初始化对象时,同时可以给对象赋值</p><p>快捷键：Alt+insert。</p><h2 id="标准Java-Bean类"><a href="#标准Java-Bean类" class="headerlink" title="标准Java Bean类"></a>标准Java Bean类</h2><p>1.类名见名知意</p><p>2.成员变量使用private修饰</p><p>3.提供至少两个构造方法:无参构造,带全部参数的构造方法</p><p>4.成员方法:提供每个成员变量对应的set&#x2F;get</p><p>在 Java 中，当你尝试打印一个对象，如使用 <code>System.out.println(s);</code> 时，Java 实际上是调用该对象的 <code>toString()</code> 方法。默认情况下，对象的 <code>toString()</code> 方法被定义在 Java 的 <code>Object</code> 类中，它返回对象的类名和哈希码的无符号十六进制表示，这看起来像是一个地址值，但实际上是对象的哈希码。</p><p>要打印出 <code>Student</code> 对象实际存储的内容，例如姓名和年龄，你需要在 <code>Student</code> 类中重写 <code>toString()</code> 方法，以返回更有意义的信息</p><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228195254909.png" alt="image-20240228195254909" style="zoom:50%;" /><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java<strong>内存分配</strong></h2><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228195903536.png" alt="image-20240228195903536" style="zoom: 67%;" /><p>只要new出来的一定在堆里面开辟了一个小空间，如果new了多次，那么堆里有多个小空间，每个小空间都有各自的数据。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型可以增强代码的可读性 和稳定性。</p><p>&lt;&gt; 泛型中不能写基本数据类型</p><p>指定范型的具体类型后，传递数据时，可以传入该类类型或者其子类类型</p><p>如果不写泛型，类型默认是Object</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><em>数组</em></h2><p>格式：数据类型[] 数组名  或 数据类型 数组名[]           例 ： int [] array&#x3D;new 数据类型[]{};</p><p>简写格式： int array[]&#x3D;{11，22，33}；</p><p>数组的遍历方式： 数组名.for i</p><p>最大索引：数组的长度减1</p><p>可以存基本数据类型和引用数据类型</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><p>只能存引用数据类型或者把基本数据类型变成<strong>包装类</strong> </p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228204339257.png" alt="image-20240228204339257" style="zoom: 50%;" /><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228203946281.png" alt="image-20240228203946281" style="zoom: 50%;" /></p><p>格式 Arraylist&lt;&gt;  list &#x3D; new Arraylist&lt;&gt;();    &lt;&gt;是泛型 ：限定集合中存储数据的类型 </p><p>返回值要有变量去接收。</p><h2 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a><strong>集合体系结构</strong></h2><p>单列集合 collection ：一次存放一个数据        双列集合 Map：一次添加一对数据         红色是接口  蓝色：实现类<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228211247494.png" alt="image-20240228211247494" style="zoom:50%;" /></p><p>collection中常见方法：</p><p>public boolean add（E e） 给定的对象添加到当前集合中</p><p>public void clear（）            清空集合中所有的元素</p><p>public boolean remove（E e）把给定的对象在当前集合中删除</p><p>public boolean contains（object obj）判断当前集合中是否包含给定的对象</p><p>public boolean isEmpty（）       判断当前集合是否为空</p><p>public int size（）                    返回集合中元素的个数&#x2F;集合的长度 </p><h5 id="Collection的遍历方式：迭代器遍历-、增强for遍历、Lambda表达式遍历"><a href="#Collection的遍历方式：迭代器遍历-、增强for遍历、Lambda表达式遍历" class="headerlink" title="Collection的遍历方式：迭代器遍历 、增强for遍历、Lambda表达式遍历"></a><strong>Collection的遍历方式：</strong>迭代器遍历 、增强for遍历、Lambda表达式遍历</h5><p>迭代器：在遍历的过程中需要删除元素，请使用迭代器</p><p>增强for、Lambda：仅仅想遍历，那么使用增强for或Lambda表达式</p><p><strong>迭代器遍历</strong>：<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228215108607.png" alt="image-20240228215108607" style="zoom: 50%;" /></p><p>​          获取迭代器对象：<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228220058733.png" alt="image-20240228220058733"  /> coll是集合名称，调用iterator方法获取迭代器对象， it是迭代器名称，好比一个指针指向0索引处</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228223332259.png" alt="image-20240228223332259" style="zoom: 67%;" /><p><strong>增强for遍历</strong>：</p><p>增强for的底层就是迭代器，为了简化迭代器的代码书写，jdk5之后出现，内部原理是一个Iterator迭代器</p><p>所有的单列集合和数组才能使用增强for遍历</p><p>格式：for（元素的数据类型 变量名：数据或者集合）{}                     例：      for（string s ：list）{ sout（s）}其中s就表示第三方变量，在循环过程中依次表示集合中的每一个数据。</p><p>快捷方式：集合名.for</p><h4 id="lambda："><a href="#lambda：" class="headerlink" title="lambda："></a><strong>lambda：</strong></h4><p><strong>作用：1.简化匿名内部类的缩写</strong>，不能用在其他地方</p><p>​             <strong>2.只能简化函数式接口的匿名内部类的写法。</strong></p><p><strong>函数式接口</strong>：</p><p>   有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@Functionallnterface注解验证</p><p><strong>Lambda的省略规则：</strong></p><p>1.参数类型可以省略不写</p><p>2.如果只有一个参数的话，参数类型可以省略，同时（）也可以省略</p><p>3.如果Lambda表达式的方法体只要一行，大括号，分号，return可以省略不写，需要同时省略。</p><p>​        </p><p>格式：（）-&gt;{ }       </p><p>（）对应着方法的形参，-&gt;固定格式    {}对应着方法的方法体</p><p>  调用lambda：集合名.forEach（new Consumer）{}</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240520143011360.png" alt="image-20240520143011360" style="zoom:50%;" /> <p>使用lambda表达式改写：</p><p>只留下方法的形参和方法体，中间加一个箭头。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240520143023108.png" alt="image-20240520143023108" style="zoom:50%;" /><p><strong>函数式编程：</strong></p><p>函数式编程是一种思想特点。</p><p>函数式编程思想，忽略面向对象的复杂语法，强调做什么，而不是谁去做。</p><p>Lambda表达式就是函数时思想的体现。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229102621020.png" alt="image-20240229102621020" style="zoom:50%;" />函数就是方法</p><p>集合的lambda表达式：<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229151720014.png" alt="image-20240229151720014" style="zoom: 80%;" />小括号中写匿名内部类的形式，然后再改成lambda形式</p><p><strong>list五种遍历方式对比：</strong></p><p>迭代器遍历：在遍历的过程中需要删除元素，使用迭代器遍历</p><p>列表迭代器：在遍历的过程中需要添加元素，使用列表迭代器</p><p>增强for遍历，lambda表达式：仅仅想遍历</p><h4 id="LinkedList："><a href="#LinkedList：" class="headerlink" title="LinkedList："></a>LinkedList：</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240229165016283.png" alt="image-20240229165016283" style="zoom:50%;" /><h3 id="set系列集合"><a href="#set系列集合" class="headerlink" title="set系列集合"></a>set系列集合</h3><p>1.特点：无序、不重复、无索引     Set集合的方法基本与CollectionAPI一致</p><p>2.Set集合的实现类特点：</p><p>Hashet：无序、不重复、无索引</p><p>LinkedHashSet：有序、不重复、无索引</p><p>TreeSet：可排序、不重复、无索引</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h5><p>底层采用哈希表存储数据，哈希表是一种对于增删改查数据性能都较好的结构</p><p><strong>如果集合中存储的是自定义对象，必须要重写hascode和equals方法</strong></p><p>哈希表组成： jdk8之前：数组+链表  jdk8之后：数组+链表+红黑树 当链表长度超过8且数组长度大于64时，自动转换为红黑树</p><p>哈希值：1.对象的整数表现形式，根据hashCode方法算出来的int类型整数  2. 该方法定义在Object类中，所有的对象可以调用，默认使用地址值进行计算3.  一般情况下，会重写hashcode方法，利用对象内部属性值计算哈希值</p><p>特点：如果没有使用hashcode方法，不同对象计算出的哈希值是不同的，重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的。</p><p><strong>LinkedHashSet</strong></p><p>有序、不重复、无索引  底层基于哈希表，使用双链表记录添加顺序</p><p>如果要数据去重 默认使用HashSet，如果要求<strong>去重且存取有序</strong>，才使用LinkedHashSet</p><p><strong>TreeSet</strong></p><p>不重复、无索引、可排序</p><p>可排序：按照元素的默认规则（从小到大）排序</p><p>TreeSet集合底层是基于<strong>红黑树</strong>的数据结构实现的，增删改查性能 都较好</p><p>TreeSet默认规则：1.对于数值类型：integer Double，默认按照从小到大的顺序进行排序</p><p>​                                 2.对于字符、字符串类型：按照字符在ASCII码表中的数字升序进行排序</p><p>TreeSet的两种比较方式：1.默认排序javabean类实现comparable接口指定比较规则                 </p><p>​                                             2.比较器排序：创建TreeSet对象，传递比较器Comparator指定规则</p><p>​                                       （一般默认使用第一种，如果第一种不能满足当前需求，就使用第二种）</p><p>  方法返回值的特点：</p><p>负数：表示当前要添加的元素是小的，存左边</p><p>正数：表示当前要添加的元素是大的，存右边</p><p>0：表示当前要添加的元素已存在，舍弃</p><h3 id="集合使用场景"><a href="#集合使用场景" class="headerlink" title="集合使用场景"></a><strong>集合使用场景</strong></h3><p>1.想要集合中元素可重复  ：用Arraylist集合，基于数组的（用的最多）</p><p>2.想要集合中的元素可重复，而且当前的增删操作明显多于查询： 用LinkedList，基于链表的</p><p>3.如果相对集合中的元素去重： 使用HashSet，基于哈希表的（用的最多）</p><p>4.如果相对集合中的元素去重，且保证存取顺序：使用LinkedHashSet集合,基于哈希表和双链表,效率低于HashSet</p><p>5.如果想对集合中的元素进行排序: 用TreeSet集合,基于红黑树.后续也可以用List集合实现排序</p><h3 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h3><p>格式    Map&lt;键的类型,值的类型&gt;  对象名&#x3D;new HasMap&lt;&gt;();等号右边是实现类对象</p><p>1.双列集合一次需要存一对数据,分别为键和值                      2.键不能重复,值可以重复</p><p>3.键和值是一一对应的,每一个键只能找到自己对应的值           4.键加值这个总体,称为键值对,java中叫 Entry对象</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304091349223.png" alt="image-20240304091349223" style="zoom:50%;" /><p>put方法一个是添加一个是覆盖,  键存在,覆盖值,方法返回被覆盖的值,键不存在,添加值,方法返回null</p><h5 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h5><p>1.键找值</p><p>创建map集合对象,添加元素,获取所有的键,并放到一个单列集合当中,遍历单列集合得到每一个键,利用map集合中的键获取对应的值</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304101243683.png" alt="image-20240304101243683" style="zoom: 80%;" /><p>2.键值对</p><p>创建map集合对象,添加元素,通过键值对对象进行遍历,通过map.entrySet();获取所有的键值对对象,返回一个Set集合,遍历集合得到每一个键值对对象</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304100728807.png" alt="image-20240304100728807" style="zoom: 67%;" /><p>3.Lambda表达式</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304103359270.png" alt="image-20240304103359270" style="zoom:67%;" /><p><strong>HashMap</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304104802688.png" alt="image-20240304104802688" style="zoom: 50%;" /><p>1.HashMap是Map里面的一个实现类</p><p>2.直接使用Map里面的方法,特点都是由键决定的:无序、不重复、无索引</p><p>3.底层和HashSet底层原理一样，都是哈希表结构</p><p>4.依赖hashcode方法和equals方法保证键的唯一，如果存储自定义对象，不需要重写hashcode和equals方法</p><p><strong>LinkedHashMap</strong></p><p>由<strong>键</strong>决定:有序、有序、不重复  这里的有序是指保证存储和取出 的元素顺序一致</p><p>原理：底层数据结构依然是哈希表，只是每个键值对元素又额外的多了一个双链表的机制纪录存储的顺序</p><p><strong>TreeMap</strong></p><p>TreeMap跟TreeSet底层原理一样，都是红黑树结构的</p><p>由键决定特性：不重复、无索引、可排序  可排序指：对键进行排序，默认从小到大，也可以自己规定键的排序规则。代码书写两种排序规则：实现comparable接口，指定比较规则.创建集合时传递comparator比较器对象，指定比较规则。</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>1.方法的形参的个数是可以发生改变的  格式： 属性类型…名字  例：int…args  作用：形参中接收多个数据</p><p>2.底层就是一个数组，只不过不需要我们自己创建，java会帮我们创建好</p><p>3.在方法的形参中最多写一个可变参数，除了可变参数以外，还有其他参数，那么可变参数要写到最后</p><h4 id="collections："><a href="#collections：" class="headerlink" title="collections："></a><strong>collections：</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304181156191.png" alt="image-20240304181156191" style="zoom:50%;" /><h4 id="不可变集合："><a href="#不可变集合：" class="headerlink" title="不可变集合："></a><strong>不可变集合：</strong></h4><p>1.定义完成后不可以修改，或者添加、删除</p><p>2.list，set，map接口中，都存在of方法可以创建不可变集合</p><p>3.三种方法的细节： list 直接用       set 元素能重复       map 元素不能重复、键值对数量最多是10个超过10用ofentries方法</p><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>1.是个权限修饰符，修饰成员变量和成员方法</p><p>2.被修饰的成员只能在本类中访问  </p><p>3.提供set&#x2F;get（参数）方法，给成员变量赋值，用public修饰</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static表示静态,是Java 中的一个修饰符,可以修饰成员变量&#x2F;方法</p><p>特点:被该类所有对象<strong>共享</strong>   不属于对象,属于类**.随着类的加载而加载,优先于对象存在**</p><p>调用方式:类名调用,对象名调用</p><p>注意事项:</p><p> 1.<strong>静态方法中只能访问静态</strong>2.<strong>非静态方法可以访问所有</strong>3.<strong>静态方法中没有this关键字</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240227131825217.png" alt="image-20240227131825217" style="zoom: 50%;" /><h2 id="面向对象三大特征-封装、继承、多态"><a href="#面向对象三大特征-封装、继承、多态" class="headerlink" title="面向对象三大特征(封装、继承、多态)"></a>面向对象三大特征(封装、继承、多态)</h2><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>对象代表什么，就得封装对应的数据，提供数据对应的行为。（正确设计对象）</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以让类与类之间产子父的关系</p><p>可以把多个子类中重复的代码抽取到父类中,子类可以直接使用，减少代码冗余，提高代码的复用性</p><p><strong>继承的特点</strong>：</p><ol><li><p>Java只支持单继承：一个子类只能继承一个父类，不支持多继承，但支持多层继承：A继承B，B继承C</p></li><li><p>Java中所有的类都直接或者间接继承于object类</p></li></ol><p>3.子类中只能访问父类中非私有的成员</p><p><strong>继承格式</strong>：public class 子类 <strong>extends</strong>父类 {}</p><p>继承后子类的特点：</p><p>1.子类可以得到父类的属性和行为，子类可以使用 2.子类可以在父类的基础上新增其他功能，子类更加强大</p><p><strong>如何设计继承：</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240227144003988.png" alt="image-20240227144003988" style="zoom: 50%;" /><p><strong>继承的内存图</strong>：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240227151615964.png" alt="image-20240227151615964" style="zoom:50%;" /><p><strong>子类能继承父类中的哪些内容？</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240227160457148.png" alt="image-20240227160457148" style="zoom:50%;" /><p><strong>继承中成员变量访问的特点</strong>：this:就近原则 super:直接找父类</p><p>现在局部位置找，从奔本类成员位置找，父类成员位置找，逐级网上</p><p><strong>继承中构造方法的访问特点:</strong></p><p>子类不能集成父类的构造方法,但是可以通过super调用</p><p>子类构造方法的第一行,有一个默认的super();</p><p>默认先访问父类中无参的构造方法,在执行自己</p><p>如果想要访问父类有参构造,必须手动书写</p><p><strong>如果出现重名的成员变量怎么办？</strong></p><p>sout（name）：从局部位置找  sout（this.name）从本类成员位置网上找 sout(super.name)从父类位置往上找</p><p><strong>方法的重写</strong></p><p>当父类的方法不能满足子类现在的需求时,需要进行方法重写.书写格式:在继承体系中,子类出现了和父类一模一样的方法申明,我们就称子类这个方法是重写的方法.</p><p>重写的方法尽量和父类保持一致.  只有添加到虚方法表中的方法才能被重写.</p><p>重写的本质:覆盖虚方法表中的方法</p><p><strong>@Override 重写注解</strong></p><p>放在重写后的方法上,效验子类重写时语法是否正确</p><p>建议重写方法都加@Override注解,代码安全</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>多态:是对象的多种形态  创建对象的方式:  父类名  对象名  &#x3D;new 子类名();</p><p>实现多态的前提:有继承&#x2F;实现关系     有父类指向子类对象  有方法的重写</p><p>多态的好处: 使用父类类型作为参数,可以接受所有子类对象   体现多态的扩展性与遍历</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240227222603582.png" alt="image-20240227222603582" style="zoom: 50%;" /><h2 id="包、final、权限修饰符、代码块"><a href="#包、final、权限修饰符、代码块" class="headerlink" title="包、final、权限修饰符、代码块"></a><strong>包、final、权限修饰符、代码块</strong></h2><h3 id="包："><a href="#包：" class="headerlink" title="包："></a><strong>包</strong>：</h3><p>包就是文件夹，用来管理不同功能的java类</p><p>包书名写的规则：公司域名反写+包的作用，需要全部英文小写，见明知意</p><p>全类名：包名加类名</p><p>使用一个包中的类 、java.lang中的类 不需要导包</p><p>同时使用两个包中的同名类，需要用全类名。</p><h3 id="final："><a href="#final：" class="headerlink" title="final："></a><strong>final：</strong></h3><p>1.final修饰方法：最终方法，不能被重写</p><p>2.final修饰类：最终类，不能被继承</p><p>3.final修饰变量：是常量，不能被修改</p><p>​        基本应用数据类型：变量的值不能修改</p><p>​        引用数据类型：地址值不能修改，内部的属性值可以修改</p><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a><strong>权限修饰符</strong></h3><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240227233925664.png" alt="image-20240227233925664" style="zoom:50%;" /><p>权限修饰符使用规则：</p><p>实际开发中，一般只用private和public</p><p>成员变量私有，方法公开  </p><p>特例：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h3><p>静态代码块：数据的初始化（重点） 格式 ：static{}      随着类的加载而加载，并且自动触发、只执行一次</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>1.抽象类的作用：</p><p>抽取共性时，无法确定方法体，就把方法定义为抽象的。强制让子类按照某种格式重写</p><p>抽象方法所在的类，必须是抽象类</p><p>2.抽象类和抽象方法的格式：</p><p>public <strong>abstrac</strong>t 返回值类型 方法名（参数列表）；</p><p>public <strong>abstract</strong> class 类名{}</p><p>3.继承抽象类有哪些要注意的？</p><p><strong>一般重写抽象类中的所有抽象方法（最常用）</strong></p><p>要么是抽象类</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>接口就是一种规则，是对行为的抽象</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228112053892.png" alt="image-20240228112053892" style="zoom:50%;" /><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228115411678.png" alt="image-20240228115411678" style="zoom: 50%;" /></p><p>接口和类之间的关系：</p><p>类和类的关系：继承关系，只能单继承，不能多继承，但可以多层继承</p><p>类和接口的关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p>接口和接口关系：继承关系，可以单继承，也可以多继承</p><p><strong>jdk8开始接口中新增的方法：</strong></p><p>jdk7以前：接口只能定义抽象方法。jdk8的新特性：接口中可以定义有方法体的方法。（默认，静态）</p><p>jdk9的新特性：接口中可以定义私有方法：普通私有方法和静态私有方法</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类:"></a><strong>内部类:</strong></h2><p>类的五大成员:</p><p>属性、方法、构造方法、代码块、内部类</p><p>内部类：</p><p>在一个类的里面，再定义一个类。B类事物是A类的一部分，且B单独存在没有意义，比如汽车的发动机，人的心脏</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228154916040.png" alt="image-20240228154916040" style="zoom: 50%;" /><h4 id="重点掌握-匿名内部类："><a href="#重点掌握-匿名内部类：" class="headerlink" title="(重点掌握)匿名内部类："></a>(重点掌握)匿名内部类：</h4><p>一般用于lambda表达式，stream流等常用操作</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240228165539762.png" alt="image-20240228165539762" style="zoom: 50%;" /><p>4.使用场景：当这个方法的参数是接口或者类的时候，如果实现类只要使用一次，就可以使用匿名内部类简化代码：匿名内部类的整体是个对象。可以作为参数进行传递。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507113921875.png" alt="image-20240507113921875" style="zoom: 67%;" /><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507111129734.png" alt="image-20240507111129734"> </p><p><strong>紫色的内容是没有名字的类，Animal是个类，它们的关系是继承关系，如果Animal是个接口的话，那么它们就是实现关系。****new是创建没有名字的类的对象</strong></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507112017328.png" alt="image-20240507112017328"></p><p>这个整体其实不是一个类，而是new出来的一个对象，真正没有名字的类是{}中的内容，和new 后面的类名是继承关系，如果new后面是接口的话那就是实现关系。</p><hr><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>Object里面的clone是浅克隆</p><p><strong>引用拷贝：</strong>就是两个不同的引用指向同一个对象。</p><p><strong>浅拷贝</strong>：特点是直接拷贝，基本类型拷贝变量记录的数据值，引用类型拷贝变量的地址值</p><p>​                   <strong>不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来</strong></p><p><strong>深拷贝</strong>：<strong>基本数据类型拷贝过来，字符串类型会复用串池里面的，引用数据类型的话会创建新的空间。</strong></p><p>浅拷贝：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240514104224736.png" alt="image-20240514104224736" style="zoom:50%;" /><p>深拷贝：</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240514104323051.png" alt="image-20240514104323051" style="zoom:50%;" /><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>结合了Lambda表达式，简化集合、数组的 操作</p><p>Stream流的使用步骤：1.先得到一条stream流（流水线），并把数据放上去</p><p>​                                         2.使用中间方法对流水线上的数据进行操作</p><p>​                                          3.使用终结方法对流水线上的数据进行操作</p><p>1.<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304192536824.png" alt="image-20240304192536824" style="zoom:50%;" /></p><p>2.<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304194235242.png" alt="image-20240304194235242" style="zoom:50%;" /></p><p>3.<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304200642885.png" alt="image-20240304200642885" style="zoom:50%;" /></p><p>list.stream().map(new Function&lt;流里面数据类型,要变成的数据类型&gt;())</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>主要有三种:引用静态方法,成员方法,构造方法</p><p>1.把已经存在的方法拿过来用,当做函数式接口中抽象方法的方法体</p><p>2.符号     ::  是方法引用符</p><p>3.方法引用时需要注意: 1.需要有函数式接口  2.被引用方法必须已经存在 3.被引用方法的形参和返回值需要和抽象方法保持一致 4.被引用方法的功能要满足当前的需求</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240304220957575.png" alt="image-20240304220957575"  /><p><strong>引用静态方法:</strong></p><p>格式:      类名::静态方法   范例:Integer :: parseInt</p><p><strong>引用成员方法</strong></p><p>格式        对象::成员方法</p><p> 1.其他类      其他类对象::方法名</p><p>2.本类           this::方法名                  引用处不能是静态方法</p><p>3.父类             super::方法名              引用处不能是静态方法</p><p><strong>引用构造方法</strong></p><p>格式    类名::new    范例:     Student::new</p><p><strong>使用类名引用成员方法</strong></p><p>格式   类名::成员方法      范例 :    String:: substring</p><p><strong>引用数组的构造方法:</strong></p><p>格式        数据类型::new    范例:  int[]::new</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>程序中可能出现的问题</strong>   异常体系最上层父类是<strong>Exception</strong>   异常分为 <strong>编译时异常</strong>、<strong>运行时异常。</strong></p><p>RuntimeException：运行时期异常，其他：编译时期异常。一般是由参数传递错误导致的</p><p>编译时期异常：在编译阶段，必须要手动处理，否则代码报错</p><p><strong>异常作用</strong>：1.异常是用来查询bug的关键参考信息</p><p> 2.异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305150419789.png" alt="image-20240305150419789" style="zoom: 33%;" /><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305151739105.png" alt="image-20240305151739105" style="zoom: 33%;" /></p><p><strong>捕获异常的目的</strong>： 当代码出现异常时，可以让程序继续往下执行</p><p><strong>捕获的格式</strong></p><p>格式：  try{</p><p>可能出现异常的代码</p><p>}catch（异常类名 变量名）{</p><p>异常的处理代码</p><p>}</p><p><strong>1.如果try中没有遇到问题？</strong>  </p><p>  会把try中的所有代码全部执行完毕，不会执行catch中的代码</p><p><strong>2.如果try中可能遇到多个问题，怎么执行？</strong></p><p>会写多个catch与之对应，细节：捕获多个异常，这些异常中如果存在父子关系的话，那么父类一定要写在下面。</p><p><strong>3.如果try中遇到的问题没有被捕获，怎么执行？</strong></p><p>相当于try..catch白写，当前异常会交给虚拟机处理</p><p><strong>4.如果try中遇到问题，那么try下面的其他代码会执行么？</strong></p><p>不会执行，直接跳转到对应的catch 如果没有对应的catch匹配，则交给虚拟机处理</p><p><strong>Throwable的常见成员方法：</strong></p><p>public String getMessage() :返回异常的简短描述    例如返回索引越界</p><p>public String toString():返回异常发生时的详细信息  例如返回索引越界的描述和对应的异常类</p><p>public void printStackTrace(): 把异常的信息输出在控制台，打印的信息包含了 toString里面的内容，增加了异常所在的位置。细节：只是打印信息，不会停止程序运行。</p><p><strong>抛出处理</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305164323516.png" alt="image-20240305164323516" style="zoom: 33%;" /><p>抛出处理：写在方法的定义处，表示声明一个异常，告诉调用者，使用本方法可能会有哪些异常     <strong>运行时异常可以不写，但是编译时期异常一定要写</strong></p><p><strong>异常总结：</strong></p><p>1.虚拟机默认处理异常的方式</p><p>把异常的信息以红色字体打印在控制台，并结束程序</p><p>2.捕获：try…catch      ：不让程序停止</p><p>一般用在调用处，让代码继续向下运行</p><p>3.抛出:throw throws    ： 告诉调用者出错了</p><p>在方法中出现异常了。方法就没有继续运行下去的意义了，采取抛出处理</p><p>也让该方法结束运行并告诉调用者出现了问题。</p><p>  <strong>自定义异常</strong>： 意义就是让控制台的报错更加的见名知意</p><p>1.定义异常类 2.写继承关系 3. 空参构造 4.带参构造   意义：为了让控制台的报错信息见名知意</p><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>file对象表示一个路径，可以是文件的路径、也可以是文件夹的路径</p><p>这个路径可以是存在的，也可以是不存在的</p><p>绝对路径和相对路径：绝对路径是带盘符的，相对路径是不带盘符的，默认到当前项目下找</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305174453983.png" alt="image-20240305174453983" style="zoom: 50%;" /><p><strong>listFiles（）  获取当前路径下所有内容，把所有内容放到数组中进行返回</strong>****</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305204621899.png" alt="image-20240305204621899" style="zoom: 33%;" /><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>  存储和读取数据的解决方案  用于读写文件中的数据（读写文件或网络中的数据）</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305210204778.png" alt="image-20240305210204778" style="zoom:50%;" /><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><strong>FileOutputStream</strong></h4><p>操作本地文件的字节输出流，可以把程序中的数据写到本地文件中，是字节流的基本流</p><p>换行符： &#x2F;r&#x2F;n             </p><p><strong>步骤：1.创建字节输出流对象</strong></p><p>参数是字符串表示的路径或者File对象都是可以的</p><p>如果文件不存在会创建一个新的文件，但要保证父级路径是存在的</p><p>如果文件已经存在，则会清空文件</p><p>​              <strong>2.写数据</strong> </p><p>write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCll上对应的字符</p><p>​               <em><strong>3.释放资源</strong></em>*</p><p>每次使用完之后都要释放资源</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240305215313270.png" alt="image-20240305215313270" style="zoom:50%;" /><h4 id="FileputStream"><a href="#FileputStream" class="headerlink" title="FileputStream"></a>FileputStream</h4><p>操作本地文件的字节输入流,可以把本地文件中的数据读取到程序中来</p><p>操作步骤:</p><p><strong>1.创建字节输入流对象</strong></p><p>如果文件不存在,就直接报错</p><p><strong>2.读数据</strong></p><p>一次读一个字节,读出来的是数据在ASCll上对应的数字</p><p>读到文件末尾,read方法返回-1</p><p><strong>3.释放资源</strong></p><p>每次使用完必须要释放资源</p><h5 id="FileputStream循环读取"><a href="#FileputStream循环读取" class="headerlink" title="FileputStream循环读取"></a>FileputStream循环读取</h5><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306093239819.png" alt="image-20240306093239819" style="zoom:50%;" /><p><strong>字符集</strong></p><p>计算机存储规则:</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306104532994.png" alt="image-20240306104532994" style="zoom: 33%;" /><p><strong>乱码原因</strong></p><p>1.读取数据时未读完整个汉字</p><p>2.编码和解码时的方式不统一</p><p><strong>字符流</strong></p><p>字符流的底层就是字节流   字符流&#x3D;字节流+字符流</p><p>输入流:一次读一个字节,遇到中文时,一次读多个字节</p><p>输出流:底层会把数据按照制定的编码方式进行编码,变成字节再写到文件中</p><p>用于纯文本文件进行读写操作</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306111051718.png" alt="image-20240306111051718" style="zoom: 33%;" /><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程:"></a>多线程:</h1><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程</strong>和线程</h4><p><strong>进程</strong>是程序的基本执行实体</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位.它被包含在进程之中,是进程中的实际运作单位.</p><p>简单理解:应用软件中互相独立,可以同时运行的功能(例如运行360软件是个<strong>进程</strong>,运行360中的木马查杀、电脑清理功能就是<strong>线程</strong>)</p><p><strong>什么是多线程</strong>:有了多线程,我们可以让程序同时做多件事情</p><p>**多线程作用:**提高效率</p><p>多线程的应用场景:  想让多个事情同时运行就需要用到多线程</p><p>​                                 软件中的耗时操作、所有的聊天软件、所有的服务器</p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a><strong>并发和并行</strong></h4><p>并发:在同一时刻,有多个指令在<strong>单个</strong>cpu上<strong>交替</strong>执行</p><p>并行:在同一时刻,有多个指令在<strong>多个</strong>cpu上同时执行</p><h4 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a><strong>多线程的实现方式</strong></h4><p>重写方法步骤</p><p>1.循环  2.同步代码块 3. 判断共享数据是否到了末尾(到了末尾)</p><p>4.判断共享数据是否到了末尾(没到末尾,执行核心逻辑)</p><p><strong>1.继承Thread类的方式进行实现</strong></p><p>1.自己定义一个类继承Thread 2.重写run方法  3. 创建子类对象 并启动线程</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306164221324.png" alt="image-20240306164221324" style="zoom: 80%;" /><p><strong>2.实现Runnable接口的方式进行实现</strong></p><p>1.自己定义一个类实现Runnable接口 2.重写里面的run方法 3.创建自己类的对象 4.创建一个Thread类的对象,并开启线程</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306164139149.png" alt="image-20240306164139149" style="zoom: 80%;" /> <p><strong>3.利用Callable接口和FutureTask方式实现</strong></p><ol><li><p>自己定义一个类实现Callable接口</p></li><li><p>重写call(是有返回值的,表示多线程运行的结果)*</p></li><li><p>创建自己类的对象(表示多线程要执行的任务)</p></li><li><p>创建FutureTask的对象(作用管理多线程运行的结果)</p></li><li><p>创建Thread类的对象,并启动(表示线程)</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306165948331.png" alt="image-20240306165948331" style="zoom: 80%;" /> <p><strong>4.通过线程池来创建</strong></p></li></ol><h4 id="多线程三种实现方法对比"><a href="#多线程三种实现方法对比" class="headerlink" title="多线程三种实现方法对比"></a>多线程三种实现方法对比</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306170249124.png" alt="image-20240306170249124" style="zoom:67%;" /> <p>常见的成员方法</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306190036031.png" alt="image-20240306190036031" style="zoom: 50%;" /> <p>当jvm虚拟机启动之后,会自动的启动多条线程,其中有一条线程叫做main线程</p><p>他的作用就是去调用main方法,并执行里面的代码,在以前,我们写的所有代码,其实都是运行main线程当中</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级:"></a><strong>线程优先级</strong>:</h4><p>分为  抢占式调度 (随机性)和非抢占式调度  优先级分为1-10个级别</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程:"></a><strong>守护线程:</strong></h4><p>当其他的非守护线程执行完毕之后,守护线程也会陆续结束 </p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期:"></a><strong>线程的生命周期</strong>:</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240506220024843.png" alt="image-20240506220024843" style="zoom: 67%;" /> <h4 id="线程的安全问题"><a href="#线程的安全问题" class="headerlink" title="线程的安全问题:"></a>线程的安全问题:</h4><p>当多线程执行的时候会出现线程安全问题.</p><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>将一段代码锁起来</p><p><strong>把操作共享数据的代码锁起来</strong>  </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240506223933965.png" alt="image-20240506223933965" style="zoom:67%;" /> <p>synchronized的<strong>锁对象</strong>一定要是<strong>唯一</strong>的,一般是当前类的字节码文件</p><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a><strong>同步方法</strong></h4><p>就是把synchronized关键字加到方法上</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240506233717715.png" alt="image-20240506233717715" style="zoom: 67%;" />**** </p><p><strong><strong><strong><strong>(面试高频考点)StringBuilder和StringBuffer的区别:</strong></strong></strong></strong></p><p>如果代码是单线程的不需要考虑多线程情况就使用StringBuilder</p><p>如果是多线程的环境下需要考虑到数据的安全的话就使用StringBuffer</p><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a><strong>Lock锁</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507000357009.png" alt="image-20240507000357009" style="zoom:67%;" /> <h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>写代码不要让两个锁嵌套起来</p><h4 id="生产者和消费者-等待唤醒机制"><a href="#生产者和消费者-等待唤醒机制" class="headerlink" title="生产者和消费者(等待唤醒机制)"></a><strong>生产者和消费者</strong>(等待唤醒机制)</h4><p>生产者消费者模式是一个非常经典的多线程协作的模式</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507004134440.png" alt="image-20240507004134440" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306211312361.png" alt="image-20240306211312361" style="zoom: 50%;" /> <h4 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a><strong>线程的六种状态</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306213645844.png" alt="image-20240306213645844" style="zoom: 50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507005621078.png" alt="image-20240507005621078" style="zoom:67%;" /> <h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>以前写多线程的弊端:1.用到线程的时候就创建2.用完之后线程消失.  浪费操作系统的资源</p><p>线程池类：ThreadPoolExecutor</p><p><strong>线程池代码实现:</strong></p><p>1.创建线程池</p><p>2.提交任务</p><p>3.所有任务全部执行完毕,关闭线程池(一般不会关闭)</p><p>Executors:线程池的工具类通过调用方法返回不同类型的线程池对象.</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507012926282.png" alt="image-20240507012926282" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306214657577.png" alt="image-20240306214657577" style="zoom: 33%;" /> <h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池:"></a>自定义线程池:</h4><p>当核心线程在忙,并且队伍当中排满了任务,此时才会创建临时线程 </p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507095814282.png" alt="image-20240507095814282" style="zoom:50%;" /> <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240507095900451.png" alt="image-20240507095900451" style="zoom:67%;" /> <h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>CS:client&#x2F;serve 客户端&#x2F;服务器      B&#x2F;S :Broswer&#x2F;Server 浏览器&#x2F;服务器</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240306220821942.png" alt="image-20240306220821942" style="zoom:50%;" /><p><strong>网络编程三要素</strong></p><p>ip:设备在网络中的地址,是唯一的标识</p><p>端口号:应用程序在设备中唯一的标识</p><p>应用程序在设备中唯一的标识   由两个字节表示的整数,取值范围0~65535</p><p>协议:数据在网络中传输的规则,常见的协议有UDP,TCP,http,https,ftp    </p><p>计算机网络中,    连接和通信的规则被称为网络通信协议</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307090258613.png" alt="image-20240307090258613" style="zoom:50%;" /><p><strong>UDP协议</strong></p><p>用户数据报协议(User Datagram Protocol)</p><p>UDP是<strong>面向无连接</strong>的通信协议,速度快,有大小限制一次最多发送6k,数据不安全,易丢失数据</p><p>发送数据步骤:1.创建发送端的DatagramSocket对象 2.数据打包3.发送数据 4.释放资源</p><p>接受数据步骤:创建接受端的DatagramSocket对象2.接受打包好的数据3.解析数据包 4.释放资源</p><p>upp三种通信方式:单播,组播,广播</p><p><strong>TCP协议</strong></p><p>传输控制协议TCP(Transmission Control Protocol)</p><p>TCP协议是面向连接的通信协议,速度慢,没有大小限制,数据安全</p><h3 id="反射（重点）"><a href="#反射（重点）" class="headerlink" title="反射（重点）"></a>反射（重点）</h3><h4 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h4><p>反射允许对类的成员变量,成员方法和构造方法的信息进行编程访问</p><p>简单理解：反射就是可以从类里面拿东西：成员变量、成员方法、构造方法</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240515145745584.png" alt="image-20240515145745584"></p><h4 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a><strong>反射的作用</strong></h4><p>1.获取任意一个类的所有信息</p><p>2.结合配置文件，动态的创建对象并调用方法</p><h4 id="获取class对象的三种方种方式"><a href="#获取class对象的三种方种方式" class="headerlink" title="获取class对象的三种方种方式"></a><strong>获取class对象的三种方种方式</strong></h4><p><strong>1.Class.forName(“全类名”)</strong>     在源代码阶段使用，<strong>也是我们后面最为常用</strong></p><p> <strong>2.类名.class</strong>                           将字节码加载到内存中时候使用，一般更多的是当做参数进行传递，比如在使用锁的时候，作为锁对象传入</p><p> <strong>3.对象.getClass();</strong>                  创建对象，运行阶段使用，有局限性，只有我么已经有了这个类的对象时，才能使用</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240515150416633.png" alt="image-20240515150416633" style="zoom:50%;" /><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307135820839.png" alt="image-20240307135820839" style="zoom: 67%;" /> <h4 id="反射获取构造方法"><a href="#反射获取构造方法" class="headerlink" title="反射获取构造方法"></a><strong>反射获取构造方法</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307143307785.png" alt="image-20240307143307785" style="zoom:50%;" /><h4 id="利用反射获取成员变量"><a href="#利用反射获取成员变量" class="headerlink" title="利用反射获取成员变量"></a><strong>利用反射获取成员变量</strong></h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307153507394.png" alt="image-20240307153507394" style="zoom: 50%;" /><h4 id="利用反射获取成员方法"><a href="#利用反射获取成员方法" class="headerlink" title="**利用反射获取成员方法 **"></a>**利用反射获取成员方法 **</h4><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307155035374.png" alt="image-20240307155035374" style="zoom: 33%;" /><h4 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h4><p><strong>反射的作用：</strong></p><p>可以获取任意一个类的所有信息</p><p>结合配置文件动态的创建对象并调用方法</p><p><strong>获得字节码的方式</strong>：</p><p>Class.forName（“全类名”);</p><p>类名.class</p><p>对象.getClass();</p><p><strong>如何获取构造函数、成员方法、成员变量</strong>：</p><p>get：获取      set：设置</p><p>Constructor：构造方法      Parameter：参数</p><p>Field：成员变量                  Modifiers：修饰符</p><p>Method：方法                    Declared：私有的</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><strong>动态代理</strong></h2><p><strong>特点:无侵入式的给代码增加额外的功能</strong></p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307164653245.png" alt="image-20240307164653245" style="zoom:50%;" /><p>当调用者想调用对象中的方法的时候，其实不是直接通过对象去调用，而是先去调用代理中的方法，代理会做一些准备的工作，然后代理去调用对象中的方法。</p><p><strong>如何为java对象创建一个代理对象?</strong> </p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240307183329697.png" alt="image-20240307183329697"></p><p>类加载器：将字节码文件加载到内存中的一个东西</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a><strong>注解</strong></h4><p><strong>注解的作用：</strong></p><p>注释是给开发人员看的,不会影响程序的编译和运行.</p><p>注解不是给开发人员看的,是用于给程序看的,会影响程序的编译和运行,比如有的注解是给编译器看的,有的注解给Tomcat看的,有的注解是给框架看的.</p><p><strong>注解的格式：</strong></p><p>以”@注释名”在代码中存在,还可以添加一些参数值,例如</p><p>@SuppressWarnings(value&#x3D;”unchecked”).</p><p>注解使用的地方:</p><p>可以附加在package,class,method,field上面,相当于给他们添加了额外的辅助信息</p><p>我们可以通过反射机制编程实现对这些元数据的访问</p><p><strong>注解本身不执行逻辑，执行逻辑的是反射，AOP是结论，加个注解就等于加切面了</strong></p><h4 id="反射和动态代理"><a href="#反射和动态代理" class="headerlink" title="反射和动态代理"></a><strong>反射和动态代理</strong></h4><p>反射：就是java在运行时能获取任意一个类的所有信息。</p><p>​            结合配置文件，动态的创建对象并调用方法。</p><p>动态代理：动态代理是代理模式的一种，代理模式也是设计模式的之一。</p><p>​                  动态代理常见的两种实现方式：jdk动态代理和CGLIB代理</p><p>​                 jdk动态代理运用了反射的机制，而CGLB代理利用ASM框架，通过修改字节码生成子类来处理。</p><p>​              <strong>动态代理可以无侵入式的给对象增加其他的功能。</strong></p><p>​             动态代理可以控制对原有对象的访问的基础上做一些扩展，比如说记录日志等。</p><p>​            动态代理：在运行中通过反射自动生成代理对象，jdk动态代理只需要我们的代理去实现invokehandler接口中invoke方法，就可以代理任何你想控制访问的                  类。            </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-Javaguide/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-Javaguide/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaguide"><a href="#Javaguide" class="headerlink" title="Javaguide"></a>Javaguide</h1><p>这里用来记录javaguide里面描述的不是很清楚的一些八股,自己整理的便于理解.</p><h2 id="1-java基础"><a href="#1-java基础" class="headerlink" title="1.java基础"></a>1.java基础</h2><h4 id="了解包装类型的缓存机制"><a href="#了解包装类型的缓存机制" class="headerlink" title="了解包装类型的缓存机制?"></a>了解包装类型的缓存机制?</h4><p>java在某些情况下会对包装类型进行缓存,这种机制内部是通过维护一个缓存池来实现的,缓存池缓存了一定范围内的整数.比如说Integer类型,缓存了-128,127的整数对象,当我们去创建integer类型的整数对象时,如果这个对象范围是在-128,127之内的话则直接从缓存池中获取,不会去新建对象,从而节省内存和提高系统性能.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-Austin%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-Austin%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Austin消息中心"><a href="#Austin消息中心" class="headerlink" title="Austin消息中心"></a>Austin消息中心</h1><h2 id="消息中心系统架构"><a href="#消息中心系统架构" class="headerlink" title="消息中心系统架构:"></a>消息中心系统架构:</h2><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240630233133504.png" alt="image-20240630233133504"></p><p>1.首先有个接入层austin-api,是给技术业务方调用我们的接口然后去下发消息.</p><p>2.接入层收到请求后会把数据写入到消息队列MQ中去.</p><p>3.会有一个handle模块（逻辑层）,去消费消息队列中的数据.handle模块做的本质工作就是去下发消息.比如短信、邮件、push等等</p><p>4.这个平台不仅有技术的业务方还有运营这个角色会去使用。运营肯定不会以代码的方式去调用我们api层接口去下发消息，他需要通过消息管理平台的后台去下发消息。</p><p>4.1运营首先要圈选收到消息的人群和指定发送消息的时间，这些都是通过后台去操作的，因为有指定时间，所以会有定时任务的一个模块（corn），等到指定的时间触发之后，corn模块就会调用（接入层）api层下发消息。</p><p>目前有五个模块：后台管理模块，定时任务模块、接入层、逻辑层、实时流处理模块</p><p>有两种角色：技术和运营</p><p>无论是运营还是技术都会比较关心他的下发的消息的一个数据情况</p><p>数据情况：用户是否收到、用户是否点击、被平台规则过滤导致用户没有收到。</p><p>这些数据我们可以从接入层、逻辑层产出的日志中获取</p><p>为了清洗这些日志数据，有个<strong>流处理模块stream</strong>，它会去清洗这些日志，会产生类似报表的数据，然后我们再将这些报表数据给到后台，然后运营和技术都可以通过后台去查看消息的一个整体下发的数据。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240630233213828.png" alt="image-20240630233213828"></p><p><strong>总结</strong>：如果是实时的消息，技术侧直接调用接入层提供的接口去下发消息。</p><p>​            运营侧通过消息管理的后台去圈选指定人群和时间去下发消息，因为有指定时间，所以会有定时任务这一模块，等接受到消息之后，通过发送MQ做一层异步的处理，会有个逻辑消费层去消费mq的数据，去下发不同渠道的消息（短信、企业微信、邮件等）。</p><p>无论是运营还是技术，都希望知道消息下发的结果是咋样的，这些数据一般来源于消息的接入层和逻辑处理层。所以我们会在消息的接入层和逻辑处理层打相关的一些日志（关键链路日志），有了这些日志之后使用<strong>实时流处理模块</strong>（stream）清洗日志，然后洗出来的数据再给到消息管理平台的后台。技术方或者运营方就可以查看消息下发的整体情况是什么样的。</p><h2 id="后台管理模块："><a href="#后台管理模块：" class="headerlink" title="后台管理模块："></a>后台管理模块：</h2><p>后台管理模块功能：前端+后台管理</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240630235205985.png" alt="image-20240630235205985"></p><p>后台主要由两部分组成：对<strong>模版的管理</strong>和对<strong>数据的管理</strong></p><p>无论是运营还是技术，想要在austin发送消息一定要在消息管理后台新建模板或者使用已有的模板，通过用户id、模板id去做消息的全链路追踪：比如说业务方通过这个模板发送了一批消息，我们可以追踪到这批消息的下发情况：比如下发量、到达量、点击量等等</p><h2 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h2><p>1.Maven：项目管理工具、依赖包管理工具</p><p>2.SpringBoot：1.约定大于配置、2.各种starter方便接入中间件、组件</p><p>3.MySql：存储模板、短信发送记录</p><p>4.SpringData JPA：作为ORM框架去连接MySQL，去读取MySql中的数据</p><p>5.XXL-JOB：作为分布式定时任务框架：1.刷新token、2.下发运营指定时间 的消息、3.次日下发消息。</p><p>6.Kafka:  1.作为消息队列：削峰、异步、解耦。2.下发日志3.接入层和逻辑层的解耦。</p><p>7.Redis：存储：1.存储token 2.业务去重</p><p>8.Apollo：分布式配置中心：1.限流值 2.流量配置值 3.账号信息</p><p>9.Flink：实时计算引擎：清理日志</p><p>10.Graylog：作为分布式日志框架：1.作为业务监控（在调用接口时打印日志，就能配置接口QPS监控、RT监控）2.日志检索（集中检索日志的地方，线上可能有多台机器，就不用每台机器上检索）</p><p>11.prometheus+granfna：做系统监控</p><p>12.docker+docker-compose：搭建部署环境</p><h2 id="项目各个模块功能："><a href="#项目各个模块功能：" class="headerlink" title="项目各个模块功能："></a>项目各个模块功能：</h2><p>为什么要分多个模块？</p><p>职责分明,好管理代码.austin有八个模块，在生产环境下很有可能把几个模块单独拎出来部署，比如说后台或者接入层单独拎出来部署，也就是说会有两个系统在线上跑，通过RPC进行交互。<strong>所以分模块也是为了后面扩展和部署。也可以针对某个模块去编译、测试、打包</strong>，<strong>代码的复用</strong>：假设我们将接入模块和后台管理模块分别在不同的机器上部署，那接入模块和后台模块所依赖的common包和support的包就可以直接以jar被依赖，就不用重写公共代码。</p><p><strong>各个包的职责：</strong></p><p>1.austin-common：一般用来放枚举，公共的类</p><p>2.austin-api:接入层的接口</p><p>3.austin-api-impl：接入层接口的实现</p><p> 为什么区分这2和3两个模块：考虑以后可能会接入rpc，当接入rpc后只要提供api层的包给到业务方去用，业务方并不关心你的实现是怎么样的，那api层的依赖是很少的（业务方引入之后，自然就不太会有很多依赖冲突的问题）</p><p>4.austin-support：对中间件的接入，可以理解为大utils包</p><p>5.austin-stream：对flink的实时清洗</p><p>6.austin-corn：主要就是定时任务逻辑（定时任务相关的都写在这）</p><p>7.austin-handler：主要是逻辑层（下发消息、平台逻辑处理）</p><p>8.austin-web：后台管理的接口</p><p>Maven工程如何接入Springboot</p><p>1.在父工程的Maven pom文件中去引入spring-boot-starter-parent这个依赖。</p><p>我电脑里springboot版本是2.3.12</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701103421907.png" alt="image-20240701103421907"></p><p>2.在web工程模块pom文件引入对应的spring-boot-starter-web以及对应的maven插件。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701104018060.png" alt="image-20240701104018060"></p><p>3.写一个Maven（项目系统）的启动类</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701104131604.png" alt="image-20240701104131604"></p><p>4.写一个简单的接口去测试，启动项目测试接口是否正常</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701104232754.png" alt="image-20240701104232754"></p><h2 id="项目中用到的工具类和组件库"><a href="#项目中用到的工具类和组件库" class="headerlink" title="项目中用到的工具类和组件库"></a>项目中用到的工具类和组件库</h2><p>在平时开发的过程中总会看到项目中有utils这个包，这个包会封装我们各种常见的一些方法。我们自己不需要写这些utils，因为网上已经有很多开源的库，已经帮我们去实现了这些utils，我们自己写的没有人家开源的写得好。</p><p>我们项目中使用了<strong>hutool和guava（瓜娃）工具包</strong>，另外我们在开发的过程中肯定会操作json，项目中用的是<strong>fastjson包</strong>。</p><h2 id="Java日志"><a href="#Java日志" class="headerlink" title="Java日志"></a>Java日志</h2><p>线上环境打印日志的时候都要去用到java的日志框架</p><p>jdbc：用java语言操作关系型数据库的一套Api。</p><p>用的是logback作为日志框架是springboot里面内置的：引入logback.xml在资源文件里，然后去写上对应的日志配置。</p><p>用@slf4j 注解  用log.info打印信息  引入lombok依赖</p><p>我们可能会在程序关键的链路上打印对应的日志，然后这些日志会被拿去分析。</p><p>在大数据的领域下，日志是不可或缺的一部分。</p><h2 id="发送一条短信"><a href="#发送一条短信" class="headerlink" title="发送一条短信"></a>发送一条短信</h2><p>互联网中发送一条短信的流程：</p><p>austin————-&gt;短信的服务提供商:比如华为，阿里，腾讯———&gt;运营商：移动、联通、电信。</p><p>我们去对接短信服务商，然后短信服务商帮我们去对接运营商。</p><p>在对接短信服务商的时候有两块需要去做：</p><p>1.签名：让用户知道这条短信是谁下发的</p><p>2.短信模板：短信服务商怕接入方乱发消息，做的安全措施</p><p>pom文件中引入对应短信服务商的<strong>sdk</strong>，拷贝官方提供的代码，组装参数，就能成功发送短信。</p><h2 id="推送平台需要解决的问题"><a href="#推送平台需要解决的问题" class="headerlink" title="推送平台需要解决的问题"></a>推送平台需要解决的问题</h2><p>1.业务方调用austin的接口发送短信的时候，austin给他返回success，但是用户并没有收到短信？</p><p>平台下发短信的时候要把发短信的凭证给记录下来，基于短信渠道，我们在调用服务提供商的接口下发短信的时候，这个过程是异步的，意味着我们去调用服务商的接口，他会给我们返回success，只能说明调用是正常的，但不意味着用户收到了信息。所以说服务提供商会提供对应的接口给我们去拉取相对应的回执。这些回执才能知道这些用户有没有真正的收的到短信。</p><p>解决方案:1.保存下发短信凭证   2.拉取对应的回执。  对这两数据做持久化，并且提供一个后台去给客服和业务方去自查下发的记录。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701222551714.png" alt="image-20240701222551714"></p><ol start="2"><li><p>假如austin只对接了服务提供商腾讯短信,如果服务提供商网关挂了，是不是平台就无法发送消息了？</p><p>作为消息推送平台，他需要接入多个短信服务商，为不同的渠道商配置不同的流量，如果有个渠道商挂了，可以动态的把流量推送给其他渠道商。</p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701223113305.png" alt="image-20240701223113305" style="zoom:67%;" /><p>3.austin在渠道侧，每种渠道QPS有不同的限制，作为平台一定要有监控去监控接口QPS值，每个渠道下发的人数qps是多少。调用渠道接口的QPS是多少。</p><p>通过监控页面来总的看这些指标。</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20240701223942386.png" alt="image-20240701223942386"></p><p>4.用户收到短信，不知道是哪个业务发送的。平台会记录下发凭证，找到下发记录。消息推送平台的人如何知道是哪个业务方下发的呢？所以平台对外提供的接口需要有溯源的功能，溯源的手段就是通过模板。</p></li></ol><p>​       QPS:每秒的请求数</p><p>​        5.短信对账：我们统计成功发送短信的数量和服务商后台统计的数量进行对比。通过hive去统计下发的情况。</p><p>​     6.业务方程序出现问题，连续调用多次，造成短信连续发送。平台要做一些去重相关的功能。（五分钟相同内容去重、一天最多n条记录）</p><p>​     7. 引入一些中间件让系统扩展性变得更好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/28/java%E5%90%8E%E7%AB%AF-ACM%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/07/28/java%E5%90%8E%E7%AB%AF-ACM%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[    <html lang="zh-CN">    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>      <body class="nodata " style="">                 <main style="width:100%">          <div class="blog-content-box">             <div class="article-title-box">                <h1 class="title-article" id="articleContentId">华为机试题输入输出总结</h1>            </div><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">                <div id="content_views" class="htmledit_views">                    <p>华为机试题采用的是<a href="https://so.csdn.net/so/search?q=ACM%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=ACM%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;ACM模式\&quot;}&quot;}" data-tit="ACM模式" data-pretit="acm模式">ACM模式</a>，需要考生自行编写输入和输出，对于已经习惯了只编写函数体部分的考生来说可能会是个挑战，本人尝试根据自己在刷华为机试题过程中遇到的各种输入输出的case进行梳理，希望能够帮助大家尽快适应华为机试题的输入输出模式，减少在这块的耗时，从而将更多的精力放在解题上。</p> <p></p> <h2><a name="t0"></a>一 基础篇</h2> <p>首先对与Java的输入，要用Scanner，因此代码起手第一句，一定得先来上这么一段：</p> <pre data-index="0" class="set-code-show" name="code"><code class="language-java hljs"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scaner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>为了方便我们不重新重新启动程序的情况下，可以反复地测试多组测试应用，我们通常会写一个while循环来反复接受输入，那么while循环的条件判断应该怎么写呢？</p> <p>读取下一个整数/字符/行：</p> <pre data-index="1" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 判断是否有下一个整数</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">while</span>(scanner.hasNextInt())&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-comment">//...</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   scanner.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 判断是否有下一个字符</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">while</span>(scanner.hasNext())&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">//...</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   scanner.next();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 判断是否有一整行</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">scanner.hasNextLine()&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">//...</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   scanner.nextLine();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h2><a name="t1"></a></h2> <p>如果采用has xxxx的话，后面也要用next xxxx。比如前面用hasNextLine，那么后面要用 nextLine 来处理输入。</p> <p>以下是针对各种输入输出条件下举例实现的Java代码：</p> <p></p> <h2><a name="t2"></a>二 正文篇</h2> <h3 id="D5qUf"><a name="t3"></a>1. 多组空格分割的两个整数 （无行数，结束字符限制）</h3> <p id="u8a69aed8">题目描述：</p> <pre id="H739r" data-index="2" class="set-code-show" name="code">输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据包括多组。输出a+b的结果</pre> <p id="u296dbc90"><strong>输入示例</strong>：</p> <pre data-index="3" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">1</span> <span class="hljs-number">5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">10</span> <span class="hljs-number">20</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u0ad227a6">输出示例</p> <pre data-index="4" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">6</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">30</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="5" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNext()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(a + b);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u6e379842"></p> <h3 id="Hfa7E"><a name="t4"></a>2. 第一行组数接空格分割的两个正整数 （行数限制）</h3> <p id="ud8baa2b6"><strong>题目描述</strong>：</p> <pre id="gDOsW" data-index="6" class="set-code-show" name="code">输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9)输出a+b的结果</pre> <p id="ub0d28c16"><strong>输入示例</strong>：</p> <pre data-index="7" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">2</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">1</span> <span class="hljs-number">5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">10</span> <span class="hljs-number">20</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="uab5c7823"><strong>输出示例</strong>：</p> <pre data-index="8" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">6</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">30</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="9" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(a + b);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="ZVLXf"><a name="t5"></a>3. 空行分割的两个正整数，0 0 结束 （结束符限制）</h3> <p id="u6e1bec9a"><strong>题目描述</strong>：</p> <pre id="lKMji" data-index="10" class="set-code-show" name="code">输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入输出a+b的结果</pre> <p id="u1625cc3c"><strong>输入示例</strong>：</p> <pre data-index="11" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">1</span> <span class="hljs-number">5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">10</span> <span class="hljs-number">20</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">0</span> <span class="hljs-number">0</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u096bca28"><strong>输出示例</strong>：</p> <pre data-index="12" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">6</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">30</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="13" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNext()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span>(a ==<span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(a + b);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="NR9cb"><a name="t6"></a>4. 每行第一个为个数后带空格分割整数，0结束 （结束符限制,每行有个数限制）</h3> <p id="u4ef2ebe2"><strong>题目描述</strong>：</p> <pre id="TUSiq" data-index="14" class="set-code-show" name="code">输入数据包括多组。每组数据一行,每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100), n为0的时候结束输入。接下来n个正整数,即需要求和的每个正整数。每组数据输出求和的结果</pre> <p id="uc621dd73"><strong>输入示例</strong>：</p> <pre data-index="15" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">0</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="ub979ed8c"><strong>输出示例</strong>：</p> <pre data-index="16" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">10</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">15</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="17" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNext()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                sum += in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(sum);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="fXGYD"><a name="t7"></a>5. 第一行组数接第一个个数接空格分开的整数 （行数限制,每行有个数限制）</h3> <p id="u0b1842e6"><strong>题目描述</strong>：</p> <pre id="zkvG4" data-index="18" class="set-code-show" name="code">输入的第一行包括一个正整数t(1 &lt;= t &lt;= 100), 表示数据组数。接下来t行, 每行一组数据。每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。接下来n个正整数, 即需要求和的每个正整数。每组数据输出求和的结果</pre> <p id="uef43bbb3"><strong>输入示例</strong>：</p> <pre data-index="19" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">2</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="uf4c532d1"><strong>输出示例</strong>：</p> <pre data-index="20" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">10</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">15</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="21" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                sum += in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(sum);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="F8AGD"><a name="t8"></a>6. 每行第一个为个数后带空格分割整数 (无结束限制,每行有个数限制)</h3> <p id="uc4e689e5"><strong>题目描述</strong>：</p> <pre id="YMNlP" data-index="22" class="set-code-show" name="code">输入数据有多组, 每行表示一组输入数据。每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。接下来n个正整数, 即需要求和的每个正整数。每组数据输出求和的结果</pre> <p id="u69ac667f"></p> <p id="u7ff53e0d"><strong>输入示例</strong>：</p> <pre data-index="23" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u7307fbfa"><strong>输出示例</strong>：</p> <pre data-index="24" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">10</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">15</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="25" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNextInt()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                sum += in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                n--;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(sum);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="qeH3X"><a name="t9"></a>7. 多组空格分隔的正整数 (无结束限制,每行无个数限制,需要当作字符串处理)</h3> <p id="u198439f4"><strong>题目描述</strong>：</p> <pre id="EVb2H" data-index="26" class="set-code-show" name="code">输入数据有多组, 每行表示一组输入数据。每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。每组数据输出求和的结果</pre> <p id="u21132285"><strong>输入示例</strong>：</p> <pre data-index="27" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">4</span> <span class="hljs-number">5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u83467a0c"><strong>输出示例</strong>：</p> <pre data-index="28" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">6</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">9</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">0</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="29" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNextLine()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            String[] s = in.nextLine().split(<span class="hljs-string">" "</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                sum += Integer.parseInt(s[i]);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(sum);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 扩展：第一行组数接空格分开的多个整数 (有行数限制,每行无个数限制,需要当作字符串处理)</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 需要注意的是：读取行数后，要加一行in.nextLine();再读下面的行。</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// eg: 每组数据输出求和的结果</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 3</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 1 2 3</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 4 5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 0 0 0 0 0</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        in.nextLine();  <span class="hljs-comment">// 注意：跳过行数所在行</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++ )&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            String[] s = in.nextLine().split(<span class="hljs-string">" "</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; s.length; j++)&#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                sum += Integer.parseInt(s[j]);  <span class="hljs-comment">// 将字符转成整数类型</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(sum);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="XsUZR"><a name="t10"></a>8. 第一行个数第二行字符串</h3> <p id="ud6134074"><strong>题目描述</strong>：</p> <pre id="KGWvM" data-index="30" class="set-code-show" name="code">输入有两行，第一行n第二行是n个空格隔开的字符串输出一行排序后的字符串，空格隔开，无结尾空格</pre> <p id="u8e6b51c2"><strong>输入示例</strong>：</p> <pre data-index="31" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">5</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">c d a bb e</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="ucb8e0caa"><strong>输出示例</strong>：</p> <pre data-index="32" class="set-code-show" name="code"><code class="language-java hljs">a bb c d e</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="33" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.*;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        in.nextLine();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNext()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            String[] s = in.nextLine().split(<span class="hljs-string">" "</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            Arrays.sort(s);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.out.print(s[i] + <span class="hljs-string">" "</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="DEEIa"><a name="t11"></a>9. 多行空格分开的字符串</h3> <p id="ud9126960"><strong>题目描述</strong>：</p> <pre id="SBQrp" data-index="34" class="set-code-show" name="code">多个测试用例，每个测试用例一行。每行通过空格隔开，有n个字符，n＜100对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</pre> <p id="u86d852fd"><strong>输入示例</strong>：</p> <pre data-index="35" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a c bb</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">f dddd</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">nowcoder</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u12ce5c77"><strong>输出示例</strong>：</p> <pre data-index="36" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a bb c</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">dddd f</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">nowcoder</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="37" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.*;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNextLine()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            String[] s = in.nextLine().split(<span class="hljs-string">" "</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            Arrays.sort(s);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (String c:s) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.out.print(c + <span class="hljs-string">" "</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <h3 id="oWgzo"><a name="t12"></a>10. 多行逗号分开的字符串 （逗号和空格的区别就是最后一个字符输完的时候",“还是” " ）</h3> <p id="ufb002d4e"><strong>题目描述</strong>：</p> <pre id="m0IYY" data-index="38" class="set-code-show" name="code">多个测试用例，每个测试用例一行。每行通过,隔开，有n个字符，n＜100对于每组用例输出一行排序后的字符串，用','隔开，无结尾空格</pre> <p id="u68f0704d"><br><strong>输入示例</strong>：</p> <pre data-index="39" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a,c,bb</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">f,dddd</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">nowcoder</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="uacf445f5"><strong>输出示例</strong>：</p> <pre data-index="40" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a,bb,c</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">dddd,f</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">nowcoder</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="41" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.*;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (in.hasNextLine()) &#123; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            String[] s = in.nextLine().split(<span class="hljs-string">","</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            Arrays.sort(s);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> s.length;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; l - <span class="hljs-number">1</span>; i++) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.out.print(s[i] + <span class="hljs-string">","</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(s[l-<span class="hljs-number">1</span>]);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p id="u1193b1ee">以上就是遇到的各种输入输出的一个总结</p> <p></p> <h2><a name="t13"></a>三 总结篇</h2> <p>有的读者看完上面的介绍之后，可能还是一脸懵逼，希望提供一个万能输入输出的模版，没关系，既然粉丝有需求，我当然是有求必应：</p> <p>输入：</p> <pre data-index="42" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">test</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">3</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">4</span> <span class="hljs-number">5</span> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">7</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <pre data-index="43" class="set-code-show" name="code"><code class="language-java hljs"><ol class="hljs-ln" style="width:1044px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Arrays;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.List;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Scanner;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.stream.Collectors;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">// 获取第一行的输入</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> scanner.nextLine();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">// 获取第2行的输入</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(scanner.nextLine());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">// 获取接下来的N行输入</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                String[] split = scanner.nextLine().split(<span class="hljs-string">"\\s+"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                List&lt;Integer&gt; collect = Arrays.stream(split).map(item -&gt; Integer.parseInt(item)).collect(Collectors.toList());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    &#125;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&#125;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>总结一下就是，读取统一采用&nbsp; scanner.nextLine() 进行获取，</p> <p>情况1:如果是其他数据类型，则进行<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;数据类型转换\&quot;}&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;数据类型转换\&quot;}&quot;}" data-tit="数据类型转换" data-pretit="数据类型转换">数据类型转换</a>；</p> <p>情况2: 如果一整行包含了多个数据，则整体读取下来之后再使用split进行分隔后二次加工；</p> <p>情况3: 如果通过读取某一个参数n来读取接下来的n行，则先读取n，并将其转换为整数，之后使用for循环的方式来读取接下来的n行，对于每一行的处理根据情况再选择情况1和情况2的处理方案今进行处理。</p> <p></p> <p>学会了这个模版，基本可以应对80% 以上的收入输出的case ，其他的特殊场合如果遇到就去参考分解的方案去应对。</p> <p></p> <p></p>                </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6548&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_52894047/article/details/126813836&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>        </div>            </div>                           </main>            </body>       </html>                ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2024/06/26/2024-6-25-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/06/26/2024-6-25-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第三篇文章"><a href="#这是我的第三篇文章" class="headerlink" title="这是我的第三篇文章"></a>这是我的第三篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四篇文章</title>
      <link href="/2024/06/26/2024-6-27-%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/06/26/2024-6-27-%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第四篇文章"><a href="#这是我的第四篇文章" class="headerlink" title="这是我的第四篇文章"></a>这是我的第四篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2024/06/25/2024-6-25-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/06/25/2024-6-25-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/06/24/2024-6-24-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/06/24/2024-6-24-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记1 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>华为面经</title>
      <link href="/2024/06/24/java%E5%90%8E%E7%AB%AF-%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/06/24/java%E5%90%8E%E7%AB%AF-%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="华为面经"><a href="#华为面经" class="headerlink" title="华为面经"></a>华为面经</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="osi七层模型应用层是干什么的？"><a href="#osi七层模型应用层是干什么的？" class="headerlink" title="osi七层模型应用层是干什么的？"></a>osi七层模型应用层是干什么的？</h4><p>为计算机用户提供服务</p><img src="https://zoujiahao.oss-cn-hangzhou.aliyuncs.com/img/image-20240512110255994.png" alt="image-20240512110255994" style="zoom: 50%;" /> <h4 id="udp数据包用在哪一层？"><a href="#udp数据包用在哪一层？" class="headerlink" title="udp数据包用在哪一层？"></a>udp数据包用在哪一层？</h4><p>在传输层</p><h4 id="计算机网络有几层模型？每一层有哪些协议？"><a href="#计算机网络有几层模型？每一层有哪些协议？" class="headerlink" title="计算机网络有几层模型？每一层有哪些协议？"></a>计算机网络有几层模型？每一层有哪些协议？</h4><p>有osi七层模型和TCP&#x2F;IP四层模型</p><p>传输层：UDP和TCP协议</p><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><p>jdk各个版本的特性</p><p>jdk8：interface里面可以有静态方法，有方法体</p><p>数据结构里面增加了红黑树</p><p>Lambda表达式，是个是匿名函数，jdk8允许把函数作为参数传递进方法中</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p><strong>进程</strong>：是程序的一次执行过程，是系统运行程序的基本单位。</p><p><strong>线程</strong>：线程是操作系统进行运算调度的最小单位，它是被包含在进程之中，是进程中的实际运行单位。</p><p>简单理解:应用软件中互相独立,可以同时运行的功能(例如运行360软件是个<strong>进程</strong>,运行360中的木马查杀、电脑清理功能就是<strong>线程</strong>)</p><p><strong>线程和进程的关系，区别及优缺点</strong>：</p><img src="https://zoujiahao.oss-cn-hangzhou.aliyuncs.com/img/image-20240508100944328.png" alt="image-20240508100944328" style="zoom:67%;" /> <p><strong>关系</strong>：一个进程中可以有多个线程，这多个线程共享该进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p><p><strong>区别</strong>：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于各进程间是相互独立的，而各线程则不一定，同一进程中的线程可能会相互影响。</p><p><strong>优缺点</strong>：线程执行开销小，但不利于资源的管理和保护，而进程相反。</p><h4 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a><strong>如何创建线程？</strong></h4><p>一般来说创建线程的方式很很多种：比如继承thread类、实现Runnable接口、实现Callable接口和Future接口、使用线程池等、使用CompleteFuture类等等。准确的说这些都是属于在java代码中<strong>使用</strong>多线程的方法。</p><p>严格来说，java只有一种方式可以创建线程，就是通过new Thread().start()创建，不管哪种方式，最终都是依赖于new Thread().start().</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p><p>RUNNABLE: 可运行状态或就绪状态，线程被调用 <code>start()</code>等待运行状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p><h4 id="可以直接调用Thread类的run方法么"><a href="#可以直接调用Thread类的run方法么" class="headerlink" title="可以直接调用Thread类的run方法么?"></a>可以直接调用Thread类的run方法么?</h4><p>如果直接执行run()方法的话，只是把run()方法当成main线程下的普通方法去执行，并不会在某个线程中执行它，这种就不是多线程工作，只有调用start()方法才能启动线程并使线程进入就绪状态。</p><h4 id="线程池如何创建？线程池的优点？"><a href="#线程池如何创建？线程池的优点？" class="headerlink" title="线程池如何创建？线程池的优点？"></a>线程池如何创建？线程池的优点？</h4><p><strong>线程池的概念：</strong>就是管理一系列线程的资源池，当有任务要处理的时候，直接从线程池中获取线程来处理，处理完线程并不会被立即销毁，而是等待下一个任务。</p><p><strong>线程池的优点</strong>：</p><p>1.<strong>减少线程创建和销毁的开销</strong>：重复利用创建的线程来处理任务，降低新线程创建和销毁造成的消耗。</p><p>2.<strong>提高响应的速度</strong>：当有任务时，不用等新线程创建就能立即执行</p><p>3<strong>提高线程的可管理性和系统稳定性</strong>：线程是个稀缺资源，如果无限制的创建，不仅会消耗系统资源，而且还会降低系统的稳定性，使用线程池的话可以进行统一的分配，调优和监控。</p><p><strong>线程池的缺点</strong>：</p><p>1**.资源的消耗**：即使没有任务执行，线程池中的线程也会消耗系统资源</p><p>2.<strong>复杂的调试</strong>：在线程池环境下调试程序可能比单线程程序更复杂，因为线程的执行是异步的，可能涉及到线程同步和资源共享的问题</p><p>3<strong>潜在的资源泄露</strong>：如果线程池中的线程在完成任务后没有正确的释放资源，例如没有关闭文件或网络连接，可能会导致资源泄露。</p><p>4.<strong>可能造成死锁</strong>：线程池中的线程都在相互等待对方释放资源，从而导致死锁。</p><p><strong>线程池如何创建：</strong></p><p>1.通过ThreadPoolExecutor构造函数来创建（推荐）</p><p>2.通过Executor框架的工具类Executors来创建</p><h4 id="死锁是什么-如何避免"><a href="#死锁是什么-如何避免" class="headerlink" title="死锁是什么,如何避免?"></a>死锁是什么,如何避免?</h4><p>定义:死锁就是多个进程或者线程执行的过程中,因为相互等待对方释放资源而无法继续执行的状态.</p><p><strong>如何避免</strong>:在资源分配的时候,借助于算法对资源分配进行计算评估,使其进入安全状态.</p><h4 id="volatile关键字和synchronized区别"><a href="#volatile关键字和synchronized区别" class="headerlink" title="volatile关键字和synchronized区别"></a>volatile关键字和synchronized区别</h4><p>volatile关键字用于<strong>确保变量的修改对所有的线程都是立即可见的</strong>,并<strong>防止指令重新排序</strong>,在一定程度上保证了线程的安全.</p><p>当一个变量被声明为volatile时,每次读取该变量的值都会从主内存中读取,每次修改该变量时都会立即写回主内存.这样任何一个线程对这个变量的修改都会立即对其他线程可见,避免了缓存中的变量值与主内存中的值不同步的问题.</p><p><strong>volatile关键字和synchronized关键字有什么区别</strong></p><p>这两个是互补的存在,不是对立的存在.</p><p>1.volatile关键字是线程同步的轻量级实现,所以volatile性能肯定比synchronized关键字要好.但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块.</p><p>2.<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。</p><p><code>synchronized</code> 关键字两者都能保证。</p><p>3.volatile关键字主要用于解决变量在多个线程之间的可见性,而synchronized关键字解决的是多个线程之间访问资源的同步性.</p><p>java的理解？</p><h4 id="面向对象三大特征？"><a href="#面向对象三大特征？" class="headerlink" title="面向对象三大特征？"></a>面向对象三大特征？</h4><p>封装、继承、多态</p><p><strong>封装：</strong></p><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p><p><strong>继承：</strong></p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p><strong>多态：</strong></p><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>特点:</p><p>对象类型和引用类型之间具有继承(类)&#x2F;实现(接口)的关系</p><p>引用类型变量发出的方法到底是调用哪个类中的方法，必须在程序运行期间才能确定。</p><p>多态不能调用“只在子类存在但在父类中不存在的方法”</p><p>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</p><h4 id="java垃圾回收机制？讲下里面的算法"><a href="#java垃圾回收机制？讲下里面的算法" class="headerlink" title="java垃圾回收机制？讲下里面的算法"></a>java垃圾回收机制？讲下里面的算法</h4><p>垃圾回收机制是一种自动内存管理系统，自动检测和回收不再使用的内存。</p><p><strong>可达性分析算法</strong>，通过gc Root作为起始点进行搜索，当gc root到对象不可达时，证明此对象是不可用的，不可达的对象会被回收。</p><p>gc root对象的选取，可作为 gc root的对象包括下面几种</p><p>1、虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。<br>2、本地方法栈中JNI(Native方法)引用的对象。<br>3、方法区中的类静态属性引用的对象。<br>4、 方法区中常量引用的对象。</p><h4 id="对于多态有什么深层次的理解？"><a href="#对于多态有什么深层次的理解？" class="headerlink" title="对于多态有什么深层次的理解？"></a>对于多态有什么深层次的理解？</h4><h4 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h4><p>重载：发生在同一个类中，方法名相同，参数的类型、个数、顺序、返回值、修饰符可以不同。</p><p>重写：发生在运行期，是子类继承父类的相同方法，输入的数据一样，但要做出有别于父类的响应，覆盖父类的方法。</p><h4 id="对面向对象-的理解？java该怎么去注意这方面？-：讲了java三大特性"><a href="#对面向对象-的理解？java该怎么去注意这方面？-：讲了java三大特性" class="headerlink" title="对面向对象 的理解？java该怎么去注意这方面？  ：讲了java三大特性"></a>对面向对象 的理解？java该怎么去注意这方面？  ：讲了java三大特性</h4><h4 id="用的jdk版本，和以前的有啥变化"><a href="#用的jdk版本，和以前的有啥变化" class="headerlink" title="用的jdk版本，和以前的有啥变化"></a>用的jdk版本，和以前的有啥变化</h4><p>用过stream流式计算？在处理大量数据的情况下的实现？</p><p>单例模式下如何破坏当前的构造器私有？</p><p>反射 setaccessible&#x3D;true，该如何避免？ 答案：使用双&#x2F;三重检测锁，最安全的方法是用枚举类</p><h4 id="forkjoin是什么？"><a href="#forkjoin是什么？" class="headerlink" title="forkjoin是什么？"></a>forkjoin是什么？</h4><p>答案：在jdk1.7并行执行任务的，在处理大量数据时候可以提高效率</p><h4 id="forkjoin底层是什么？"><a href="#forkjoin底层是什么？" class="headerlink" title="forkjoin底层是什么？"></a>forkjoin底层是什么？</h4><p>forkjoin是基于一种称为工作窃取的算法实现的。</p><p>在 Fork&#x2F;Join 框架中，每个工作线程都有自己的双端队列（deque）来存储任务。这种队列支持两端的操作：工作线程通常从队列的一端添加（fork）新的任务，并从同一端取出（pop）任务来执行。当一个线程完成了自己队列中的所有任务，它可以从其他线程的队列的另一端窃取（steal）任务来执行。</p><h4 id="java默认几个线程？"><a href="#java默认几个线程？" class="headerlink" title="java默认几个线程？"></a>java默认几个线程？</h4><p>2个     main和辅助gc线程</p><p>讲讲工厂模式？它的作用？</p><h4 id="一个单线程处理文件，怎么改造成多线程？"><a href="#一个单线程处理文件，怎么改造成多线程？" class="headerlink" title="一个单线程处理文件，怎么改造成多线程？"></a>一个单线程处理文件，怎么改造成多线程？</h4><p>要求之后主任务线程在其他线程处理完之后发送一个最后的通知</p><p>AOP的概念，切点、切面？</p><h4 id="equals-和hashcode-的关系"><a href="#equals-和hashcode-的关系" class="headerlink" title="equals()和hashcode()的关系?"></a>equals()和hashcode()的关系?</h4><p>hashcode()和equals()都是用来比较两个对象是否相等</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值一定相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li><li>如果重写equals()没有重写hashcode()方法的话可能会导致equals方法判断是相等的两个对象，hashcode值却不相等。</li></ul><h4 id="spring框架中的设计模式了解么？"><a href="#spring框架中的设计模式了解么？" class="headerlink" title="spring框架中的设计模式了解么？"></a>spring框架中的设计模式了解么？</h4><p>详细说一下单例模式？</p><p>spring 中单例模式下的 bean 是线程安全的吗？如果多线程访问这个单例 bean 时，spring</p><p>是怎么实现的？</p><p>spring中注解的底层原理？  答案：注解是基于javaconfig实现的</p><p>JvM中，类加载机制了解么  答案：（双亲委派机制）</p><p>tomacat 里的类加载机制了解吗？也是双亲委派机制吗</p><p>秒杀系统的设计？</p><p>秒杀系统中缓存重要还是消息队列重要</p><p>redis为什么能做缓存？</p><p>mybaits的原理？</p><p>dao 接口里面的方法是怎么和 xml 里面的语句进行关联的</p><p>MySQL 默认事务隔离级别，讲一下全部的隔离级别</p><p>MySQL 可重复读会产生幻读的问题吗？</p><p>表里面有两个字段，一个字段是主键索引，一个是唯一索引，哪个效率更高？</p><p>spring事务传播</p><p>jvm内存模型？</p><p>栈和线程是什么关系？</p><p>堆里面分为哪些区域？新生代又分为几个区？</p><p>Linux命令说几个常用的？</p><p>kill kill-9有什么区别？</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="数据库执行一条语句的过程？"><a href="#数据库执行一条语句的过程？" class="headerlink" title="数据库执行一条语句的过程？"></a>数据库执行一条语句的过程？</h4><p>1.连接器:通过客户端与mysql进行连接，并查询是否有权限</p><p>2.查询缓存：在mysql8.0之前查询是否开启了缓存，如果查到缓存的话直接将结果返回给客户端。</p><p>3.分析器：对sql语句进行语法和语义分析，并生成解析树，再通过预处理器检查解析树是否合法。比如检查查询的数据表数据列是否存在</p><p>4.优化器：生成最优执行方案</p><p>5.执行器：执行sql语句，然后从存储引擎返回数据。</p><h4 id="数据库的左右内外连接？"><a href="#数据库的左右内外连接？" class="headerlink" title="数据库的左右内外连接？"></a>数据库的左右内外连接？</h4><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>最快最稳定的排序算法</p><p>长用的排序算法</p><p>知道的数据结构？</p><p>数组：数组是可以在内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中</p><p>的元素通过数组下标进行访问，数组下标从 0 开始。</p><p>栈：栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。</p><p>栈的特点是：先进后出，或者说是后进先出。</p><p>队列：队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取</p><p>出元素，也就是：先进先出。</p><p>链表：链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链</p><p>表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个</p><p>是指向下一个结点地址的指针域。</p><p>树：树是一种数据结构，它是由 n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合。</p><p>散列表：散列表，也叫哈希表，是根据关键码和值 (key 和 value) 直接进行访问的数据结构，</p><p>通过 key 和 value 来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><p>堆：堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><p>堆中某个节点的值总是不大于或不小于其父节点的值；</p><p>堆总是一棵完全二叉树。</p><p>图：图是由结点的有穷集合 V 和边的集合 E 组成。</p><p>list，set，map 的数据存储区别</p><p>list 和 set 继承自 Collection 接口，是一个个数据存进去的。</p><p>list 里面的元素是有序的，按插入顺序排列的，且是可重复的。</p><p>set 里面的元素是无序的，一般都是使用对应的 map 实现功能，将数据存在 key 上保证唯一性</p><p>map 继承自 Map 接口，map 里面有一个 entry，对应键值对，键值 key 映射着对应的值，</p><p>key 是唯一的，但是 value 不是。</p><p>知道多少种排序？冒泡排序 选择排序 插入排序 希尔排序 快速排序 归并排序 基数排序  堆排序</p><p>说说快速排序？</p><p>1．先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><h4 id="1-TCP、UDP协议是什么？"><a href="#1-TCP、UDP协议是什么？" class="headerlink" title="1.TCP、UDP协议是什么？"></a>1.TCP、UDP协议是什么？</h4><p><strong>UDP协议</strong></p><p>用户数据报协议(User Datagram Protocol)</p><p>UDP是面向无连接的通信协议</p><p>特点：速度快，有大小限制一次最多发送64k，数据不安全，易丢失数据</p><p><strong>TCP协议</strong></p><p>传输控制协议TCP(Transmission Control Protocol)</p><p>TCP协议是面向连接的通信协议，它在通信的两端各建立一个Socket对象，通过Socket产生IO流进行网络通信。</p><p>特点:速度慢，没有大小限制，数据安全</p><h4 id="2-TCP三次握手和四次挥手"><a href="#2-TCP三次握手和四次挥手" class="headerlink" title="2.TCP三次握手和四次挥手"></a>2.TCP三次握手和四次挥手</h4><p><strong>TCP三次握手</strong></p><p>是TCP协议建立连接的一个过程，作用是确保通信端点的双方能够准确的开始数据传输。</p><img src="https://zoujiahao.oss-cn-hangzhou.aliyuncs.com/img/image-20240507153756698.png" alt="image-20240507153756698" style="zoom:67%;" /> <p>过程：客户端向服务器发出连接请求，等待服务器确认。</p><p>​          服务器向客户端返回一个响应，告诉客户端收到了请求。</p><p>​        客户端向服务器再次发出确认信息，连接建立。</p><p><strong>TCP四次挥手</strong></p><p>是TCP协议关闭连接的一个过程，作用是确保连接双方数据完全处理完毕后，能够被正确的关闭。</p> <img src="https://zoujiahao.oss-cn-hangzhou.aliyuncs.com/img/image-20240507154824937.png" alt="image-20240507154824937" style="zoom:67%;" /> <p>过程：客户端向服务器发出取消连接的请求。</p><p>​            服务器向客户端返回一个响应，表示收到客户端取消请求。</p><p>​           服务器将数据处理完毕后，服务器向客户端发出确认取消信息</p><p>​           客户端再次发送确认消息，连接取消。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="9-大顶堆小顶堆怎么删除根节点？"><a href="#9-大顶堆小顶堆怎么删除根节点？" class="headerlink" title="9.大顶堆小顶堆怎么删除根节点？"></a>9.大顶堆小顶堆怎么删除根节点？</h4><h4 id="10-CSRF攻击是什么，怎么预防"><a href="#10-CSRF攻击是什么，怎么预防" class="headerlink" title="10.CSRF攻击是什么，怎么预防"></a>10.CSRF攻击是什么，怎么预防</h4><p>11.springboot常用的注解有哪些？</p><p>12.springboot的配置文件</p><p>13.redis集群的几种方式详细说一下</p><p>14.redis缓存雪崩，缓存击穿，缓存穿透是什么，怎么解决</p><p>15.mysql索引？为什么用B+树</p><h4 id="16-mysql常用数据类型"><a href="#16-mysql常用数据类型" class="headerlink" title="16.mysql常用数据类型"></a>16.mysql常用数据类型</h4><p>数值类型、字符串类型、日期类型</p><h4 id="17-char和varchar的区别"><a href="#17-char和varchar的区别" class="headerlink" title="17.char和varchar的区别"></a>17.char和varchar的区别</h4><p><strong>char是定长字符串,varchar是变长字符串</strong></p><p>18.mysql建索引的原则，索引是不是越多越好，为什么？</p><p>19.springboot用到了哪些设计模式，从源码层面说说你熟悉的以及实现</p><p>20.jvm调优你用什么工具，具体怎么做的，怎么调优</p><p>21.线程优先级，操作系统线程与jvm线程</p><p>22.cas怎么交换</p><h2 id="2024-5-13华为面试问题"><a href="#2024-5-13华为面试问题" class="headerlink" title="2024.5.13华为面试问题"></a>2024.5.13华为面试问题</h2><h4 id="Stringbuilder和Stringbuffer的区别有哪些？"><a href="#Stringbuilder和Stringbuffer的区别有哪些？" class="headerlink" title="Stringbuilder和Stringbuffer的区别有哪些？"></a>Stringbuilder和Stringbuffer的区别有哪些？</h4><p>Stringbuilder对方法或者调用的方法没有加同步锁：<strong>非线程安全</strong></p><p>Stringbuffer对方法或调用的方法添加了同步锁：<strong>是线程安全的</strong></p><p>相同情况下，Stringbuilder会比Stringbuffer性能高，但要冒多线程不安全的风险。</p><h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p>浅拷贝：会创建一个新对象,如果原对象属性是基本属性,拷贝的就是基本类型的值.如果是引用类型的话,会复制内部对象的引用地址。</p><p>深拷贝：将这个对象内部属性的基本数据类型拷贝过来，字符串类型复用串池里面的，引用数据类型会创建一个新的空间（拷贝过后记录的地址值不同）。</p><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p><strong>关系</strong>：一个进程中可能包含多个线程，线程共享该进程中堆和方法区的资源，同时每个线程也有自己的程序计数器，虚拟机栈和本地方法栈</p><p><strong>区别</strong>：线程是进程划分成的更小执行单位，他们最大的不同就是各个进程之间的运行是相互独立的，线程则不一定，同一进程中的线程之间可能会相互影响。</p><p>线程执行开销小，但不利于资源的管理和保护，进程相反</p><h4 id="Exception-和Error-的区别"><a href="#Exception-和Error-的区别" class="headerlink" title="Exception 和Error 的区别"></a>Exception 和Error 的区别</h4><p>Error：属于程序无法处理错误，不建议使用catch捕获。比如内存溢出、java虚拟机运行错误。</p><p>Exception：属于程序本身可以处理的异常，可以通过catch来捕获。</p><h4 id="聊不了解JVM"><a href="#聊不了解JVM" class="headerlink" title="聊不了解JVM"></a>聊不了解JVM</h4><h4 id="了解反射机制么？"><a href="#了解反射机制么？" class="headerlink" title="了解反射机制么？"></a>了解反射机制么？</h4><h4 id="io输入输出流有哪些？"><a href="#io输入输出流有哪些？" class="headerlink" title="io输入输出流有哪些？"></a>io输入输出流有哪些？</h4><h4 id="数据库索引的底层结构是什么？还有哪些"><a href="#数据库索引的底层结构是什么？还有哪些" class="headerlink" title="数据库索引的底层结构是什么？还有哪些?"></a>数据库索引的底层结构是什么？还有哪些?</h4><p>B+树     Hash    full-text.</p><h4 id="数据库锁有哪些？"><a href="#数据库锁有哪些？" class="headerlink" title="数据库锁有哪些？"></a>数据库锁有哪些？</h4><h4 id="数据库的事务？"><a href="#数据库的事务？" class="headerlink" title="数据库的事务？"></a>数据库的事务？</h4><h4 id="数据库的字段类型有哪些？"><a href="#数据库的字段类型有哪些？" class="headerlink" title="数据库的字段类型有哪些？"></a>数据库的字段类型有哪些？</h4><h4 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h4><h4 id="timedate和timestamp的区别"><a href="#timedate和timestamp的区别" class="headerlink" title="timedate和timestamp的区别"></a>timedate和timestamp的区别</h4><h4 id="2024-5-28运维开发"><a href="#2024-5-28运维开发" class="headerlink" title="2024.5.28运维开发:"></a><strong>2024.5.28运维开发</strong>:</h4><p>1.进程和线程的区别</p><p>2.TCP和UDP协议的区别?</p><p>3.三次握手和四次挥手?</p><p>4.ping属于什么协议?</p><p>5.事务的四大特性?</p><p>6.索引是干什么的?</p><p>7.索引存储过程?(这个没听太清楚)</p><p>8.数据库中针对字段从高到低排序,用什么?</p><p>9.delete和drop的区别?</p><p>10.数据库中对锁有没有了解?锁的性质?</p><p>11.怎么保证数据库高可靠性?</p><p>12.数据库数据丢失的话,怎么解决(比如说宕机)</p><p>13.sql注入??</p><h1 id="手撕代码："><a href="#手撕代码：" class="headerlink" title="手撕代码："></a>手撕代码：</h1><p>力扣：</p><p>02.05链表求和</p><p>328： 奇偶链表</p><p>409 ：最长回文串</p><p>49：字母异位词分组</p><p>1019：链表中的下一个更大节点</p><p>划分字符串</p><p>最长公共字数组</p><p>斐波那契数列</p><p>优化空间复杂度</p><p>224：基本计算器</p><p>1047：删除字符串中的所有相邻重复项</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>项目中遇到的问题，怎么解决？</p><p>项目中遇到委屈的事</p><p>项目中另外几个同学负责什么</p><p>遇到的挫折？怎么解决</p><p>对华为的看法？对华为云的了解</p><p>为什么跨专业学编程？</p><p>自己的优势</p><p>个人的规划？</p><p>项目中学习到了什么？</p><p>​        </p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 笔记1 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
